L 1 "rs274ngc_pre.c"
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N   /* rs274ngc.cc
N
N   This rs274ngc.cc file contains the source code for (1) the kernel of
N   several rs274ngc interpreters and (2) two of the four sets of interface
N   functions declared in canon.hh:
N   1. interface functions to call to tell the interpreter what to do.
N   These all return a status value.
N   2. interface functions to call to get information from the interpreter.
N
N   Kernel functions call each other. A few kernel functions are called by
N   interface functions.
N
N   Interface function names all begin with "rs274ngc_".
N
N   Error handling is by returning a status value of either a non-error
N   code (RS274NGC_OK, RS274NGC_EXIT, etc.) or some specific error code
N   from each function where there is a possibility of error.  If an error
N   occurs, processing is always stopped, and control is passed back up
N   through the function call hierarchy to an interface function; the
N   error code is also passed back up. The stack of functions called is
N   also recorded. The external program calling an interface function may
N   then handle the error further as it sees fit.
N
N   Since returned values are usually used as just described to handle the
N   possibility of errors, an alternative method of passing calculated
N   values is required. In general, if function A needs a value for
N   variable V calculated by function B, this is handled by passing a
N   pointer to V from A to B, and B calculates and sets V.
N
N   There are a lot of functions named read_XXXX. All such functions read
N   characters from a string using a counter. They all reset the counter
N   to point at the character in the string following the last one used by
N   the function. The counter is passed around from function to function
N   by using pointers to it. The first character read by each of these
N   functions is expected to be a member of some set of characters (often
N   a specific character), and each function checks the first character.
N
N   This version of the interpreter not saving input lines. A list of all
N   lines will be needed in future versions to implement loops, and
N   probably for other purposes.
N
N   This version does not use any additional memory as it runs. No
N   memory is allocated by the source code.
N
N   This version does not suppress superfluous commands, such as a command
N   to start the spindle when the spindle is already turning, or a command
N   to turn on flood coolant, when flood coolant is already on.  When the
N   interpreter is being used for direct control of the machining center,
N   suppressing superfluous commands might confuse the user and could be
N   dangerous, but when it is used to translate from one file to another,
N   suppression can produce more concise output. Future versions might
N   include an option for suppressing superfluous commands.
N
N   This file has been arranged typographically so that it may be used
N   for compiling fifteen different executables. The file may be compiled
N   as is for a six-axis interpreter. The file may be pre-preprocessed
N   into "pre.cc" by "prepre" (a lex-based pre-processor). All
N   fifteen executables may be compiled from the pre.cc file. The special
N   typography items are:
N
N   1. Any line with the comment /^AA^/, /^BB^/, or /^CC^/ at the end
N   (where ^ is replaced by *).
N
N   2. Calls to the canonical functions STRAIGHT_FEED, STRAIGHT_TRAVERSE,
N   STRAIGHT_PROBE, and ARC_FEED. These are always set on two lines
N   with the rotary axes on the second line:
N
N   3. Calls to the canonical function SET_ORIGIN_OFFSETS.  These are
N   always set on six lines, with one argument per line.
N
N   4. Anywhere else AA, BB, or CC appears followed by an underscore.
N
N   The pre-preprocessor looks for these items of typography and, in the output
N   file (pre.cc), resets them appropriately marked with #ifdef and #endif.
N   The rest of the text is put into the output file unchanged.
N
N   The compiler flags are:
N
N   1. -DAA to have an A-axis
N
N   2. -DBB to have a B-axis
N
N   3. -DCC to have a C-axis
N
N   4. -DALL_AXES to have a 3-, 4-, or 5-axis interpreter use all three
N   rotary axes in canonical function calls. In those calls, the value
N   for a rotary axis not compiled into an interpreter is always zero.
N
N   5. -DAXIS_ERROR to have a 3-, 4-, or 5-axis interpreter signal an error
N   if the input RS274 code has a value for an axis not compiled in. If
N   this flag is not used, the interpreter will read and ignore values for
N   axes not compiled in.
N
N   */
N
N   /****************************************************************************/
N
N#include <stdio.h>
L 1 "C:\Keil\ARM\RV31\INC\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 137287 $
N * Checkin $Date: 2008-08-27 13:36:52 +0100 (Wed, 27 Aug 2008) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
L 123 "rs274ngc_pre.c" 2
N#include <stdlib.h>
L 1 "C:\Keil\ARM\RV31\INC\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 152811 $
N * Checkin $Date: 2010-03-04 09:02:00 +0000 (Thu, 04 Mar 2010) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
L 124 "rs274ngc_pre.c" 2
N#include <math.h>
L 1 "C:\Keil\ARM\RV31\INC\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 163268 $ Codemist 0.03
N * Checkin $Date: 2010-12-03 13:57:26 +0000 (Fri, 03 Dec 2010) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (1L && 199901L <= 199409L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_SOFTFP __declspec(__nothrow) __softfp
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __pure
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE __inline
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#ifdef __BIG_ENDIAN
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* ndef __BIG_ENDIAN */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* ndef __BIG_ENDIAN */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern __softfp unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Nextern __softfp unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#define HUGE_VAL ((double)__INFINITY__)
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __pure double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __pure double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    __inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    __inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __pure double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __pure double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __pure double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
X__inline __declspec(__nothrow) __pure double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
X__inline __declspec(__nothrow) __pure float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __pure double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __pure float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
X__inline __declspec(__nothrow) __pure float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __pure float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __pure float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
Sextern _ARMABI __int64 llrint(double /*x*/);
Sextern _ARMABI __int64 llrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x)     { return llrint((double)__x); }
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
Sextern _ARMABI __int64 llround(double /*x*/);
Sextern _ARMABI __int64 llroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x)     { return llround((double)__x); }
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __int64 llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __int64 llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __int64 llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __int64 llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S      using ::std::fmal;
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S      using ::std::lrintl;
S      using ::std::llrint;
S      using ::std::llrintf;
S      using ::std::llrintl;
S      using ::std::lround;
S      using ::std::lroundf;
S      using ::std::lroundl;
S      using ::std::llround;
S      using ::std::llroundf;
S      using ::std::llroundl;
S      using ::std::nan;
S      using ::std::nanf;
S      using ::std::nanl;
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S      using ::std::remquol;
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#endif /* __math_h */
N
N/* end of math.h */
L 125 "rs274ngc_pre.c" 2
N#include <string.h>
L 1 "C:\Keil\ARM\RV31\INC\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
L 126 "rs274ngc_pre.c" 2
N#include <ctype.h>
L 1 "C:\Keil\ARM\RV31\INC\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision: 137298 $
N * Checkin $Date: 2008-08-27 14:28:42 +0100 (Wed, 27 Aug 2008) $
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
S#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __A as __N+__X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __S 1            /* whitespace           */
N#define __P 2            /* punctuation          */
N#define __B 4            /* blank                */
N#define __L 8            /* lower case letter    */
N#define __U 16           /* upper case letter    */
N#define __N 32           /* (decimal) digit      */
N#define __C 64           /* control chars        */
N#define __X 128          /* A-F and a-f          */
N#define __A (__N+__X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __pure unsigned char **__rt_ctype_table(void);
N
N#define __ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__ctype[__c] & (__U+__L+__N)); }
N#else
N    #define isalnum(c) (__ctype[c] & (__U+__L+__N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__ctype[__c] & (__U+__L+__X)); }
N#else
N    #define isalpha(c) (__ctype[c] & (__U+__L+__X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__ctype[__c] & __C); }
N#else
N    #define iscntrl(c) (__ctype[c] & __C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __N, not just __N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__ctype[__c] == __N); }
N#else
N    #define isdigit(c) (__ctype[c] == __N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__ctype[__c] & (__L+__U+__N+__X+__P));}
N#else
N    #define isgraph(c) (__ctype[c]&(__L+__U+__N+__X+__P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__ctype[__c] & __L); }
N#else
N    #define islower(c) (__ctype[c] & __L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__ctype[__c] & (__L+__U+__N+__P+__B)); }
N#else
N    #define isprint(c) (__ctype[c] & (__L+__U+__N+__P+__B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__ctype[__c] & __P); }
N#else
N    #define ispunct(c) (__ctype[c] & __P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__ctype[__c] & __S); }
N#else
N    #define isspace(c) (__ctype[c] & __S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__ctype[__c] & __U); }
N#else
N    #define isupper(c) (__ctype[c] & __U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __N or __X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
X__inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__ctype[__c]) & __X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__ctype[c]) & __X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
L 127 "rs274ngc_pre.c" 2
N#include "rs274ngc.h"
L 1 "rs274ngc.h" 1
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N#ifndef RS274NGC_HH
N#define RS274NGC_HH
N
N   /*
N     rs274ngc.hh
N
N   Declarations for the rs274abc translator.
N
N   */
N
N   /**********************/
N   /* INCLUDE DIRECTIVES */
N   /**********************/
N
N#include <stdio.h>
N#include "canon.h"
L 1 "canon.h" 1
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N#ifndef CANON_HH
N#define CANON_HH
N
N   /* canon.hh
N
N   This is the header file that all applications that use the
N   canonical commands for three- to six-axis machining should include.
N
N   Three mutually orthogonal (in a right-handed system) X, Y, and Z axes
N   are always present. In addition, there may be zero to three rotational
N   axes: A (parallel to the X-axis), B (parallel to the Y-axis), and C
N   (parallel to the Z-axis).
N
N   In the functions that use rotational axes, the axis value is that of a
N   wrapped linear axis, in degrees.
N
N   It is assumed in these activities that the spindle tip is always at
N   some location called the "current location," and the controller always
N   knows where that is. It is also assumed that there is always a
N   "selected plane" which must be the XY-plane, the YZ-plane, or the
N   ZX-plane of the machine.
N
N   */
N
Ntypedef int CANON_PLANE;
N#define CANON_PLANE_XY 1
N#define CANON_PLANE_YZ 2
N#define CANON_PLANE_XZ 3
N
Ntypedef int CANON_UNITS;
N#define CANON_UNITS_INCHES 1
N#define CANON_UNITS_MM 2
N#define CANON_UNITS_CM 3
N
Ntypedef int CANON_MOTION_MODE;
N#define CANON_EXACT_STOP 1
N#define CANON_EXACT_PATH 2
N#define CANON_CONTINUOUS 3
N
Ntypedef int CANON_SPEED_FEED_MODE;
N#define CANON_SYNCHED 1
N#define CANON_INDEPENDENT 2
N
Ntypedef int CANON_DIRECTION;
N#define CANON_STOPPED 1
N#define CANON_CLOCKWISE 2
N#define CANON_COUNTERCLOCKWISE 3
N
Ntypedef int CANON_FEED_REFERENCE;
N#define CANON_WORKPIECE 1
N#define CANON_XYZ 2
N
Ntypedef int CANON_SIDE;
N#define CANON_SIDE_RIGHT 1
N#define CANON_SIDE_LEFT 2
N#define CANON_SIDE_OFF 3
N
Ntypedef int CANON_AXIS;
N#define CANON_AXIS_X 1
N#define CANON_AXIS_Y 2
N#define CANON_AXIS_Z 3
N#define CANON_AXIS_A 4
N#define CANON_AXIS_B 5
N#define CANON_AXIS_C 6
N
N   /* Currently using the typedefs above rather than the enums below
N   typedef enum {CANON_PLANE_XY, CANON_PLANE_YZ, CANON_PLANE_XZ} CANON_PLANE;
N   typedef enum {CANON_UNITS_INCHES, CANON_UNITS_MM, CANON_UNITS_CM} CANON_UNITS;
N   typedef enum {CANON_EXACT_STOP, CANON_EXACT_PATH, CANON_CONTINUOUS}
N   CANON_MOTION_MODE;
N   typedef enum {CANON_SYNCHED, CANON_INDEPENDENT} CANON_SPEED_FEED_MODE;
N   typedef enum {CANON_STOPPED, CANON_CLOCKWISE, CANON_COUNTERCLOCKWISE}
N   CANON_DIRECTION;
N   typedef enum {CANON_WORKPIECE, CANON_XYZ} CANON_FEED_REFERENCE;
N   typedef enum {CANON_SIDE_RIGHT, CANON_SIDE_LEFT, CANON_SIDE_OFF} CANON_SIDE;
N   typedef enum {CANON_AXIS_X, CANON_AXIS_Y, CANON_AXIS_Z, CANON_AXIS_A,
N   CANON_AXIS_B, CANON_AXIS_C} CANON_AXIS;
N   */
N
N/*
Nstruct CANON_VECTOR
N{
N    double x, y, z;
N    CANON_VECTOR() {}
N    CANON_VECTOR(double _x, double _y, double _z) 
N	{
N		x = _x; y = _y; z = _z;
N	}
N};
N
Nstruct CANON_POSITION
N{
N    CANON_POSITION() {}
N    CANON_POSITION(double _x, double _y, double _z
N    #ifdef AA
N        , double _a
N    #endif
N    #ifdef BB
N        , double _b
N    #endif
N    #ifdef CC
N        , double _c
N    #endif
N        )
N    {
N        x = _x; y = _y; z = _z;
N#ifdef AA
N        a = _a;
N#endif
N#ifdef BB
N        b = _b;
N#endif
N#ifdef CC
N        c = _c;
N#endif
N    }
N    double x, y, z
N    #ifdef AA
N        , a
N    #endif
N    #ifdef BB
N        , b
N    #endif
N    #ifdef CC
N        , c
N    #endif
N        ;
N};
N*/
N
N   /* Tools are numbered 1..CANON_TOOL_MAX, with tool 0 meaning no tool. */
N#define CANON_TOOL_MAX 128                        // max size of carousel handled
N#define CANON_TOOL_ENTRY_LEN 256                  // how long each file line can be
N
Ntypedef struct canon_tool_table
N{
N    int id;
N    double length;
N    double diameter;
N}CANON_TOOL_TABLE;
N
N   /* Initialization */
N
N   /* reads world model data into the canonical interface */
W "canon.h" 169 13 Deprecated declaration INIT_CANON - give arg types
Nextern void INIT_CANON();
N
N   /* Representation */
N
Nextern void SET_ORIGIN_OFFSETS(
Ndouble x, double y, double z
N#ifdef AA
S, double a
N#else
N#ifdef ALL_AXES
S, double a
N#endif
N#endif
N#ifdef BB
S, double b
N#else
N#ifdef ALL_AXES
S, double b
N#endif
N#endif
N#ifdef CC
S, double c
N#else
N#ifdef ALL_AXES
S, double c
N#endif
N#endif
N);
N
N   /* Offset the origin to the point with absolute coordinates x, y, z,
N   a, b, and c. Values of x, y, z, a, b, and c are real numbers. The units
N   are whatever length units are being used at the time this command is
N   given. */
N
Nextern void USE_LENGTH_UNITS(CANON_UNITS u);
N
N   /* Use the specified units for length. Conceptually, the units must
N   be either inches or millimeters. */
N
Nextern void SELECT_PLANE(CANON_PLANE pl);
N
N   /* Use the plane designated by selected_plane as the selected plane.
N   Conceptually, the selected_plane must be the XY-plane, the XZ-plane, or
N   the YZ-plane. */
N
N   /* Free Space Motion */
N
Nextern void SET_TRAVERSE_RATE(double rate);
N
N   /* Set the traverse rate that will be used when the spindle traverses. It
N   is expected that no cutting will occur while a traverse move is being
N   made. */
N
Nextern void STRAIGHT_TRAVERSE(
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N   /*
N
N   Move at traverse rate so that at any time during the move, all axes
N   have covered the same proportion of their required motion. The final
N   XYZ position is given by x, y, and z. If there is an a-axis, its final
N   position is given by a_position, and similarly for the b-axis and c-axis.
N   A more positive value of a rotational axis is in the counterclockwise
N   direction.
N
N   Clockwise or counterclockwise is from the point of view of the
N   workpiece. If the workpiece is fastened to a turntable, the turntable
N   will turn clockwise (from the point of view of the machinist or anyone
N   else not moving with respect to the machining center) in order to make
N   the tool move counterclockwise from the point of view of the
N   workpiece.
N
N   */
N
N   /* Machining Attributes */
N
Nextern void SET_FEED_RATE(double rate);
N
N   /* 
N
N   SET_FEED_RATE sets the feed rate that will be used when the spindle is
N   told to move at the currently set feed rate. The rate is either:
N   1. the rate of motion of the tool tip in the workpiece coordinate system,
N   which is used when the feed_reference mode is "CANON_WORKPIECE", or
N   2. the rate of motion of the tool tip in the XYZ axis system, ignoring
N   motion of other axes, which is used when the feed_reference mode is
N   "CANON_XYZ".
N
N   The units of the rate are:
N
N   1. If the feed_reference mode is CANON_WORKPIECE:
N   length units (inches or millimeters according to the setting of
N   CANON_UNITS) per minute along the programmed path as seen by the
N   workpiece.
N
N   2. If the feed_reference mode is CANON_XYZ:
N   A. For motion including one rotational axis only: degrees per minute.
N   B. For motion including two rotational axes only: degrees per minute
N   In this case, the rate applies to the axis with the larger angle
N   to cover, and the second rotational axis rotates so that it has
N   always completed the same proportion of its required motion as has
N   the rotational axis to which the feed rate applies.
N   C. For motion involving one or more of the XYZ axes (with or without
N   simultaneous rotational axis motion): length units (inches or
N   millimeters according to the setting of CANON_UNITS) per minute
N   along the programmed XYZ path.
N
N   */
N
Nextern void SET_FEED_REFERENCE(CANON_FEED_REFERENCE reference);
N
N   /*
N
N   This sets the feed_reference mode to either CANON_WORKPIECE or
N   CANON_XYZ.
N
N   The CANON_WORKPIECE mode is more natural and general, since the rate
N   at which the tool passes through the material must be controlled for
N   safe and effective machining. For machines with more than the three
N   standard XYZ axes, however, computing the feed rate may be
N   time-consuming because the trajectories that result from motion in
N   four or more axes may be complex. Computation of path lengths when
N   only XYZ motion is considered is quite simple for the two standard
N   motion types (straight lines and helical arcs).
N
N   Some programming languages (rs274kt, in particular) use CANON_XYZ
N   mode. In these languages, the task of dealing with the rate at which
N   the tool tip passes through material is pushed back on the NC-program
N   generator, where the computation of path lengths is (almost always in
N   1995) an off-line activity where speed of calculation is not critical.
N
N   In CANON_WORKPIECE mode, some motions cannot be carried out as fast as
N   the programmed feed rate would require because axis motions tend to
N   cancel each other. For example, an arc in the YZ-plane can exactly
N   cancel a rotation around the A-axis, so that the location of the tool
N   tip with respect to the workpiece does not change at all during the
N   motion; in this case, the motion should take no time, which is
N   impossible at any finite rate of axis motion. In such cases, the axes
N   should be moved as fast as possible consistent with accurate
N   machining.
N
N   It would be possible to omit the SET_FEED_REFERENCE command from the
N   canonical commands and operate always in one mode or the other,
N   letting the interpreter issue SET_FEED_RATE commands, if necessary to
N   compensate if the NC language being interpreted used the other mode.
N
N   This would create two disadvantages when the feed_reference mode
N   assumed by the canonical commands differed from that assumed by the NC
N   language being interpreted:
N
N   1. The output code could have a lot of SET_FEED_RATE commands not
N   found in the input code; this is a relatively minor consideration.
N
N   2. If the interpreter reads a program in language which uses the
N   CANON_XYZ mode and writes canonical commands in the CANON_WORKPIECE
N   mode, both the interpreter and the executor of the output canonical
N   commands would have to perform a lot of complex calculations. With the
N   SET_FEED_REFERENCE command available, both do only simple calculations
N   for the same motions.
N
N   */
N
Nextern void SET_MOTION_CONTROL_MODE(CANON_MOTION_MODE mode);
N
N   /*
N
N   This sets the motion control mode to one of: CANON_EXACT_STOP,
N   CANON_EXACT_PATH, or CANON_CONTINUOUS.
N
N   */
N
Nextern void SET_CUTTER_RADIUS_COMPENSATION(double radius);
N
N   /* Set the radius to use when performing cutter radius compensation. */
N
Nextern void START_CUTTER_RADIUS_COMPENSATION(int direction);
N
N   /* Conceptually, the direction must be left (meaning the cutter
N   stays to the left of the programmed path) or right. */
N
W "canon.h" 370 13 Deprecated declaration STOP_CUTTER_RADIUS_COMPENSATION - give arg types
Nextern void STOP_CUTTER_RADIUS_COMPENSATION();
N
N   /* Do not apply cutter radius compensation when executing spindle
N   translation commands. */
N
W "canon.h" 375 13 Deprecated declaration START_SPEED_FEED_SYNCH - give arg types
Nextern void START_SPEED_FEED_SYNCH();
W "canon.h" 376 13 Deprecated declaration STOP_SPEED_FEED_SYNCH - give arg types
Nextern void STOP_SPEED_FEED_SYNCH();
N
N   /* Machining Functions */
N
Nextern void ARC_FEED(
Ndouble first_end,
Ndouble second_end,
Ndouble first_axis,
Ndouble second_axis,
Nint rotation,
Ndouble axis_end_point
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Move in a helical arc from the current location at the existing feed
N   rate. The axis of the helix is parallel to the x, y, or z axis,
N   according to which one is perpendicular to the selected plane. The
N   helical arc may degenerate to a circular arc if there is no motion
N   parallel to the axis of the helix.
N
N   1. If the selected plane is the xy-plane:
N   A. first_end is the x-coordinate of the end of the arc.
N   B. second_end is the y-coordinate of the end of the arc.
N   C. first_axis is the x-coordinate of the axis (center) of the arc.
N   D. second_axis is the y-coordinate of the axis.
N   E. axis_end_point is the z-coordinate of the end of the arc.
N
N   2. If the selected plane is the yz-plane:
N   A. first_end is the y-coordinate of the end of the arc.
N   B. second_end is the z-coordinate of the end of the arc.
N   C. first_axis is the y-coordinate of the axis (center) of the arc.
N   D. second_axis is the z-coordinate of the axis.
N   E. axis_end_point is the x-coordinate of the end of the arc.
N
N   3. If the selected plane is the zx-plane:
N   A. first_end is the z-coordinate of the end of the arc.
N   B. second_end is the x-coordinate of the end of the arc.
N   C. first_axis is the z-coordinate of the axis (center) of the arc.
N   D. second_axis is the x-coordinate of the axis.
N   E. axis_end_point is the y-coordinate of the end of the arc.
N
N   If rotation is positive, the arc is traversed counterclockwise as
N   viewed from the positive end of the coordinate axis perpendicular to
N   the currently selected plane. If rotation is negative, the arc is
N   traversed clockwise. If rotation is 0, first_end and second_end must
N   be the same as the corresponding coordinates of the current point and
N   no arc is made (but there may be translation parallel to the axis
N   perpendicular to the selected plane and motion along the rotational axes).
N   If rotation is 1, more than 0 but not more than 360 degrees of arc
N   should be made. In general, if rotation is n, the amount of rotation
N   in the arc should be more than ([n-1] x 360) but not more than (n x
N   360).
N
N   The radius of the helix is determined by the distance from the current
N   location to the axis of helix or by the distance from the end location
N   to the axis of the helix. It is recommended that the executing system
N   verify that the two radii are the same (within some tolerance) at the
N   beginning of executing this function.
N
N   While the XYZ motion is going on, move the rotational axes so that
N   they have always covered the same proportion of their total motion as
N   a point moving along the arc has of its total motion.
N
N   */
N
Nextern void STRAIGHT_FEED(
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Move at existing feed rate so that at any time during the move,
N   all axes have covered the same proportion of their required motion.
N   The meanings of the parameters is the same as for STRAIGHT_TRAVERSE.*/
N
Nextern void STRAIGHT_PROBE (
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Perform a probing operation. This is a temporary addition to the
N   canonical machining functions and its semantics are not defined.
N   When the operation is finished, all axes should be back where they
N   started. */
N
W "canon.h" 520 13 Deprecated declaration STOP - give arg types
Nextern void STOP();
N
N   /* stop motion after current feed */
N
Nextern void DWELL(double seconds);
N
N   /* freeze x,y,z for a time */
N
N   /* Spindle Functions */
N
W "canon.h" 530 13 Deprecated declaration SPINDLE_RETRACT_TRAVERSE - give arg types
Nextern void SPINDLE_RETRACT_TRAVERSE();
N
N   /* Retract the spindle at traverse rate to the fully retracted position. */
N
W "canon.h" 534 13 Deprecated declaration START_SPINDLE_CLOCKWISE - give arg types
Nextern void START_SPINDLE_CLOCKWISE();
N
N   /* Turn the spindle clockwise at the currently set speed rate. If the
N   spindle is already turning that way, this command has no effect. */
N
W "canon.h" 539 13 Deprecated declaration START_SPINDLE_COUNTERCLOCKWISE - give arg types
Nextern void START_SPINDLE_COUNTERCLOCKWISE();
N
N   /* Turn the spindle counterclockwise at the currently set speed rate. If
N   the spindle is already turning that way, this command has no effect. */
N
Nextern void SET_SPINDLE_SPEED(double r);
N
N   /* Set the spindle speed that will be used when the spindle is turning.
N   This is usually given in rpm and refers to the rate of spindle
N   rotation. If the spindle is already turning and is at a different
N   speed, change to the speed given with this command. */
N
W "canon.h" 551 13 Deprecated declaration STOP_SPINDLE_TURNING - give arg types
Nextern void STOP_SPINDLE_TURNING();
N
N   /* Stop the spindle from turning. If the spindle is already stopped, this
N   command may be given, but it will have no effect. */
N
W "canon.h" 556 13 Deprecated declaration SPINDLE_RETRACT - give arg types
Nextern void SPINDLE_RETRACT();
Nextern void ORIENT_SPINDLE(double orientation, CANON_DIRECTION direction);
W "canon.h" 558 13 Deprecated declaration LOCK_SPINDLE_Z - give arg types
Nextern void LOCK_SPINDLE_Z();
W "canon.h" 559 13 Deprecated declaration USE_SPINDLE_FORCE - give arg types
Nextern void USE_SPINDLE_FORCE();
W "canon.h" 560 13 Deprecated declaration USE_NO_SPINDLE_FORCE - give arg types
Nextern void USE_NO_SPINDLE_FORCE();
N
N   /* Tool Functions */
Nextern void USE_TOOL_LENGTH_OFFSET(double length);
N
Nextern void CHANGE_TOOL(int slot);                /* slot is slot number */
N
N   /* It is assumed that each cutting tool in the machine is assigned to a
N   slot (intended to correspond to a slot number in a tool carousel).
N   This command results in the tool currently in the spindle (if any)
N   being returned to its slot, and the tool from the slot designated by
N   slot_number (if any) being inserted in the spindle.
N
N   If there is no tool in the slot designated by the slot argument, there
N   will be no tool in the spindle after this command is executed and no
N   error condition will result in the controller. Similarly, if there is
N   no tool in the spindle when this command is given, no tool will be
N   returned to the carousel and no error condition will result in the
N   controller, whether or not a tool was previously selected in the
N   program.
N
N   It is expected that when the machine tool controller is initialized,
N   the designated slot for a tool already in the spindle will be
N   established. This may be done in any manner deemed fit, including
N   (for, example) recording that information in a persistent, crash-proof
N   location so it is always available from the last time the machine was
N   run, or having the operator enter it. It is expected that the machine
N   tool controller will remember that information as long as it is
N   not re-initialized; in particular, it will be remembered between
N   programs.
N
N   For the purposes of this command, the tool includes the tool holder.
N
N   For machines which can carry out a select_tool command separately from
N   a change_tool command, the select_tool command must have been given
N   before the change_tool command, and the value of slot must be the slot
N   number of the selected tool. */
N
Nextern void SELECT_TOOL(int i);                   /* i is slot number */
N
N   /* Miscellaneous Functions */
N
Nextern void CLAMP_AXIS(CANON_AXIS axis);
N
N   /* Clamp the given axis. If the machining center does not have a clamp
N   for that axis, this command should result in an error condition in the
N   controller.
N
N   An attempt to move an axis while it is clamped should result in an
N   error condition in the controller. */
N
Nextern void COMMENT(char *s);
N
N   /* This function has no physical effect. If commands are being printed or
N   logged, the comment command is printed or logged, including the string
N   which is the value of comment_text. This serves to allow formal
N   comments at specific locations in programs or command files. */
N
W "canon.h" 618 13 Deprecated declaration DISABLE_FEED_OVERRIDE - give arg types
Nextern void DISABLE_FEED_OVERRIDE();
W "canon.h" 619 13 Deprecated declaration ENABLE_FEED_OVERRIDE - give arg types
Nextern void ENABLE_FEED_OVERRIDE();
W "canon.h" 620 13 Deprecated declaration DISABLE_SPEED_OVERRIDE - give arg types
Nextern void DISABLE_SPEED_OVERRIDE();
W "canon.h" 621 13 Deprecated declaration ENABLE_SPEED_OVERRIDE - give arg types
Nextern void ENABLE_SPEED_OVERRIDE();
W "canon.h" 622 13 Deprecated declaration FLOOD_OFF - give arg types
Nextern void FLOOD_OFF();
N   /* Turn flood coolant off. */
W "canon.h" 624 13 Deprecated declaration FLOOD_ON - give arg types
Nextern void FLOOD_ON();
N   /* Turn flood coolant on. */
N
Nextern void MESSAGE(char *s);
N
W "canon.h" 629 13 Deprecated declaration MIST_OFF - give arg types
Nextern void MIST_OFF();
N   /* Turn mist coolant off. */
N
W "canon.h" 632 13 Deprecated declaration MIST_ON - give arg types
Nextern void MIST_ON();
N   /* Turn mist coolant on. */
N
W "canon.h" 635 13 Deprecated declaration PALLET_SHUTTLE - give arg types
Nextern void PALLET_SHUTTLE();
N
N   /* If the machining center has a pallet shuttle mechanism (a mechanism
N   which switches the position of two pallets), this command should cause
N   that switch to be made. If either or both of the pallets are missing,
N   this will not result in an error condition in the controller.
N
N   If the machining center does not have a pallet shuttle, this command
N   should result in an error condition in the controller. */
N
W "canon.h" 645 13 Deprecated declaration TURN_PROBE_OFF - give arg types
Nextern void TURN_PROBE_OFF();
W "canon.h" 646 13 Deprecated declaration TURN_PROBE_ON - give arg types
Nextern void TURN_PROBE_ON();
N
Nextern void UNCLAMP_AXIS(CANON_AXIS axis);
N
N   /* Unclamp the given axis. If the machining center does not have a clamp
N   for that axis, this command should result in an error condition in the
N   controller. */
N
N   /* NURB Functions */
W "canon.h" 655 13 Deprecated declaration NURB_KNOT_VECTOR - give arg types
Nextern void NURB_KNOT_VECTOR();                   /* double knot values, -1.0 signals done */
Nextern void NURB_CONTROL_POINT(int i, double x, double y, double z, double w );
Nextern void NURB_FEED(double sStart, double sEnd);
N
N   /* Program Functions */
W "canon.h" 660 13 Deprecated declaration OPTIONAL_PROGRAM_STOP - give arg types
Nextern void OPTIONAL_PROGRAM_STOP();
N
N   /* If the machining center has an optional stop switch, and it is on
N   when this command is read from a program, stop executing the program
N   at this point, but be prepared to resume with the next line of the
N   program. If the machining center does not have an optional stop
N   switch, or commands are being executed with a stop after each one
N   already (such as when the interpreter is being used with keyboard
N   input), this command has no effect. */
N
W "canon.h" 670 13 Deprecated declaration PROGRAM_END - give arg types
Nextern void PROGRAM_END();
N   /* If a program is being read, stop executing the program and be prepared
N   to accept a new program or to be shut down. */
N
W "canon.h" 674 13 Deprecated declaration PROGRAM_STOP - give arg types
Nextern void PROGRAM_STOP();
N   /* If this command is read from a program, stop executing the program at
N   this point, but be prepared to resume with the next line of the
N   program. If commands are being executed with a stop after each one
N   already (such as when the interpreter is being used with keyboard
N   input), this command has no effect. */
N
N   /*************************************************************************/
N
N   /* Canonical "Give me information" functions for the interpreter to call
N
N   In general, returned values are valid only if any canonical do it commands
N   that may have been called for have been executed to completion. If a function
N   returns a valid value regardless of execution, that is noted in the comments
N   below.
N
N   */
N
N   /* The interpreter is not using this function
N   // Returns the system angular unit factor, in units / degree
N   extern double GET_EXTERNAL_ANGLE_UNIT_FACTOR();
N   */
N
N   // Returns the system feed rate
W "canon.h" 698 15 Deprecated declaration GET_EXTERNAL_FEED_RATE - give arg types
Nextern double GET_EXTERNAL_FEED_RATE();
N
N   // Returns the system value for flood coolant, zero = off, non-zero = on
W "canon.h" 701 12 Deprecated declaration GET_EXTERNAL_FLOOD - give arg types
Nextern int GET_EXTERNAL_FLOOD();
N
N   /* The interpreter is not using this function
N   // Returns the system length unit factor, in units / mm
N   extern double GET_EXTERNAL_LENGTH_UNIT_FACTOR();
N   */
N
N   // Returns the system length unit type
W "canon.h" 709 13 Deprecated declaration GET_EXTERNAL_LENGTH_UNIT_TYPE - give arg types
NCANON_UNITS GET_EXTERNAL_LENGTH_UNIT_TYPE();
N
N   // Returns the system value for mist coolant, zero = off, non-zero = on
W "canon.h" 712 12 Deprecated declaration GET_EXTERNAL_MIST - give arg types
Nextern int GET_EXTERNAL_MIST();
N
N   // Returns the current motion control mode
W "canon.h" 715 26 Deprecated declaration GET_EXTERNAL_MOTION_CONTROL_MODE - give arg types
Nextern CANON_MOTION_MODE GET_EXTERNAL_MOTION_CONTROL_MODE();
N
N   /* The interpreter is not using these six GET_EXTERNAL_ORIGIN functions
N
N   #ifdef AA
N   // returns the current a-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_A();
N   #endif
N
N   #ifdef BB
N   // returns the current b-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_B();
N   #endif
N
N   #ifdef CC
N   // returns the current c-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_C();
N   #endif
N
N   // returns the current x-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_X();
N
N   // returns the current y-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_Y();
N
N   // returns the current z-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_Z();
N
N   */
N
N   // returns nothing but copies the name of the parameter file into
N   // the filename array, stopping at max_size if the name is longer
N   // An empty string may be placed in filename.
Nextern void GET_EXTERNAL_PARAMETER_FILE_NAME(char * filename, unsigned int max_size);
N
N   // returns the currently active plane
W "canon.h" 751 20 Deprecated declaration GET_EXTERNAL_PLANE - give arg types
Nextern CANON_PLANE GET_EXTERNAL_PLANE();
N
N#ifdef AA
S   // returns the current a-axis position
Sextern double GET_EXTERNAL_POSITION_A();
N#endif
N
N#ifdef BB
S   // returns the current b-axis position
Sextern double GET_EXTERNAL_POSITION_B();
N#endif
N
N#ifdef CC
S   // returns the current c-axis position
Sextern double GET_EXTERNAL_POSITION_C();
N#endif
N
N   // returns the current x-axis position
W "canon.h" 769 15 Deprecated declaration GET_EXTERNAL_POSITION_X - give arg types
Nextern double GET_EXTERNAL_POSITION_X();
N
N   // returns the current y-axis position
W "canon.h" 772 15 Deprecated declaration GET_EXTERNAL_POSITION_Y - give arg types
Nextern double GET_EXTERNAL_POSITION_Y();
N
N   // returns the current z-axis position
W "canon.h" 775 15 Deprecated declaration GET_EXTERNAL_POSITION_Z - give arg types
Nextern double GET_EXTERNAL_POSITION_Z();
N
N#ifdef AA
S   // Returns the machine A-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_A();
N#endif
N
N#ifdef BB
S   // Returns the machine B-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_B();
N#endif
N
N#ifdef CC
S   // Returns the machine C-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_C();
N#endif
N
N   // Returns the machine X-axis position at the last probe trip.
W "canon.h" 793 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_X - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_X();
N
N   // Returns the machine Y-axis position at the last probe trip.
W "canon.h" 796 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_Y - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_Y();
N
N   // Returns the machine Z-axis position at the last probe trip.
W "canon.h" 799 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_Z - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_Z();
N
N   // Returns the value for any analog non-contact probing.
W "canon.h" 802 15 Deprecated declaration GET_EXTERNAL_PROBE_VALUE - give arg types
Nextern double GET_EXTERNAL_PROBE_VALUE();
N
N   // Returns zero if queue is not empty, non-zero if the queue is empty
N   // This always returns a valid value
W "canon.h" 806 12 Deprecated declaration GET_EXTERNAL_QUEUE_EMPTY - give arg types
Nextern int GET_EXTERNAL_QUEUE_EMPTY();
N
N   // Returns the system value for spindle speed in rpm
W "canon.h" 809 15 Deprecated declaration GET_EXTERNAL_SPEED - give arg types
Nextern double GET_EXTERNAL_SPEED();
N
N   // Returns the system value for direction of spindle turning
W "canon.h" 812 24 Deprecated declaration GET_EXTERNAL_SPINDLE - give arg types
Nextern CANON_DIRECTION GET_EXTERNAL_SPINDLE();
N
N   // returns current tool length offset
W "canon.h" 815 15 Deprecated declaration GET_EXTERNAL_TOOL_LENGTH_OFFSET - give arg types
Nextern double GET_EXTERNAL_TOOL_LENGTH_OFFSET();
N
N   // Returns number of slots in carousel
W "canon.h" 818 12 Deprecated declaration GET_EXTERNAL_TOOL_MAX - give arg types
Nextern int GET_EXTERNAL_TOOL_MAX();
N
N   // Returns the system value for the carousel slot in which the tool
N   // currently in the spindle belongs. Return value zero means there is no
N   // tool in the spindle.
W "canon.h" 823 12 Deprecated declaration GET_EXTERNAL_TOOL_SLOT - give arg types
Nextern int GET_EXTERNAL_TOOL_SLOT();
N
N   // Returns the CANON_TOOL_TABLE structure associated with the tool
N   // in the given pocket
Nextern CANON_TOOL_TABLE GET_EXTERNAL_TOOL_TABLE(int pocket);
N
N   // Returns the system traverse rate
W "canon.h" 830 15 Deprecated declaration GET_EXTERNAL_TRAVERSE_RATE - give arg types
Nextern double GET_EXTERNAL_TRAVERSE_RATE();
N#endif                                            /* ifndef CANON_HH */
L 41 "rs274ngc.h" 2
N
N   /**********************/
N   /*   COMPILER MACROS  */
N   /**********************/
N
N#define AND              &&
N#define IS               ==
N#define ISNT             !=
N#define MAX(x, y)        ((x) > (y) ? (x) : (y))
N#define NOT              !
N#define OR               ||
N#define SET_TO           =
N
N#ifndef TRUE
N#define TRUE             1
N#endif
N
N#ifndef FALSE
N#define FALSE            0
N#endif
N
N#define RS274NGC_TEXT_SIZE 256
N
N   /* numerical constants */
N#define TOLERANCE_INCH 0.0002
N#define TOLERANCE_MM 0.002
N#define TOLERANCE_CONCAVE_CORNER 0.01
N   /* angle threshold for concavity for
N                        cutter compensation, in radians */
N#define TINY 1e-12                                /* for arc_data_r */
N#define UNKNOWN 1e-20
N#define TWO_PI  6.2831853071795864
N
N#ifndef PI
N#define PI      3.1415926535897932
N#endif
N
N#ifndef PI2
N#define PI2     1.5707963267948966
N#endif
N
N   // array sizes
N#define RS274NGC_ACTIVE_G_CODES 12
N#define RS274NGC_ACTIVE_M_CODES 7
N#define RS274NGC_ACTIVE_SETTINGS 3
N
N   // name of parameter file for saving/restoring interpreter variables
N#define RS274NGC_PARAMETER_FILE_NAME_DEFAULT "rs274ngc.var"
N#define RS274NGC_PARAMETER_FILE_BACKUP_SUFFIX ".bak"
N
N   // max number of m codes on one line
N#define MAX_EMS  4
N
N   // English - Metric conversion (long number keeps error buildup down)
N#define MM_PER_INCH 25.4
N#define INCH_PER_MM 0.039370078740157477
N
N   // on-off switch settings
N#define OFF 0
N#define ON 1
N
N   // feed_mode
N#define UNITS_PER_MINUTE 0
N#define INVERSE_TIME 1
N
N   // cutter radius compensation mode, OFF already defined to 0
N   // not using CANON_SIDE since interpreter handles cutter radius comp
N#define RIGHT 1
N#define LEFT 2
N
N   // number of parameters in parameter table
N#define RS274NGC_MAX_PARAMETERS 5400
N
N   // unary operations
N   // These are not enums because the "&" operator is used in
N   // reading the operation names and is illegal with an enum
N
N#define ABS 1
N#define ACOS 2
N#define ASIN 3
N#define ATAN 4
N#define COS 5
N#define EXP 6
N#define FIX 7
N#define FUP 8
N#define LN 9
N#define ROUND 10
N#define SIN 11
N#define SQRT 12
N#define TAN 13
N
N   // binary operations
N#define NO_OPERATION 0
N#define DIVIDED_BY 1
N#define MODULO 2
N#define POWER 3
N#define TIMES 4
N#define AND2 5
N#define EXCLUSIVE_OR 6
N#define MINUS 7
N#define NON_EXCLUSIVE_OR 8
N#define PLUS 9
N#define RIGHT_BRACKET 10
N
N   // G Codes are symbolic to be dialect-independent in source code
N#define G_0      0
N#define G_1     10
N#define G_2     20
N#define G_3     30
N#define G_4     40
N#define G_10   100
N#define G_17   170
N#define G_18   180
N#define G_19   190
N#define G_20   200
N#define G_21   210
N#define G_28   280
N#define G_30   300
N#define G_38_2 382
N#define G_40   400
N#define G_41   410
N#define G_42   420
N#define G_43   430
N#define G_49   490
N#define G_53   530
N#define G_54   540
N#define G_55   550
N#define G_56   560
N#define G_57   570
N#define G_58   580
N#define G_59   590
N#define G_59_1 591
N#define G_59_2 592
N#define G_59_3 593
N#define G_61   610
N#define G_61_1 611
N#define G_64   640
N#define G_80   800
N#define G_81   810
N#define G_82   820
N#define G_83   830
N#define G_84   840
N#define G_85   850
N#define G_86   860
N#define G_87   870
N#define G_88   880
N#define G_89   890
N#define G_90   900
N#define G_91   910
N#define G_92   920
N#define G_92_1 921
N#define G_92_2 922
N#define G_92_3 923
N#define G_93   930
N#define G_94   940
N#define G_98   980
N#define G_99   990
N
N   /**********************/
N   /*      TYPEDEFS      */
N   /**********************/
N
N   /* distance_mode */
Ntypedef enum {MODE_ABSOLUTE, MODE_INCREMENTAL}
NDISTANCE_MODE;
N
N   /* retract_mode for cycles */
Ntypedef enum {R_PLANE, OLD_Z}
NRETRACT_MODE;
N
Ntypedef int ON_OFF;
N
Ntypedef struct block_struct
N{
N#ifdef AA
S    ON_OFF   a_flag;
S    double   a_number;
N#endif
N#ifdef BB
S    ON_OFF   b_flag;
S    double   b_number;
N#endif
N#ifdef CC
S    ON_OFF   c_flag;
S    double   c_number;
N#endif
N    char     comment[256];
N    int      d_number;
N    double   f_number;
N    int      g_modes[14];
N    int      h_number;
N    ON_OFF   i_flag;
N    double   i_number;
N    ON_OFF   j_flag;
N    double   j_number;
N    ON_OFF   k_flag;
N    double   k_number;
N    int      l_number;
N    int      line_number;
N    int      motion_to_be;
N    int      m_count;
N    int      m_modes[10];
N    double   p_number;
N    double   q_number;
N    ON_OFF   r_flag;
N    double   r_number;
N    double   s_number;
N    int      t_number;
N    ON_OFF   x_flag;
N    double   x_number;
N    ON_OFF   y_flag;
N    double   y_number;
N    ON_OFF   z_flag;
N    double   z_number;
N} block;
N
Ntypedef block * block_pointer;
N
N   /*
N
N   The current_x, current_y, and current_z are the location of the tool
N   in the current coordinate system. current_x and current_y differ from
N   program_x and program_y when cutter radius compensation is on.
N   current_z is the position of the tool tip in program coordinates when
N   tool length compensation is using the actual tool length; it is the
N   position of the spindle when tool length is zero.
N
N   In a setup, the axis_offset values are set by g92 and the origin_offset
N   values are set by g54 - g59.3. The net origin offset uses both values
N   and is not represented here
N
N   */
N
Ntypedef struct setup_struct
N{
N#ifdef AA
S    double AA_axis_offset;                        // A-axis g92 offset
S    double AA_current;                            // current A-axis position
S    double AA_origin_offset;                      // A-axis origin offset
N#endif
N#ifdef BB
S    double BB_axis_offset;                        // B-axis g92offset
S    double BB_current;                            // current B-axis position
S    double BB_origin_offset;                      // B-axis origin offset
N#endif
N#ifdef CC
S    double CC_axis_offset;                        // C-axis g92offset
S    double CC_current;                            // current C-axis position
S    double CC_origin_offset;                      // C-axis origin offset
N#endif
N    int active_g_codes
N        [RS274NGC_ACTIVE_G_CODES];                // array of active G codes
X        [12];                
N    int active_m_codes
N        [RS274NGC_ACTIVE_M_CODES];                // array of active M codes
X        [7];                
N    double active_settings
N        [RS274NGC_ACTIVE_SETTINGS];               // array of feed, speed, etc.
X        [3];               
N    double axis_offset_x;                         // X-axis g92 offset
N    double axis_offset_y;                         // Y-axis g92 offset
N    double axis_offset_z;                         // Z-axis g92 offset
N    block block1;                                 // parsed next block
N    char blocktext[RS274NGC_TEXT_SIZE];           // linetext downcased, white space gone
X    char blocktext[256];           
N    CANON_MOTION_MODE control_mode;               // exact path or cutting mode
N    int current_slot;                             // carousel slot number of current tool
N    double current_x;                             // current X-axis position
N    double current_y;                             // current Y-axis position
N    double current_z;                             // current Z-axis position
N    double cutter_comp_radius;                    // current cutter compensation radius
N    int cutter_comp_side;                         // current cutter compensation side
N    double cycle_cc;                              // cc-value (normal) for canned cycles
N    double cycle_i;                               // i-value for canned cycles
N    double cycle_j;                               // j-value for canned cycles
N    double cycle_k;                               // k-value for canned cycles
N    int cycle_l;                                  // l-value for canned cycles
N    double cycle_p;                               // p-value (dwell) for canned cycles
N    double cycle_q;                               // q-value for canned cycles
N    double cycle_r;                               // r-value for canned cycles
N    DISTANCE_MODE distance_mode;                  // absolute or incremental
N    int feed_mode;                                // G_93 (inverse time) or G_94 units/min
N    ON_OFF feed_override;                         // whether feed override is enabled
N    double feed_rate;                             // feed rate in current units/min
N    char filename[RS274NGC_TEXT_SIZE];            // name of currently open NC code file
X    char filename[256];            
N    FILE * file_pointer;                          // file pointer for open NC code file
N    ON_OFF flood;                                 // whether flood coolant is on
N    int length_offset_index;                      // for use with tool length offsets
N    CANON_UNITS length_units;                     // millimeters or inches
N    int line_length;                              // length of line last read
N    char linetext[RS274NGC_TEXT_SIZE];            // text of most recent line read
X    char linetext[256];            
N    ON_OFF mist;                                  // whether mist coolant is on
N    int motion_mode;                              // active G-code for motion
N    int origin_index;                             // active origin (1=G54 to 9=G59.3)
N    double origin_offset_x;                       // origin offset x
N    double origin_offset_y;                       // origin offset y
N    double origin_offset_z;                       // origin offset z
N    double parameters
N        [RS274NGC_MAX_PARAMETERS];                // system parameters
X        [5400];                
N    int parameter_occurrence;                     // parameter buffer index
N    int parameter_numbers[50];                    // parameter number buffer
N    double parameter_values[50];                  // parameter value buffer
N    ON_OFF percent_flag;                          // ON means first line was percent sign
N    CANON_PLANE plane;                            // active plane, XY-, YZ-, or XZ-plane
N    ON_OFF probe_flag;                            // flag indicating probing done
N    double program_x;                             // program x, used when cutter comp on
N    double program_y;                             // program y, used when cutter comp on
N    RETRACT_MODE retract_mode;                    // for cycles, old_z or r_plane
N    int selected_tool_slot;                       // tool slot selected but not active
N    int sequence_number;                          // sequence number of line last read
N    double speed;                                 // current spindle speed in rpm
N    CANON_SPEED_FEED_MODE speed_feed_mode;        // independent or synched
N    ON_OFF speed_override;                        // whether speed override is enabled
N    CANON_DIRECTION spindle_turning;              // direction spindle is turning
N    char stack[50][80];                           // stack of calls for error reporting
N    int stack_index;                              // index into the stack
N    double tool_length_offset;                    // current tool length offset
N    int tool_max;                                 // highest number tool slot in carousel
N    CANON_TOOL_TABLE tool_table
N        [CANON_TOOL_MAX + 1];                     // index is slot number
X        [128 + 1];                     
N    int tool_table_index;                         // tool index used with cutter comp
N    double traverse_rate;                         // rate for traverse motions
N} setup;
N
Ntypedef setup * setup_pointer;
N
N   // pointer to function that reads
Ntypedef int (*read_function_pointer) (char *, int *, block_pointer, double *);
N
N   /*************************************************************************/
N   /*
N
N   Interface functions to call to tell the interpreter what to do.
N   Return values indicate status of execution.
N   These functions may change the state of the interpreter.
N
N   */
N
N   // close the currently open NC code file
W "rs274ngc.h" 376 12 Deprecated declaration rs274ngc_close - give arg types
Nextern int rs274ngc_close();
N
N   // execute a line of NC code
W "rs274ngc.h" 379 12 Deprecated declaration rs274ngc_execute - give arg types
Nextern int rs274ngc_execute();
N
N   // stop running
W "rs274ngc.h" 382 12 Deprecated declaration rs274ngc_exit - give arg types
Nextern int rs274ngc_exit();
N
N   // get ready to run
W "rs274ngc.h" 385 12 Deprecated declaration rs274ngc_init - give arg types
Nextern int rs274ngc_init();
N
N   // load a tool table
W "rs274ngc.h" 388 12 Deprecated declaration rs274ngc_load_tool_table - give arg types
Nextern int rs274ngc_load_tool_table();
N
N   // open a file of NC code
Nextern int rs274ngc_open(const char *filename);
N
N   // read the mdi or the next line of the open NC code file
Nextern int rs274ngc_read(const char * mdi);
N
N   // reset yourself
W "rs274ngc.h" 397 12 Deprecated declaration rs274ngc_reset - give arg types
Nextern int rs274ngc_reset();
N
N   // restore interpreter variables from a file
Nextern int rs274ngc_restore_parameters(const char * filename);
N
N   // save interpreter variables to file
Nextern int rs274ngc_save_parameters(const char * filename,
Nconst double parameters[]);
N
N   // synchronize your internal model with the external world
W "rs274ngc.h" 407 12 Deprecated declaration rs274ngc_synch - give arg types
Nextern int rs274ngc_synch();
N
N   /*************************************************************************/
N   /* 
N
N   Interface functions to call to get information from the interpreter.
N   If a function has a return value, the return value contains the information.
N   If a function returns nothing, information is copied into one of the
N   arguments to the function. These functions do not change the state of
N   the interpreter.
N
N   */
N
N   // copy active G codes into array [0]..[11]
Nextern void rs274ngc_active_g_codes(int * codes);
N
N   // copy active M codes into array [0]..[6]
Nextern void rs274ngc_active_m_codes(int * codes);
N
N   // copy active F, S settings into array [0]..[2]
Nextern void rs274ngc_active_settings(double * settings);
N
N   // copy the text of the error message whose number is error_code into the
N   // error_text array, but stop at max_size if the text is longer.
Nextern void rs274ngc_error_text(int error_code, char * error_text,unsigned
Nint max_size);
N
N   // copy the name of the currently open file into the file_name array,
N   // but stop at max_size if the name is longer
Nextern void rs274ngc_file_name(char * file_name,unsigned int max_size);
N
N   // return the length of the most recently read line
W "rs274ngc.h" 439 12 Deprecated declaration rs274ngc_line_length - give arg types
Nextern int rs274ngc_line_length();
N
N   // copy the text of the most recently read line into the line_text array,
N   // but stop at max_size if the text is longer
Nextern void rs274ngc_line_text(char * line_text, int max_size);
N
N   // return the current sequence number (how many lines read)
W "rs274ngc.h" 446 12 Deprecated declaration rs274ngc_sequence_number - give arg types
Nextern int rs274ngc_sequence_number();
N
N   // copy the function name from the stack_index'th position of the
N   // function call stack at the time of the most recent error into
N   // the function name string, but stop at max_size if the name is longer
Nextern void rs274ngc_stack_name(int stack_index, char * function_name,
Nint max_size);
N#endif
L 128 "rs274ngc_pre.c" 2
N#include "rs274ngc_return.h"
L 1 "rs274ngc_return.h" 1
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N#ifndef RS274NGC_RETURN_H
N#define RS274NGC_RETURN_H
N
N#define RS274NGC_OK 0
N#define RS274NGC_EXIT 1
N#define RS274NGC_EXECUTE_FINISH 2
N#define RS274NGC_ENDFILE 3
N#define NCE_A_FILE_IS_ALREADY_OPEN 4
N#define NCE_ALL_AXES_MISSING_WITH_G92 5
N#define NCE_ALL_AXES_MISSING_WITH_MOTION_CODE 6
N#define NCE_ARC_RADIUS_TOO_SMALL_TO_REACH_END_POINT 7
N#define NCE_ARGUMENT_TO_ACOS_OUT_OF_RANGE 8
N#define NCE_ARGUMENT_TO_ASIN_OUT_OF_RANGE 9
N#define NCE_ATTEMPT_TO_DIVIDE_BY_ZERO 10
N#define NCE_ATTEMPT_TO_RAISE_NEGATIVE_TO_NON_INTEGER_POWER 11
N#define NCE_BAD_CHARACTER_USED 12
N#define NCE_BAD_FORMAT_UNSIGNED_INTEGER 13
N#define NCE_BAD_NUMBER_FORMAT 14
N#define NCE_BUG_BAD_G_CODE_MODAL_GROUP_0 15
N#define NCE_BUG_CODE_NOT_G0_OR_G1 16
N#define NCE_BUG_CODE_NOT_G17_G18_OR_G19 17
N#define NCE_BUG_CODE_NOT_G20_OR_G21 18
N#define NCE_BUG_CODE_NOT_G28_OR_G30 19
N#define NCE_BUG_CODE_NOT_G2_OR_G3 20
N#define NCE_BUG_CODE_NOT_G40_G41_OR_G42 21
N#define NCE_BUG_CODE_NOT_G43_OR_G49 22
N#define NCE_BUG_CODE_NOT_G4_G10_G28_G30_G53_OR_G92_SERIES 23
N#define NCE_BUG_CODE_NOT_G61_G61_1_OR_G64 24
N#define NCE_BUG_CODE_NOT_G90_OR_G91 25
N#define NCE_BUG_CODE_NOT_G93_OR_G94 26
N#define NCE_BUG_CODE_NOT_G98_OR_G99 27
N#define NCE_BUG_CODE_NOT_IN_G92_SERIES 28
N#define NCE_BUG_CODE_NOT_IN_RANGE_G54_TO_G593 29
N#define NCE_BUG_CODE_NOT_M0_M1_M2_M30_M60 30
N#define NCE_BUG_DISTANCE_MODE_NOT_G90_OR_G91 31
N#define NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED 32
N#define NCE_BUG_IN_TOOL_RADIUS_COMP 33
N#define NCE_BUG_PLANE_NOT_XY_YZ_OR_XZ 34
N#define NCE_BUG_SIDE_NOT_RIGHT_OR_LEFT 35
N#define NCE_BUG_UNKNOWN_MOTION_CODE 36
N#define NCE_BUG_UNKNOWN_OPERATION 37
N#define NCE_CANNOT_CHANGE_AXIS_OFFSETS_WITH_CUTTER_RADIUS_COMP 38
N#define NCE_CANNOT_CHANGE_UNITS_WITH_CUTTER_RADIUS_COMP 39
N#define NCE_CANNOT_CREATE_BACKUP_FILE 40
N#define NCE_CANNOT_DO_G1_WITH_ZERO_FEED_RATE 41
N#define NCE_CANNOT_DO_ZERO_REPEATS_OF_CYCLE 42
N#define NCE_CANNOT_MAKE_ARC_WITH_ZERO_FEED_RATE 43
N#define NCE_CANNOT_MOVE_ROTARY_AXES_DURING_PROBING 44
N#define NCE_CANNOT_OPEN_BACKUP_FILE 45
N#define NCE_CANNOT_OPEN_VARIABLE_FILE 46
N#define NCE_CANNOT_PROBE_IN_INVERSE_TIME_FEED_MODE 47
N#define NCE_CANNOT_PROBE_WITH_CUTTER_RADIUS_COMP_ON 48
N#define NCE_CANNOT_PROBE_WITH_ZERO_FEED_RATE 49
N#define NCE_CANNOT_PUT_A_B_IN_CANNED_CYCLE 50
N#define NCE_CANNOT_PUT_A_C_IN_CANNED_CYCLE 51
N#define NCE_CANNOT_PUT_AN_A_IN_CANNED_CYCLE 52
N#define NCE_CANNOT_TURN_CUTTER_RADIUS_COMP_ON_OUT_OF_XY_PLANE 53
N#define NCE_CANNOT_TURN_CUTTER_RADIUS_COMP_ON_WHEN_ON 54
N#define NCE_CANNOT_USE_A_WORD 55
N#define NCE_CANNOT_USE_AXIS_VALUES_WITH_G80 56
N#define NCE_CANNOT_USE_AXIS_VALUES_WITHOUT_A_G_CODE_THAT_USES_THEM 57
N#define NCE_CANNOT_USE_B_WORD 58
N#define NCE_CANNOT_USE_C_WORD 59
N#define NCE_CANNOT_USE_G28_OR_G30_WITH_CUTTER_RADIUS_COMP 60
N#define NCE_CANNOT_USE_G53_INCREMENTAL 61
N#define NCE_CANNOT_USE_G53_WITH_CUTTER_RADIUS_COMP 62
N#define NCE_CANNOT_USE_TWO_G_CODES_THAT_BOTH_USE_AXIS_VALUES 63
N#define NCE_CANNOT_USE_XZ_PLANE_WITH_CUTTER_RADIUS_COMP 64
N#define NCE_CANNOT_USE_YZ_PLANE_WITH_CUTTER_RADIUS_COMP 65
N#define NCE_COMMAND_TOO_LONG 66
N#define NCE_CONCAVE_CORNER_WITH_CUTTER_RADIUS_COMP 67
N#define NCE_COORDINATE_SYSTEM_INDEX_PARAMETER_5220_OUT_OF_RANGE 68
N#define NCE_CURRENT_POINT_SAME_AS_END_POINT_OF_ARC 69
N#define NCE_CUTTER_GOUGING_WITH_CUTTER_RADIUS_COMP 70
N#define NCE_D_WORD_WITH_NO_G41_OR_G42 71
N#define NCE_DWELL_TIME_MISSING_WITH_G4 72
N#define NCE_DWELL_TIME_P_WORD_MISSING_WITH_G82 73
N#define NCE_DWELL_TIME_P_WORD_MISSING_WITH_G86 74
N#define NCE_DWELL_TIME_P_WORD_MISSING_WITH_G88 75
N#define NCE_DWELL_TIME_P_WORD_MISSING_WITH_G89 76
N#define NCE_EQUAL_SIGN_MISSING_IN_PARAMETER_SETTING 77
N#define NCE_F_WORD_MISSING_WITH_INVERSE_TIME_ARC_MOVE 78
N#define NCE_F_WORD_MISSING_WITH_INVERSE_TIME_G1_MOVE 79
N#define NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN 80
N#define NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN_OR_PROGRAM_END 81
N#define NCE_FILE_NAME_TOO_LONG 82
N#define NCE_FILE_NOT_OPEN 83
N#define NCE_G_CODE_OUT_OF_RANGE 84
N#define NCE_H_WORD_WITH_NO_G43 85
N#define NCE_I_WORD_GIVEN_FOR_ARC_IN_YZ_PLANE 86
N#define NCE_I_WORD_MISSING_WITH_G87 87
N#define NCE_I_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT 88
N#define NCE_J_WORD_GIVEN_FOR_ARC_IN_XZ_PLANE 89
N#define NCE_J_WORD_MISSING_WITH_G87 90
N#define NCE_J_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT 91
N#define NCE_K_WORD_GIVEN_FOR_ARC_IN_XY_PLANE 92
N#define NCE_K_WORD_MISSING_WITH_G87 93
N#define NCE_K_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT 94
N#define NCE_L_WORD_WITH_NO_CANNED_CYCLE_OR_G10 95
N#define NCE_LEFT_BRACKET_MISSING_AFTER_SLASH_WITH_ATAN 96
N#define NCE_LEFT_BRACKET_MISSING_AFTER_UNARY_OPERATION_NAME 97
N#define NCE_LINE_NUMBER_GREATER_THAN_99999 98
N#define NCE_LINE_WITH_G10_DOES_NOT_HAVE_L2 99
N#define NCE_M_CODE_GREATER_THAN_99 100
N#define NCE_MIXED_RADIUS_IJK_FORMAT_FOR_ARC 101
N#define NCE_MULTIPLE_A_WORDS_ON_ONE_LINE 102
N#define NCE_MULTIPLE_B_WORDS_ON_ONE_LINE 103
N#define NCE_MULTIPLE_C_WORDS_ON_ONE_LINE 104
N#define NCE_MULTIPLE_D_WORDS_ON_ONE_LINE 105
N#define NCE_MULTIPLE_F_WORDS_ON_ONE_LINE 106
N#define NCE_MULTIPLE_H_WORDS_ON_ONE_LINE 107
N#define NCE_MULTIPLE_I_WORDS_ON_ONE_LINE 108
N#define NCE_MULTIPLE_J_WORDS_ON_ONE_LINE 109
N#define NCE_MULTIPLE_K_WORDS_ON_ONE_LINE 110
N#define NCE_MULTIPLE_L_WORDS_ON_ONE_LINE 111
N#define NCE_MULTIPLE_P_WORDS_ON_ONE_LINE 112
N#define NCE_MULTIPLE_Q_WORDS_ON_ONE_LINE 113
N#define NCE_MULTIPLE_R_WORDS_ON_ONE_LINE 114
N#define NCE_MULTIPLE_S_WORDS_ON_ONE_LINE 115
N#define NCE_MULTIPLE_T_WORDS_ON_ONE_LINE 116
N#define NCE_MULTIPLE_X_WORDS_ON_ONE_LINE 117
N#define NCE_MULTIPLE_Y_WORDS_ON_ONE_LINE 118
N#define NCE_MULTIPLE_Z_WORDS_ON_ONE_LINE 119
N#define NCE_MUST_USE_G0_OR_G1_WITH_G53 120
N#define NCE_NEGATIVE_ARGUMENT_TO_SQRT 121
N#define NCE_NEGATIVE_D_WORD_TOOL_RADIUS_INDEX_USED 122
N#define NCE_NEGATIVE_F_WORD_USED 123
N#define NCE_NEGATIVE_G_CODE_USED 124
N#define NCE_NEGATIVE_H_WORD_TOOL_LENGTH_OFFSET_INDEX_USED 125
N#define NCE_NEGATIVE_L_WORD_USED 126
N#define NCE_NEGATIVE_M_CODE_USED 127
N#define NCE_NEGATIVE_OR_ZERO_Q_VALUE_USED 128
N#define NCE_NEGATIVE_P_WORD_USED 129
N#define NCE_NEGATIVE_SPINDLE_SPEED_USED 130
N#define NCE_NEGATIVE_TOOL_ID_USED 131
N#define NCE_NESTED_COMMENT_FOUND 132
N#define NCE_NO_CHARACTERS_FOUND_IN_READING_REAL_VALUE 133
N#define NCE_NO_DIGITS_FOUND_WHERE_REAL_NUMBER_SHOULD_BE 134
N#define NCE_NON_INTEGER_VALUE_FOR_INTEGER 135
N#define NCE_NULL_MISSING_AFTER_NEWLINE 136
N#define NCE_OFFSET_INDEX_MISSING 137
N#define NCE_P_VALUE_NOT_AN_INTEGER_WITH_G10_L2 138
N#define NCE_P_VALUE_OUT_OF_RANGE_WITH_G10_L2 139
N#define NCE_P_WORD_WITH_NO_G4_G10_G82_G86_G88_G89 140
N#define NCE_PARAMETER_FILE_OUT_OF_ORDER 141
N#define NCE_PARAMETER_NUMBER_OUT_OF_RANGE 142
N#define NCE_Q_WORD_MISSING_WITH_G83 143
N#define NCE_Q_WORD_WITH_NO_G83 144
N#define NCE_QUEUE_IS_NOT_EMPTY_AFTER_PROBING 145
N#define NCE_R_CLEARANCE_PLANE_UNSPECIFIED_IN_CYCLE 146
N#define NCE_R_I_J_K_WORDS_ALL_MISSING_FOR_ARC 147
N#define NCE_R_LESS_THAN_X_IN_CYCLE_IN_YZ_PLANE 148
N#define NCE_R_LESS_THAN_Y_IN_CYCLE_IN_XZ_PLANE 149
N#define NCE_R_LESS_THAN_Z_IN_CYCLE_IN_XY_PLANE 150
N#define NCE_R_WORD_WITH_NO_G_CODE_THAT_USES_IT 151
N#define NCE_RADIUS_TO_END_OF_ARC_DIFFERS_FROM_RADIUS_TO_START 152
N#define NCE_RADIUS_TOO_SMALL_TO_REACH_END_POINT 153
N#define NCE_REQUIRED_PARAMETER_MISSING 154
N#define NCE_SELECTED_TOOL_SLOT_NUMBER_TOO_LARGE 155
N#define NCE_SLASH_MISSING_AFTER_FIRST_ATAN_ARGUMENT 156
N#define NCE_SPINDLE_NOT_TURNING_CLOCKWISE_IN_G84 157
N#define NCE_SPINDLE_NOT_TURNING_IN_G86 158
N#define NCE_SPINDLE_NOT_TURNING_IN_G87 159
N#define NCE_SPINDLE_NOT_TURNING_IN_G88 160
N#define NCE_SSCANF_FAILED 161
N#define NCE_START_POINT_TOO_CLOSE_TO_PROBE_POINT 162
N#define NCE_TOO_MANY_M_CODES_ON_LINE 163
N#define NCE_TOOL_LENGTH_OFFSET_INDEX_TOO_BIG 164
N#define NCE_TOOL_MAX_TOO_LARGE 165
N#define NCE_TOOL_RADIUS_INDEX_TOO_BIG 166
N#define NCE_TOOL_RADIUS_NOT_LESS_THAN_ARC_RADIUS_WITH_COMP 167
N#define NCE_TWO_G_CODES_USED_FROM_SAME_MODAL_GROUP 168
N#define NCE_TWO_M_CODES_USED_FROM_SAME_MODAL_GROUP 169
N#define NCE_UNABLE_TO_OPEN_FILE 170
N#define NCE_UNCLOSED_COMMENT_FOUND 171
N#define NCE_UNCLOSED_EXPRESSION 172
N#define NCE_UNKNOWN_G_CODE_USED 173
N#define NCE_UNKNOWN_M_CODE_USED 174
N#define NCE_UNKNOWN_OPERATION 175
N#define NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_A 176
N#define NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_M 177
N#define NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_O 178
N#define NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_X 179
N#define NCE_UNKNOWN_WORD_STARTING_WITH_A 180
N#define NCE_UNKNOWN_WORD_STARTING_WITH_C 181
N#define NCE_UNKNOWN_WORD_STARTING_WITH_E 182
N#define NCE_UNKNOWN_WORD_STARTING_WITH_F 183
N#define NCE_UNKNOWN_WORD_STARTING_WITH_L 184
N#define NCE_UNKNOWN_WORD_STARTING_WITH_R 185
N#define NCE_UNKNOWN_WORD_STARTING_WITH_S 186
N#define NCE_UNKNOWN_WORD_STARTING_WITH_T 187
N#define NCE_UNKNOWN_WORD_WHERE_UNARY_OPERATION_COULD_BE 188
N#define NCE_X_AND_Y_WORDS_MISSING_FOR_ARC_IN_XY_PLANE 189
N#define NCE_X_AND_Z_WORDS_MISSING_FOR_ARC_IN_XZ_PLANE 190
N#define NCE_X_VALUE_UNSPECIFIED_IN_YZ_PLANE_CANNED_CYCLE 191
N#define NCE_X_Y_AND_Z_WORDS_ALL_MISSING_WITH_G38_2 192
N#define NCE_Y_AND_Z_WORDS_MISSING_FOR_ARC_IN_YZ_PLANE 193
N#define NCE_Y_VALUE_UNSPECIFIED_IN_XZ_PLANE_CANNED_CYCLE 194
N#define NCE_Z_VALUE_UNSPECIFIED_IN_XY_PLANE_CANNED_CYCLE 195
N#define NCE_ZERO_OR_NEGATIVE_ARGUMENT_TO_LN 196
N#define NCE_ZERO_RADIUS_ARC 197
N
N#define RS274NGC_MIN_ERROR 3
N#define RS274NGC_MAX_ERROR 197
N#endif                                            /* RS274NGC_RETURN_H */
L 129 "rs274ngc_pre.c" 2
N
Nchar * _rs274ngc_errors[] =
N{
N    /*   0 */ "No error",
N    /*   1 */ "No error",
N    /*   2 */ "No error",
N    /*   3 */ "No error",
N    /*   4 */ "A file is already open", // rs274ngc_open
N    /*   5 */ "All axes missing with g92", // enhance_block
N    /*   6 */ "All axes missing with motion code", // enhance_block
N    /*   7 */ "Arc radius too small to reach end point", // arc_data_r
N    /*   8 */ "Argument to acos out of range", // execute_unary
N    /*   9 */ "Argument to asin out of range", // execute_unary
N    /*  10 */ "Attempt to divide by zero", // execute_binary1
N    /*  11 */ "Attempt to raise negative to non integer power", // execute_binary1
N    /*  12 */ "Bad character used", // read_one_item
N    /*  13 */ "Bad format unsigned integer", // read_integer_unsigned
N    /*  14 */ "Bad number format", // read_real_number
N    /*  15 */ "Bug bad g code modal group 0", // check_g_codes
N    /*  16 */ "Bug code not g0 or g1", // convert_straight, convert_straight_comp1, convert_straight_comp2
N    /*  17 */ "Bug code not g17 g18 or g19", // convert_set_plane
N    /*  18 */ "Bug code not g20 or g21", // convert_length_units
N    /*  19 */ "Bug code not g28 or g30", // convert_home
N    /*  20 */ "Bug code not g2 or g3", // arc_data_comp_ijk, arc_data_ijk
N    /*  21 */ "Bug code not g40 g41 or g42", // convert_cutter_compensation
N    /*  22 */ "Bug code not g43 or g49", // convert_tool_length_offset
N    /*  23 */ "Bug code not g4 g10 g28 g30 g53 or g92 series", // convert_modal_0
N    /*  24 */ "Bug code not g61 g61 1 or g64", // convert_control_mode
N    /*  25 */ "Bug code not g90 or g91", // convert_distance_mode
N    /*  26 */ "Bug code not g93 or g94", // convert_feed_mode
N    /*  27 */ "Bug code not g98 or g99", // convert_retract_mode
N    /*  28 */ "Bug code not in g92 series", // convert_axis_offsets
N    /*  29 */ "Bug code not in range g54 to g593", // convert_coordinate_system
N    /*  30 */ "Bug code not m0 m1 m2 m30 m60", // convert_stop
N    /*  31 */ "Bug distance mode not g90 or g91", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /*  32 */ "Bug function should not have been called", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx, read_a, read_b, read_c, read_comment, read_d, read_f, read_g, read_h, read_i, read_j, read_k, read_l, read_line_number, read_m, read_p, read_parameter, read_parameter_setting, read_q, read_r, read_real_expression, read_s, read_t, read_x, read_y, read_z
N    /*  33 */ "Bug in tool radius comp", // arc_data_comp_r
N    /*  34 */ "Bug plane not xy yz or xz", // convert_arc, convert_cycle
N    /*  35 */ "Bug side not right or left", // convert_straight_comp1, convert_straight_comp2
N    /*  36 */ "Bug unknown motion code", // convert_motion
N    /*  37 */ "Bug unknown operation", // execute_binary1, execute_binary2, execute_unary
N    /*  38 */ "Cannot change axis offsets with cutter radius comp", // convert_axis_offsets
N    /*  39 */ "Cannot change units with cutter radius comp", // convert_length_units
N    /*  40 */ "Cannot create backup file", // rs274ngc_save_parameters
N    /*  41 */ "Cannot do g1 with zero feed rate", // convert_straight
N    /*  42 */ "Cannot do zero repeats of cycle", // convert_cycle
N    /*  43 */ "Cannot make arc with zero feed rate", // convert_arc
N    /*  44 */ "Cannot move rotary axes during probing", // convert_probe
N    /*  45 */ "Cannot open backup file", // rs274ngc_save_parameters
N    /*  46 */ "Cannot open variable file", // rs274ngc_save_parameters
N    /*  47 */ "Cannot probe in inverse time feed mode", // convert_probe
N    /*  48 */ "Cannot probe with cutter radius comp on", // convert_probe
N    /*  49 */ "Cannot probe with zero feed rate", // convert_probe
N    /*  50 */ "Cannot put a b in canned cycle", // check_other_codes
N    /*  51 */ "Cannot put a c in canned cycle", // check_other_codes
N    /*  52 */ "Cannot put an a in canned cycle", // check_other_codes
N    /*  53 */ "Cannot turn cutter radius comp on out of xy plane", // convert_cutter_compensation_on
N    /*  54 */ "Cannot turn cutter radius comp on when on", // convert_cutter_compensation_on
N    /*  55 */ "Cannot use a word", // read_a
N    /*  56 */ "Cannot use axis values with g80", // enhance_block
N    /*  57 */ "Cannot use axis values without a g code that uses them", // enhance_block
N    /*  58 */ "Cannot use b word", // read_b
N    /*  59 */ "Cannot use c word", // read_c
N    /*  60 */ "Cannot use g28 or g30 with cutter radius comp", // convert_home
N    /*  61 */ "Cannot use g53 incremental", // check_g_codes
N    /*  62 */ "Cannot use g53 with cutter radius comp", // convert_straight
N    /*  63 */ "Cannot use two g codes that both use axis values", // enhance_block
N    /*  64 */ "Cannot use xz plane with cutter radius comp", // convert_set_plane
N    /*  65 */ "Cannot use yz plane with cutter radius comp", // convert_set_plane
N    /*  66 */ "Command too long", // read_text, rs274ngc_open
N    /*  67 */ "Concave corner with cutter radius comp", // convert_arc_comp2, convert_straight_comp2
N    /*  68 */ "Coordinate system index parameter 5220 out of range", // rs274ngc_init
N    /*  69 */ "Current point same as end point of arc", // arc_data_r
N    /*  70 */ "Cutter gouging with cutter radius comp", // convert_arc_comp1, convert_straight_comp1
N    /*  71 */ "D word with no g41 or g42", // check_other_codes
N    /*  72 */ "Dwell time missing with g4", // check_g_codes
N    /*  73 */ "Dwell time p word missing with g82", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /*  74 */ "Dwell time p word missing with g86", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /*  75 */ "Dwell time p word missing with g88", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /*  76 */ "Dwell time p word missing with g89", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /*  77 */ "Equal sign missing in parameter setting", // read_parameter_setting
N    /*  78 */ "F word missing with inverse time arc move", // convert_arc
N    /*  79 */ "F word missing with inverse time g1 move", // convert_straight
N    /*  80 */ "File ended with no percent sign", // read_text, rs274ngc_open
N    /*  81 */ "File ended with no percent sign or program end", // read_text
N    /*  82 */ "File name too long", // rs274ngc_open
N    /*  83 */ "File not open", // rs274ngc_read
N    /*  84 */ "G code out of range", // read_g
N    /*  85 */ "H word with no g43", // check_other_codes
N    /*  86 */ "I word given for arc in yz plane", // convert_arc
N    /*  87 */ "I word missing with g87", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /*  88 */ "I word with no g2 or g3 or g87 to use it", // check_other_codes
N    /*  89 */ "J word given for arc in xz plane", // convert_arc
N    /*  90 */ "J word missing with g87", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /*  91 */ "J word with no g2 or g3 or g87 to use it", // check_other_codes
N    /*  92 */ "K word given for arc in xy plane", // convert_arc
N    /*  93 */ "K word missing with g87", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /*  94 */ "K word with no g2 or g3 or g87 to use it", // check_other_codes
N    /*  95 */ "L word with no canned cycle or g10", // check_other_codes
N    /*  96 */ "Left bracket missing after slash with atan", // read_atan
N    /*  97 */ "Left bracket missing after unary operation name", // read_unary
N    /*  98 */ "Line number greater than 99999", // read_line_number
N    /*  99 */ "Line with g10 does not have l2", // check_g_codes
N    /* 100 */ "M code greater than 99", // read_m
N    /* 101 */ "Mixed radius ijk format for arc", // convert_arc
N    /* 102 */ "Multiple a words on one line", // read_a
N    /* 103 */ "Multiple b words on one line", // read_b
N    /* 104 */ "Multiple c words on one line", // read_c
N    /* 105 */ "Multiple d words on one line", // read_d
N    /* 106 */ "Multiple f words on one line", // read_f
N    /* 107 */ "Multiple h words on one line", // read_h
N    /* 108 */ "Multiple i words on one line", // read_i
N    /* 109 */ "Multiple j words on one line", // read_j
N    /* 110 */ "Multiple k words on one line", // read_k
N    /* 111 */ "Multiple l words on one line", // read_l
N    /* 112 */ "Multiple p words on one line", // read_p
N    /* 113 */ "Multiple q words on one line", // read_q
N    /* 114 */ "Multiple r words on one line", // read_r
N    /* 115 */ "Multiple s words on one line", // read_s
N    /* 116 */ "Multiple t words on one line", // read_t
N    /* 117 */ "Multiple x words on one line", // read_x
N    /* 118 */ "Multiple y words on one line", // read_y
N    /* 119 */ "Multiple z words on one line", // read_z
N    /* 120 */ "Must use g0 or g1 with g53", // check_g_codes
N    /* 121 */ "Negative argument to sqrt", // execute_unary
N    /* 122 */ "Negative d word tool radius index used", // read_d
N    /* 123 */ "Negative f word used", // read_f
N    /* 124 */ "Negative g code used", // read_g
N    /* 125 */ "Negative h word tool length offset index used", // read_h
N    /* 126 */ "Negative l word used", // read_l
N    /* 127 */ "Negative m code used", // read_m
N    /* 128 */ "Negative or zero q value used", // read_q
N    /* 129 */ "Negative p word used", // read_p
N    /* 130 */ "Negative spindle speed used", // read_s
N    /* 131 */ "Negative tool id used", // read_t
N    /* 132 */ "Nested comment found", // close_and_downcase
N    /* 133 */ "No characters found in reading real value", // read_real_value
N    /* 134 */ "No digits found where real number should be", // read_real_number
N    /* 135 */ "Non integer value for integer", // read_integer_value
N    /* 136 */ "Null missing after newline", // close_and_downcase
N    /* 137 */ "Offset index missing", // convert_tool_length_offset
N    /* 138 */ "P value not an integer with g10 l2", // check_g_codes
N    /* 139 */ "P value out of range with g10 l2", // check_g_codes
N    /* 140 */ "P word with no g4 g10 g82 g86 g88 g89", // check_other_codes
N    /* 141 */ "Parameter file out of order", // rs274ngc_restore_parameters, rs274ngc_save_parameters
N    /* 142 */ "Parameter number out of range", // read_parameter, read_parameter_setting, rs274ngc_restore_parameters, rs274ngc_save_parameters
N    /* 143 */ "Q word missing with g83", // convert_cycle_xy, convert_cycle_yz, convert_cycle_zx
N    /* 144 */ "Q word with no g83", // check_other_codes
N    /* 145 */ "Queue is not empty after probing", // rs274ngc_read
N    /* 146 */ "R clearance plane unspecified in cycle", // convert_cycle
N    /* 147 */ "R i j k words all missing for arc", // convert_arc
N    /* 148 */ "R less than x in cycle in yz plane", // convert_cycle_yz
N    /* 149 */ "R less than y in cycle in xz plane", // convert_cycle_zx
N    /* 150 */ "R less than z in cycle in xy plane", // convert_cycle_xy
N    /* 151 */ "R word with no g code that uses it", // check_other_codes
N    /* 152 */ "Radius to end of arc differs from radius to start", // arc_data_comp_ijk, arc_data_ijk
N    /* 153 */ "Radius too small to reach end point", // arc_data_comp_r
N    /* 154 */ "Required parameter missing", // rs274ngc_restore_parameters
N    /* 155 */ "Selected tool slot number too large", // convert_tool_select
N    /* 156 */ "Slash missing after first atan argument", // read_atan
N    /* 157 */ "Spindle not turning clockwise in g84", // convert_cycle_g84
N    /* 158 */ "Spindle not turning in g86", // convert_cycle_g86
N    /* 159 */ "Spindle not turning in g87", // convert_cycle_g87
N    /* 160 */ "Spindle not turning in g88", // convert_cycle_g88
N    /* 161 */ "Sscanf failed", // read_integer_unsigned, read_real_number
N    /* 162 */ "Start point too close to probe point", // convert_probe
N    /* 163 */ "Too many m codes on line", // check_m_codes
N    /* 164 */ "Tool length offset index too big", // read_h
N    /* 165 */ "Tool max too large", // rs274ngc_load_tool_table
N    /* 166 */ "Tool radius index too big", // read_d
N    /* 167 */ "Tool radius not less than arc radius with comp", // arc_data_comp_r, convert_arc_comp2
N    /* 168 */ "Two g codes used from same modal group", // read_g
N    /* 169 */ "Two m codes used from same modal group", // read_m
N    /* 170 */ "Unable to open file", // convert_stop, rs274ngc_open, rs274ngc_restore_parameters
N    /* 171 */ "Unclosed comment found", // close_and_downcase
N    /* 172 */ "Unclosed expression", // read_operation
N    /* 173 */ "Unknown g code used", // read_g
N    /* 174 */ "Unknown m code used", // read_m
N    /* 175 */ "Unknown operation", // read_operation
N    /* 176 */ "Unknown operation name starting with a", // read_operation
N    /* 177 */ "Unknown operation name starting with m", // read_operation
N    /* 178 */ "Unknown operation name starting with o", // read_operation
N    /* 179 */ "Unknown operation name starting with x", // read_operation
N    /* 180 */ "Unknown word starting with a", // read_operation_unary
N    /* 181 */ "Unknown word starting with c", // read_operation_unary
N    /* 182 */ "Unknown word starting with e", // read_operation_unary
N    /* 183 */ "Unknown word starting with f", // read_operation_unary
N    /* 184 */ "Unknown word starting with l", // read_operation_unary
N    /* 185 */ "Unknown word starting with r", // read_operation_unary
N    /* 186 */ "Unknown word starting with s", // read_operation_unary
N    /* 187 */ "Unknown word starting with t", // read_operation_unary
N    /* 188 */ "Unknown word where unary operation could be", // read_operation_unary
N    /* 189 */ "X and y words missing for arc in xy plane", // convert_arc
N    /* 190 */ "X and z words missing for arc in xz plane", // convert_arc
N    /* 191 */ "X value unspecified in yz plane canned cycle", // convert_cycle_yz
N    /* 192 */ "X y and z words all missing with g38 2", // convert_probe
N    /* 193 */ "Y and z words missing for arc in yz plane", // convert_arc
N    /* 194 */ "Y value unspecified in xz plane canned cycle", // convert_cycle_zx
N    /* 195 */ "Z value unspecified in xy plane canned cycle", // convert_cycle_xy
N    /* 196 */ "Zero or negative argument to ln", // execute_unary
N    /* 197 */ "Zero radius arc", // arc_data_ijk
N    "The End"
N};
N
N#define DEBUG_EMC
N
N   /*
N
N   The _setup model includes a stack array for the names of function
N   calls. This stack is written into if an error occurs. Just before each
N   function returns an error code, it writes its name in the next
N   available string, initializes the following string, and increments
N   the array index. The following four macros do the work.
N
N   The size of the stack array is 50. An error in the middle of a very
N   complex expression would cause the ERP and CHP macros to write past the
N   bounds of the array if a check were not provided. No real program
N   would contain such a thing, but the check is included to make the
N   macros totally crash-proof. If the function call stack is deeper than
N   49, the top of the stack will be missing.
N
N   */
N
N#define ERM(error_code) if (1) { \
N    _setup.stack_index SET_TO 0; \
N    strcpy(_setup.stack[_setup.stack_index++], name); \
N    _setup.stack[_setup.stack_index][0] SET_TO 0; \
N    return error_code; \
N} else
X#define ERM(error_code) if (1) {     _setup.stack_index SET_TO 0;     strcpy(_setup.stack[_setup.stack_index++], name);     _setup.stack[_setup.stack_index][0] SET_TO 0;     return error_code; } else
N
N#define ERP(error_code) if (_setup.stack_index < 49) { \
N    strcpy(_setup.stack[_setup.stack_index++], name); \
N    _setup.stack[_setup.stack_index][0] SET_TO 0; \
N    return error_code; \
N} else return error_code
X#define ERP(error_code) if (_setup.stack_index < 49) {     strcpy(_setup.stack[_setup.stack_index++], name);     _setup.stack[_setup.stack_index][0] SET_TO 0;     return error_code; } else return error_code
N
N#define CHK(bad, error_code) if (bad) { \
N    _setup.stack_index SET_TO 0; \
N    strcpy(_setup.stack[_setup.stack_index++], name); \
N    _setup.stack[_setup.stack_index][0] SET_TO 0; \
N    return error_code; \
N} else
X#define CHK(bad, error_code) if (bad) {     _setup.stack_index SET_TO 0;     strcpy(_setup.stack[_setup.stack_index++], name);     _setup.stack[_setup.stack_index][0] SET_TO 0;     return error_code; } else
N
N#define CHP(try_this) \
Nif ((status SET_TO (try_this)) ISNT RS274NGC_OK) \
N{ \
N    if (_setup.stack_index < 49) \
N    { \
N        strcpy(_setup.stack[_setup.stack_index++], name); \
N        _setup.stack[_setup.stack_index][0] SET_TO 0; \
N        return status; \
N    } \
N    else {return status;} \
N} else
X#define CHP(try_this) if ((status SET_TO (try_this)) ISNT RS274NGC_OK) {     if (_setup.stack_index < 49)     {         strcpy(_setup.stack[_setup.stack_index++], name);         _setup.stack[_setup.stack_index][0] SET_TO 0;         return status;     }     else {return status;} } else
N
N   /*
N
N   Function prototypes for all static functions
N
N   */
N
N            static int arc_data_comp_ijk(int move, int side, double tool_radius,
N            double current_x, double current_y, double end_x, double end_y,
N            double i_number, double j_number, double * center_x, double * center_y,
N            int * turn, double tolerance);
Nstatic int arc_data_comp_r(int move, int side, double tool_radius,
Ndouble current_x, double current_y, double end_x, double end_y,
Ndouble big_radius, double * center_x, double * center_y, int * turn);
Nstatic int arc_data_ijk(int move, double current_x, double current_y,
Ndouble end_x, double end_y, double i_number, double j_number,
Ndouble * center_x, double * center_y, int * turn, double tolerance);
Nstatic int arc_data_r(int move, double current_x, double current_y,
Ndouble end_x, double end_y, double radius, double * center_x,
Ndouble * center_y, int * turn);
Nstatic int check_g_codes(block_pointer block, setup_pointer settings);
Nstatic int check_items(block_pointer block, setup_pointer settings);
Nstatic int check_m_codes(block_pointer block);
Nstatic int check_other_codes(block_pointer block);
Nstatic int close_and_downcase(char * line);
Nstatic int convert_arc(int move, block_pointer block, setup_pointer settings);
Nstatic int convert_arc2(int move, block_pointer block,
Nsetup_pointer settings, double * current1, double * current2,
Ndouble * current3, double end1, double end2,
Ndouble end3
N#ifdef AA
S, double AA_end
N#endif
N
N#ifdef BB
S, double BB_end
N#endif
N
N#ifdef CC
S, double CC_end
N#endif
N, double offset1,
Ndouble offset2);
Nstatic int convert_arc_comp1(int move, block_pointer block,
Nsetup_pointer settings, double end_x, double end_y,
Ndouble end_z
N#ifdef AA
S, double AA_end
N#endif
N
N#ifdef BB
S, double BB_end
N#endif
N
N#ifdef CC
S, double CC_end
N#endif
N);
Nstatic int convert_arc_comp2(int move, block_pointer block,
Nsetup_pointer settings, double end_x, double end_y,
Ndouble end_z
N#ifdef AA
S, double AA_end
N#endif
N
N#ifdef BB
S, double BB_end
N#endif
N
N#ifdef CC
S, double CC_end
N#endif
N);
Nstatic int convert_axis_offsets(int g_code, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_comment(char * comment);
Nstatic int convert_control_mode(int g_code, setup_pointer settings);
Nstatic int convert_coordinate_system(int g_code, setup_pointer settings);
Nstatic int convert_cutter_compensation(int g_code, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_cutter_compensation_off(setup_pointer settings);
Nstatic int convert_cutter_compensation_on(int side, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_cycle(int motion, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_cycle_g81(CANON_PLANE plane, double x, double y,
Ndouble clear_z, double bottom_z);
Nstatic int convert_cycle_g82(CANON_PLANE plane, double x, double y,
Ndouble clear_z, double bottom_z, double dwell);
Nstatic int convert_cycle_g83(CANON_PLANE plane, double x, double y,
Ndouble r, double clear_z, double bottom_z, double delta);
Nstatic int convert_cycle_g84(CANON_PLANE plane, double x, double y,
Ndouble clear_z, double bottom_z, CANON_DIRECTION direction,
NCANON_SPEED_FEED_MODE mode);
Nstatic int convert_cycle_g85(CANON_PLANE plane, double x, double y,
Ndouble clear_z, double bottom_z);
Nstatic int convert_cycle_g86(CANON_PLANE plane, double x, double y,
Ndouble clear_z, double bottom_z, double dwell, CANON_DIRECTION direction);
Nstatic int convert_cycle_g87(CANON_PLANE plane, double x, double offset_x,
Ndouble y, double offset_y, double r, double clear_z, double middle_z,
Ndouble bottom_z, CANON_DIRECTION direction);
Nstatic int convert_cycle_g88(CANON_PLANE plane, double x, double y,
Ndouble bottom_z, double dwell, CANON_DIRECTION direction);
Nstatic int convert_cycle_g89(CANON_PLANE plane, double x, double y,
Ndouble clear_z, double bottom_z, double dwell);
Nstatic int convert_cycle_xy(int motion, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_cycle_yz(int motion, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_cycle_zx(int motion, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_distance_mode(int g_code, setup_pointer settings);
Nstatic int convert_dwell(double time);
Nstatic int convert_feed_mode(int g_code, setup_pointer settings);
Nstatic int convert_feed_rate(block_pointer block, setup_pointer settings);
Nstatic int convert_g(block_pointer block, setup_pointer settings);
Nstatic int convert_home(int move, block_pointer block, setup_pointer settings);
Nstatic int convert_length_units(int g_code, setup_pointer settings);
Nstatic int convert_m(block_pointer block, setup_pointer settings);
Nstatic int convert_modal_0(int code, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_motion(int motion, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_probe(block_pointer block, setup_pointer settings);
Nstatic int convert_retract_mode(int g_code, setup_pointer settings);
Nstatic int convert_setup(block_pointer block, setup_pointer settings);
Nstatic int convert_set_plane(int g_code, setup_pointer settings);
Nstatic int convert_speed(block_pointer block, setup_pointer settings);
Nstatic int convert_stop(block_pointer block, setup_pointer settings);
Nstatic int convert_straight(int move, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_straight_comp1(int move, block_pointer block,
Nsetup_pointer settings, double px, double py,
Ndouble end_z
N#ifdef AA
S, double AA_end
N#endif
N
N#ifdef BB
S, double BB_end
N#endif
N
N#ifdef CC
S, double CC_end
N#endif
N);
Nstatic int convert_straight_comp2(int move, block_pointer block,
Nsetup_pointer settings, double px, double py,
Ndouble end_z
N#ifdef AA
S, double AA_end
N#endif
N
N#ifdef BB
S, double BB_end
N#endif
N
N#ifdef CC
S, double CC_end
N#endif
N);
Nstatic int convert_tool_change(setup_pointer settings);
Nstatic int convert_tool_length_offset(int g_code, block_pointer block,
Nsetup_pointer settings);
Nstatic int convert_tool_select(block_pointer block, setup_pointer settings);
Nstatic int cycle_feed(CANON_PLANE plane, double end1,
Ndouble end2, double end3);
Nstatic int cycle_traverse(CANON_PLANE plane, double end1, double end2,
Ndouble end3);
Nstatic int enhance_block(block_pointer block, setup_pointer settings);
Nstatic int execute_binary(double * left, int operation, double * right);
Nstatic int execute_binary1(double * left, int operation, double * right);
Nstatic int execute_binary2(double * left, int operation, double * right);
Nstatic int execute_block(block_pointer block, setup_pointer settings);
Nstatic int execute_unary(double * double_ptr, int operation);
Nstatic double find_arc_length(double x1, double y1, double z1,
Ndouble center_x, double center_y, int turn, double x2, double y2, double z2);
Nstatic int find_ends(block_pointer block, setup_pointer settings, double * px,
Ndouble * py, double * pz
N#ifdef AA
S, double * AA_p
N#endif
N
N#ifdef BB
S, double * BB_p
N#endif
N
N#ifdef CC
S, double * CC_p
N#endif
N);
Nstatic int find_relative(double x1, double y1,
Ndouble z1
N#ifdef AA
S, double AA_1
N#endif
N
N#ifdef BB
S, double BB_1
N#endif
N
N#ifdef CC
S, double CC_1
N#endif
N, double * x2, double * y2,
Ndouble * z2
N#ifdef AA
S, double * AA_2
N#endif
N
N#ifdef BB
S, double * BB_2
N#endif
N
N#ifdef CC
S, double * CC_2
N#endif
N,
Nsetup_pointer settings);
Nstatic double find_straight_length(double x2, double y2,
Ndouble z2
N#ifdef AA
S, double AA_2
N#endif
N
N#ifdef BB
S, double BB_2
N#endif
N
N#ifdef CC
S, double CC_2
N#endif
N, double x1, double y1,
Ndouble z1
N#ifdef AA
S, double AA_1
N#endif
N
N#ifdef BB
S, double BB_1
N#endif
N
N#ifdef CC
S, double CC_1
N#endif
N);
Nstatic double find_turn(double x1, double y1, double center_x, double center_y,
Nint turn, double x2, double y2);
Nstatic int init_block(block_pointer block);
Nstatic int inverse_time_rate_arc(double x1, double y1, double z1,
Ndouble cx, double cy, int turn, double x2, double y2, double z2,
Nblock_pointer block, setup_pointer settings);
Nstatic int inverse_time_rate_arc2(double start_x, double start_y, int turn1,
Ndouble mid_x, double mid_y, double cx, double cy, int turn2, double end_x,
Ndouble end_y, double end_z, block_pointer block, setup_pointer settings);
Nstatic int inverse_time_rate_as(double start_x, double start_y, int turn,
Ndouble mid_x, double mid_y, double end_x, double end_y,
Ndouble end_z
N#ifdef AA
S, double AA_end
N#endif
N
N#ifdef BB
S, double BB_end
N#endif
N
N#ifdef CC
S, double CC_end
N#endif
N,
Nblock_pointer block, setup_pointer settings);
Nstatic int inverse_time_rate_straight(double end_x, double end_y,
Ndouble end_z
N#ifdef AA
S, double AA_end
N#endif
N
N#ifdef BB
S, double BB_end
N#endif
N
N#ifdef CC
S, double CC_end
N#endif
N,
Nblock_pointer block, setup_pointer settings);
Nstatic int parse_line(char * line, block_pointer block,setup_pointer settings);
Nstatic int precedence(int an_operator);
Nstatic int read_a(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_atan(char * line, int * counter, double * double_ptr,
Ndouble * parameters);
Nstatic int read_b(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_c(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_comment(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_d(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_f(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_g(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_h(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_i(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_integer_unsigned(char * line, int * counter,
Nint * integer_ptr);
Nstatic int read_integer_value(char * line, int * counter, int * integer_ptr,
Ndouble * parameters);
Nstatic int read_items(block_pointer block, char * line, double * parameters);
Nstatic int read_j(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_k(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_l(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_line_number(char * line, int * counter, block_pointer block);
Nstatic int read_m(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_one_item(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_operation(char * line, int * counter, int * operation);
Nstatic int read_operation_unary(char * line, int * counter, int * operation);
Nstatic int read_p(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_parameter(char * line, int * counter, double * double_ptr,
Ndouble * parameters);
Nstatic int read_parameter_setting(char * line, int * counter,
Nblock_pointer block, double * parameters);
Nstatic int read_q(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_r(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_real_expression(char * line, int * counter,
Ndouble * hold2, double * parameters);
Nstatic int read_real_number(char * line, int * counter, double * double_ptr);
Nstatic int read_real_value(char * line, int * counter, double * double_ptr,
Ndouble * parameters);
Nstatic int read_s(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_t(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_text(const char * command, FILE * inport, char * raw_line,
Nchar * line, int * length);
Nstatic int read_unary(char * line, int * counter, double * double_ptr,
Ndouble * parameters);
Nstatic int read_x(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_y(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int read_z(char * line, int * counter, block_pointer block,
Ndouble * parameters);
Nstatic int set_probe_data(setup_pointer settings);
Nstatic int write_g_codes(block_pointer block, setup_pointer settings);
Nstatic int write_m_codes(block_pointer block, setup_pointer settings);
Nstatic int write_settings(setup_pointer settings);
N
N   /* Interpreter global arrays for g_codes and m_codes. The nth entry
N   in each array is the modal group number corresponding to the nth
N   code. Entries which are -1 represent illegal codes. Remember g_codes
N   in this interpreter are multiplied by 10.
N
N   The modal g groups and group numbers defined in [NCMS, pages 71 - 73]
N   (see also [Fanuc, pages 43 - 45]) are used here, except the canned
N   cycles (g80 - g89), which comprise modal g group 9 in [Fanuc], are
N   treated here as being in the same modal group (group 1) with the
N   straight moves and arcs (g0, g1, g2,g3).  [Fanuc, page 45] says only
N   one g_code from any one group may appear on a line, and we are
N   following that rule. The straight_probe move, g38.2, is in group 1; it
N   is not defined in [NCMS].
N
N   Some g_codes are non-modal (g4, g10, g28, g30, g53, g92, g92.1, g92.2,
N   and g92.3 here - many more in [NCMS]). [Fanuc] and [NCMS] put all
N   these in the same group 0, so we do also. Logically, there are two
N   subgroups, those which require coordinate values (g10, g28, g30, and
N   g92) and those which do not (g4, g53, g92.1, g92.2, and g92.3).
N   The subgroups are identified by itemization when necessary.
N
N   Those in group 0 which require coordinate values may not be on the
N   same line as those in group 1 (except g80) because they would be
N   competing for the coordinate values. Others in group 0 may be used on
N   the same line as those in group 1.
N
N   A total of 52 G-codes are implemented.
N
N   The groups are:
N   group  0 = {g4,g10,g28,g30,g53,g92,g92.1,g92.2,g92.3} - NON-MODAL
N   dwell, setup, return to ref1, return to ref2,
N   motion in machine coordinates, set and unset axis offsets
N   group  1 = {g0,g1,g2,g3,g38.2,g80,g81,g82,g83,g84,g85,g86,g87,g88,g89} - motion
N   group  2 = {g17,g18,g19}   - plane selection
N   group  3 = {g90,g91}       - distance mode
N   group  5 = {g93,g94}       - feed rate mode
N   group  6 = {g20,g21}       - units
N   group  7 = {g40,g41,g42}   - cutter diameter compensation
N   group  8 = {g43,g49}       - tool length offset
N   group 10 = {g98,g99}       - return mode in canned cycles
N   group 12 = {g54,g55,g56,g57,g58,g59,g59.1,g59.2,g59.3} - coordinate system
N   group 13 = {g61,g61.1,g64} - control mode
N
N   */
N
Nstatic const int _gees[] SET_TO
Xstatic const int _gees[] =
N{
N    /*   0 */   1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /*  20 */   1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /*  40 */   0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /*  60 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /*  80 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 100 */   0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 120 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 140 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 160 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 2,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 180 */   2,-1,-1,-1,-1,-1,-1,-1,-1,-1, 2,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 200 */   6,-1,-1,-1,-1,-1,-1,-1,-1,-1, 6,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 220 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 240 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 260 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 280 */   0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 300 */   0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 320 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 340 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 360 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 380 */  -1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 400 */   7,-1,-1,-1,-1,-1,-1,-1,-1,-1, 7,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 420 */   7,-1,-1,-1,-1,-1,-1,-1,-1,-1, 8,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 440 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 460 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 480 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 8,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 500 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 520 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 540 */  12,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 560 */  12,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 580 */  12,-1,-1,-1,-1,-1,-1,-1,-1,-1,12,12,12,12,-1,-1,-1,-1,-1,-1,
N        /* 600 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,13,13,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 620 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 640 */  13,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 660 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 680 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 700 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 720 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 740 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 760 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 780 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 800 */   1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 820 */   1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 840 */   1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 860 */   1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 880 */   1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 900 */   3,-1,-1,-1,-1,-1,-1,-1,-1,-1, 3,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 920 */   0, 0, 0, 0,-1,-1,-1,-1,-1,-1, 5,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 940 */   5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 960 */  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
N        /* 980 */  10,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,-1,-1,-1,-1,-1,-1,-1,-1,-1};
N
N   /*
N
N   Modal groups and modal group numbers for M codes are not described in
N   [Fanuc]. We have used the groups from [NCMS] and added M60, as an
N   extension of the language for pallet shuttle and stop. This version has
N   no codes related to axis clamping.
N
N   The groups are:
N   group 4 = {m0,m1,m2,m30,m60} - stopping
N   group 6 = {m6}               - tool change
N   group 7 = {m3,m4,m5}         - spindle turning
N   group 8 = {m7,m8,m9}         - coolant
N   group 9 = {m48,m49}          - feed and speed override switch bypass
N
N   */
N
N    static const int _ems[] SET_TO
X    static const int _ems[] =
N    {
N        4,  4,  4,  7,  7,  7,  6,  8,  8,  8,
N            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
N            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
N            4, -1, -1, -1, -1, -1, -1, -1, -1, -1,
N            -1, -1, -1, -1, -1, -1, -1, -1,  9,  9,
N            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
N            4, -1, -1, -1, -1, -1, -1, -1, -1, -1,
N            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
N            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
N            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
N    };
N
N   /* 
N
N   This is an array of the index numbers of system parameters that must
N   be included in a file used with the rs274ngc_restore_parameters
N   function. The array is used by that function and by the
N   rs274ngc_save_parameters function.
N
N   */
N
N    static const int _required_parameters[] SET_TO
X    static const int _required_parameters[] =
N    {
N        5161, 5162, 5163,                         /* G28 home */
N    #ifdef AA
S            5164,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5165,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5166,                                 /*CC*/
N    #endif
N            5181, 5182, 5183,                     /* G30 home */
N    #ifdef AA
S            5184,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5185,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5186,                                 /*CC*/
N    #endif
N            5211, 5212, 5213,                     /* G92 offsets */
N    #ifdef AA
S            5214,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5215,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5216,                                 /*CC*/
N    #endif
N            5220,                                 /* selected coordinate */
N            5221, 5222, 5223,                     /* coordinate system 1 */
N    #ifdef AA
S            5224,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5225,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5226,                                 /*CC*/
N    #endif
N            5241, 5242, 5243,                     /* coordinate system 2 */
N    #ifdef AA
S            5244,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5245,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5246,                                 /*CC*/
N    #endif
N            5261, 5262, 5263,                     /* coordinate system 3 */
N    #ifdef AA
S            5264,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5265,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5266,                                 /*CC*/
N    #endif
N            5281, 5282, 5283,                     /* coordinate system 4 */
N    #ifdef AA
S            5284,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5285,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5286,                                 /*CC*/
N    #endif
N            5301, 5302, 5303,                     /* coordinate system 5 */
N    #ifdef AA
S            5304,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5305,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5306,                                 /*CC*/
N    #endif
N            5321, 5322, 5323,                     /* coordinate system 6 */
N    #ifdef AA
S            5324,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5325,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5326,                                 /*CC*/
N    #endif
N            5341, 5342, 5343,                     /* coordinate system 7 */
N    #ifdef AA
S            5344,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5345,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5346,                                 /*CC*/
N    #endif
N            5361, 5362, 5363,                     /* coordinate system 8 */
N    #ifdef AA
S            5364,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5365,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5366,                                 /*CC*/
N    #endif
N            5381, 5382, 5383,                     /* coordinate system 9 */
N    #ifdef AA
S            5384,                                 /*AA*/
N    #endif
N    #ifdef BB
S            5385,                                 /*BB*/
N    #endif
N    #ifdef CC
S            5386,                                 /*CC*/
N    #endif
N            RS274NGC_MAX_PARAMETERS
X            5400
N    };
N
N   /*
N
N   _readers is an array of pointers to functions that read.
N   It is used by read_one_item.
N
N   */
N
N    static const read_function_pointer _readers[] SET_TO
X    static const read_function_pointer _readers[] =
N    {
N        0,      0,      0,      0,      0,      0,      0,      0,      0,      0,
N            0,      0,      0,      0,      0,      0,      0,      0,      0,      0,
N            0,      0,      0,      0,      0,      0,      0,      0,      0,      0,
N            0,      0,      0, 0, 0, read_parameter_setting,0,      0,      0,      0,
N            read_comment, 0, 0,     0,      0,      0,      0,      0,      0,      0,
N            0,      0,      0,      0,      0,      0,      0,      0,      0,      0,
N            0,      0,      0,      0,      0,      0,      0,      0,      0,      0,
N            0,      0,      0,      0,      0,      0,      0,      0,      0,      0,
N            0,      0,      0,      0,      0,      0,      0,      0,      0,      0,
N            0,      0,      0,      0,      0,      0,      0,      read_a, read_b, read_c,
N            read_d, 0,      read_f, read_g, read_h, read_i, read_j, read_k, read_l, read_m,
N            0,      0,      read_p, read_q, read_r, read_s, read_t, 0     , 0,      0,
N            read_x, read_y, read_z
N    };
N
N   /****************************************************************************/
N
N   /* There are four global variables. The first three are _gees, _ems,
N   and _readers. The last one, declared here, is for interpreter settings */
N
N    static setup _setup;
N
N   /****************************************************************************/
N   /****************************************************************************/
N
N   /*
N
N   The functions in this section are the interpreter kernel functions
N
N   */
N
N   /***********************************************************************/
N
N   /* arc_data_comp_ijk
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The two calculable values of the radius differ by more than
N   tolerance: NCE_RADIUS_TO_END_OF_ARC_DIFFERS_FROM_RADIUS_TO_START
N   2. move is not G_2 or G_3: NCE_BUG_CODE_NOT_G2_OR_G3
N
N   Side effects:
N   This finds and sets the values of center_x, center_y, and turn.
N
N   Called by: convert_arc_comp1
N
N   This finds the center coordinates and number of full or partial turns
N   counterclockwise of a helical or circular arc in ijk-format in the XY
N   plane. The center is computed easily from the current point and center
N   offsets, which are given. It is checked that the end point lies one
N   tool radius from the arc.
N
N   */
N
N    static int arc_data_comp_ijk(                 /* ARGUMENTS                               */
N    int move,                                     /* either G_2 (cw arc) or G_3 (ccw arc)             */
N    int side,                                     /* either RIGHT or LEFT                             */
N    double tool_radius,                           /* radius of the tool                               */
N    double current_x,                             /* first coordinate of current point                */
N    double current_y,                             /* second coordinate of current point               */
N    double end_x,                                 /* first coordinate of arc end point                */
N    double end_y,                                 /* second coordinate of arc end point               */
N    double i_number,                              /* first coordinate offset of center from current   */
N    double j_number,                              /* second coordinate offset of center from current  */
N    double * center_x,                            /* pointer to first coordinate of center of arc     */
N    double * center_y,                            /* pointer to second coordinate of center of arc    */
N    int * turn,                                   /* pointer to number of full or partial circles CCW */
N    double tolerance)                             /* tolerance of differing radii                     */
N    {
N        static char name[] SET_TO "arc_data_comp_ijk";
X        static char name[] = "arc_data_comp_ijk";
N        double arc_radius;
N        double radius2;
N
N        *center_x SET_TO (current_x + i_number);
X        *center_x = (current_x + i_number);
N        *center_y SET_TO (current_y + j_number);
X        *center_y = (current_y + j_number);
N        arc_radius SET_TO hypot(i_number, j_number);
X        arc_radius = hypot(i_number, j_number);
N        radius2 SET_TO hypot((*center_x - end_x), (*center_y - end_y));
X        radius2 = hypot((*center_x - end_x), (*center_y - end_y));
N        radius2 SET_TO
X        radius2 =
N            (((side IS LEFT ) AND (move IS 30)) OR
X            (((side == 2 ) && (move == 30)) ||
N            ((side IS RIGHT) AND (move IS 20))) ?
X            ((side == 1) && (move == 20))) ?
N            (radius2 - tool_radius): (radius2 + tool_radius);
N        CHK((fabs(arc_radius - radius2) > tolerance),
N            NCE_RADIUS_TO_END_OF_ARC_DIFFERS_FROM_RADIUS_TO_START);
X        if ((fabs(arc_radius - radius2) > tolerance)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 152; } else;
N   /* This catches an arc too small for the tool, also */
N        if (move IS G_2)
X        if (move == 20)
N            *turn SET_TO -1;
X            *turn = -1;
N        else if (move IS G_3)
X        else if (move == 30)
N            *turn SET_TO 1;
X            *turn = 1;
N        else
N            ERM(NCE_BUG_CODE_NOT_G2_OR_G3);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 20; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* arc_data_comp_r
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The arc radius is too small to reach the end point:
N   NCE_RADIUS_TOO_SMALL_TO_REACH_END_POINT
N   2. The arc radius is not greater than the tool_radius, but should be:
N   NCE_TOOL_RADIUS_NOT_LESS_THAN_ARC_RADIUS_WITH_COMP
N   3. An imaginary value for offset would be found, which should never
N   happen if the theory is correct: NCE_BUG_IN_TOOL_RADIUS_COMP
N
N   Side effects:
N   This finds and sets the values of center_x, center_y, and turn.
N
N   Called by: convert_arc_comp1
N
N   This finds the center coordinates and number of full or partial turns
N   counterclockwise of a helical or circular arc (call it arc1) in
N   r-format in the XY plane.  Arc2 is constructed so that it is tangent
N   to a circle whose radius is tool_radius and whose center is at the
N   point (current_x, current_y) and passes through the point (end_x,
N   end_y). Arc1 has the same center as arc2. The radius of arc1 is one
N   tool radius larger or smaller than the radius of arc2.
N
N   If the value of the big_radius argument is negative, that means [NCMS,
N   page 21] that an arc larger than a semicircle is to be made.
N   Otherwise, an arc of a semicircle or less is made.
N
N   The algorithm implemented here is to construct a line L from the
N   current point to the end point, and a perpendicular to it from the
N   center of the arc which intersects L at point P. Since the distance
N   from the end point to the center and the distance from the current
N   point to the center are known, two equations for the length of the
N   perpendicular can be written. The right sides of the equations can be
N   set equal to one another and the resulting equation solved for the
N   length of the line from the current point to P. Then the location of
N   P, the length of the perpendicular, the angle of the perpendicular,
N   and the location of the center, can be found in turn.
N
N   This needs to be better documented, with figures. There are eight
N   possible arcs, since there are three binary possibilities: (1) tool
N   inside or outside arc, (2) clockwise or counterclockwise (3) two
N   positions for each arc (of the given radius) tangent to the tool
N   outline and through the end point. All eight are calculated below,
N   since theta, radius2, and turn may each have two values.
N
N   To see two positions for each arc, imagine the arc is a hoop, the
N   tool is a cylindrical pin, and the arc may rotate around the end point.
N   The rotation covers all possible positions of the arc. It is easy to
N   see the hoop is constrained by the pin at two different angles, whether
N   the pin is inside or outside the hoop.
N
N   */
N
N    static int arc_data_comp_r(                   /* ARGUMENTS                                 */
N    int move,                                     /* either G_2 (cw arc) or G_3 (ccw arc)             */
N    int side,                                     /* either RIGHT or LEFT                             */
N    double tool_radius,                           /* radius of the tool                               */
N    double current_x,                             /* first coordinate of current point                */
N    double current_y,                             /* second coordinate of current point               */
N    double end_x,                                 /* first coordinate of arc end point                */
N    double end_y,                                 /* second coordinate of arc end point               */
N    double big_radius,                            /* radius of arc                                    */
N    double * center_x,                            /* pointer to first coordinate of center of arc     */
N    double * center_y,                            /* pointer to second coordinate of center of arc    */
N    int * turn)                                   /* pointer to number of full or partial circles CCW */
N    {
N        static char name[] SET_TO "arc_data_comp_r";
X        static char name[] = "arc_data_comp_r";
N        double abs_radius;                        /* absolute value of big_radius          */
N        double alpha;                             /* direction of line from current to end */
N        double distance;                          /* length of line L from current to end  */
N        double mid_length;                        /* length from current point to point P  */
N        double offset;                            /* length of line from P to center       */
N        double radius2;                           /* distance from center to current point */
N        double mid_x;                             /* x-value of point P                    */
N        double mid_y;                             /* y-value of point P                    */
N        double theta;                             /* direction of line from P to center    */
N
N        abs_radius SET_TO fabs(big_radius);
X        abs_radius = fabs(big_radius);
N        CHK(((abs_radius <= tool_radius) AND (((side IS LEFT ) AND (move IS G_3)) OR
N            ((side IS RIGHT) AND (move IS G_2)))),
N            NCE_TOOL_RADIUS_NOT_LESS_THAN_ARC_RADIUS_WITH_COMP);
X        if (((abs_radius <= tool_radius) && (((side == 2 ) && (move == 30)) || ((side == 1) && (move == 20))))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 167; } else;
N
N        distance SET_TO hypot((end_x - current_x), (end_y - current_y));
X        distance = hypot((end_x - current_x), (end_y - current_y));
N        alpha SET_TO atan2 ((end_y - current_y), (end_x - current_x));
X        alpha = atan2 ((end_y - current_y), (end_x - current_x));
N        theta SET_TO (((move IS G_3) AND (big_radius > 0)) OR
X        theta = (((move == 30) && (big_radius > 0)) ||
N            ((move IS G_2) AND (big_radius < 0))) ?
X            ((move == 20) && (big_radius < 0))) ?
N            (alpha + PI2) : (alpha - PI2);
X            (alpha + 1.5707963267948966) : (alpha - 1.5707963267948966);
N        radius2 SET_TO (((side IS LEFT ) AND (move IS G_3)) OR
X        radius2 = (((side == 2 ) && (move == 30)) ||
N            ((side IS RIGHT) AND (move IS G_2))) ?
X            ((side == 1) && (move == 20))) ?
N            (abs_radius - tool_radius) : (abs_radius + tool_radius);
N        CHK((distance > (radius2 + abs_radius)),
N            NCE_RADIUS_TOO_SMALL_TO_REACH_END_POINT);
X        if ((distance > (radius2 + abs_radius))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 153; } else;
N        mid_length SET_TO (((radius2 * radius2) + (distance * distance) -
X        mid_length = (((radius2 * radius2) + (distance * distance) -
N            (abs_radius * abs_radius)) / (2.0 * distance));
N        mid_x SET_TO (current_x + (mid_length * cos(alpha)));
X        mid_x = (current_x + (mid_length * cos(alpha)));
N        mid_y SET_TO (current_y + (mid_length * sin(alpha)));
X        mid_y = (current_y + (mid_length * sin(alpha)));
N        CHK(((radius2 * radius2) <= (mid_length * mid_length)),
N            NCE_BUG_IN_TOOL_RADIUS_COMP);
X        if (((radius2 * radius2) <= (mid_length * mid_length))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 33; } else;
N        offset SET_TO sqrt((radius2 * radius2) - (mid_length * mid_length));
X        offset = sqrt((radius2 * radius2) - (mid_length * mid_length));
N        *center_x SET_TO mid_x + (offset * cos(theta));
X        *center_x = mid_x + (offset * cos(theta));
N        *center_y SET_TO mid_y + (offset * sin(theta));
X        *center_y = mid_y + (offset * sin(theta));
N        *turn SET_TO (move IS G_2) ? -1 : 1;
X        *turn = (move == 20) ? -1 : 1;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* arc_data_ijk
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The two calculable values of the radius differ by more than
N   tolerance: NCE_RADIUS_TO_END_OF_ARC_DIFFERS_FROM_RADIUS_TO_START
N   2. The move code is not G_2 or G_3: NCE_BUG_CODE_NOT_G2_OR_G3
N   3. Either of the two calculable values of the radius is zero:
N   NCE_ZERO_RADIUS_ARC
N
N   Side effects:
N   This finds and sets the values of center_x, center_y, and turn.
N
N   Called by:
N   convert_arc2
N   convert_arc_comp2
N
N   This finds the center coordinates and number of full or partial turns
N   counterclockwise of a helical or circular arc in ijk-format. This
N   function is used by convert_arc2 for all three planes, so "x" and
N   "y" really mean "first_coordinate" and "second_coordinate" wherever
N   they are used here as suffixes of variable names. The i and j prefixes
N   are handled similarly.
N
N   */
N
N    static int arc_data_ijk(                      /* ARGUMENTS                                       */
N    int move,                                     /* either G_2 (cw arc) or G_3 (ccw arc)            */
N    double current_x,                             /* first coordinate of current point               */
N    double current_y,                             /* second coordinate of current point              */
N    double end_x,                                 /* first coordinate of arc end point               */
N    double end_y,                                 /* second coordinate of arc end point              */
N    double i_number,                              /* first coordinate offset of center from current  */
N    double j_number,                              /* second coordinate offset of center from current */
N    double * center_x,                            /* pointer to first coordinate of center of arc    */
N    double * center_y,                            /* pointer to second coordinate of center of arc   */
N    int * turn,                                   /* pointer to no. of full or partial circles CCW   */
N    double tolerance)                             /* tolerance of differing radii                    */
N    {
N        static char name[] SET_TO "arc_data_ijk";
X        static char name[] = "arc_data_ijk";
N        double radius;                            /* radius to current point */
N        double radius2;                           /* radius to end point     */
N        *center_x SET_TO (current_x + i_number);
X        *center_x = (current_x + i_number);
N        *center_y SET_TO (current_y + j_number);
X        *center_y = (current_y + j_number);
N        radius SET_TO hypot((*center_x - current_x), (*center_y - current_y));
X        radius = hypot((*center_x - current_x), (*center_y - current_y));
N        radius2 SET_TO hypot((*center_x - end_x), (*center_y - end_y));
X        radius2 = hypot((*center_x - end_x), (*center_y - end_y));
N        CHK(((radius IS 0.0) OR (radius2 IS 0.0)), NCE_ZERO_RADIUS_ARC);
X        if (((radius == 0.0) || (radius2 == 0.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 197; } else;
N        CHK((fabs(radius - radius2) > tolerance),
N            NCE_RADIUS_TO_END_OF_ARC_DIFFERS_FROM_RADIUS_TO_START);
X        if ((fabs(radius - radius2) > tolerance)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 152; } else;
N        if (move IS G_2)
X        if (move == 20)
N            *turn SET_TO -1;
X            *turn = -1;
N        else if (move IS G_3)
X        else if (move == 30)
N            *turn SET_TO 1;
X            *turn = 1;
N        else
N            ERM(NCE_BUG_CODE_NOT_G2_OR_G3);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 20; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* arc_data_r
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The radius is too small to reach the end point:
N   NCE_ARC_RADIUS_TOO_SMALL_TO_REACH_END_POINT
N   2. The current point is the same as the end point of the arc
N   (so that it is not possible to locate the center of the circle):
N   NCE_CURRENT_POINT_SAME_AS_END_POINT_OF_ARC
N
N   Side effects:
N   This finds and sets the values of center_x, center_y, and turn.
N
N   Called by:
N   convert_arc2
N   convert_arc_comp2
N
N   This finds the center coordinates and number of full or partial turns
N   counterclockwise of a helical or circular arc in the r format. This
N   function is used by convert_arc2 for all three planes, so "x" and
N   "y" really mean "first_coordinate" and "second_coordinate" wherever
N   they are used here as suffixes of variable names.
N
N   If the value of the radius argument is negative, that means [NCMS,
N   page 21] that an arc larger than a semicircle is to be made.
N   Otherwise, an arc of a semicircle or less is made.
N
N   The algorithm used here is based on finding the midpoint M of the line
N   L between the current point and the end point of the arc. The center
N   of the arc lies on a line through M perpendicular to L.
N
N   */
N
N    static int arc_data_r(                        /* ARGUMENTS                                     */
N    int move,                                     /* either G_2 (cw arc) or G_3 (ccw arc)          */
N    double current_x,                             /* first coordinate of current point             */
N    double current_y,                             /* second coordinate of current point            */
N    double end_x,                                 /* first coordinate of arc end point             */
N    double end_y,                                 /* second coordinate of arc end point            */
N    double radius,                                /* radius of arc                                 */
N    double * center_x,                            /* pointer to first coordinate of center of arc  */
N    double * center_y,                            /* pointer to second coordinate of center of arc */
N    int * turn)                                   /* pointer to no. of full or partial circles CCW */
N    {
N        static char name[] SET_TO "arc_data_r";
X        static char name[] = "arc_data_r";
N        double abs_radius;                        /* absolute value of given radius */
N        double half_length;                       /* distance from M to end point   */
N        double mid_x;                             /* first coordinate of M          */
N        double mid_y;                             /* second coordinate of M         */
N        double offset;                            /* distance from M to center      */
N        double theta;                             /* angle of line from M to center */
N        double turn2;                             /* absolute value of half of turn */
N
N        CHK(((end_x IS current_x) AND (end_y IS current_y)),
N            NCE_CURRENT_POINT_SAME_AS_END_POINT_OF_ARC);
X        if (((end_x == current_x) && (end_y == current_y))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 69; } else;
N        abs_radius SET_TO fabs(radius);
X        abs_radius = fabs(radius);
N        mid_x SET_TO (end_x + current_x)/2.0;
X        mid_x = (end_x + current_x)/2.0;
N        mid_y SET_TO (end_y + current_y)/2.0;
X        mid_y = (end_y + current_y)/2.0;
N        half_length SET_TO hypot((mid_x - end_x), (mid_y - end_y));
X        half_length = hypot((mid_x - end_x), (mid_y - end_y));
N        CHK(((half_length/abs_radius) > (1+TINY)),
N            NCE_ARC_RADIUS_TOO_SMALL_TO_REACH_END_POINT);
X        if (((half_length/abs_radius) > (1+1e-12))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 7; } else;
N        if ((half_length/abs_radius) > (1-TINY))
X        if ((half_length/abs_radius) > (1-1e-12))
N            half_length SET_TO abs_radius;        /* allow a small error for semicircle */
X            half_length = abs_radius;         
N   /* check needed before calling asin   */
N        if (((move IS G_2) AND (radius > 0)) OR
X        if (((move == 20) && (radius > 0)) ||
N            ((move IS G_3) AND (radius < 0)))
X            ((move == 30) && (radius < 0)))
N            theta SET_TO atan2((end_y - current_y), (end_x - current_x)) - PI2;
X            theta = atan2((end_y - current_y), (end_x - current_x)) - 1.5707963267948966;
N        else
N            theta SET_TO atan2((end_y - current_y), (end_x - current_x)) + PI2;
X            theta = atan2((end_y - current_y), (end_x - current_x)) + 1.5707963267948966;
N
N        turn2 SET_TO asin (half_length/abs_radius);
X        turn2 = asin (half_length/abs_radius);
N        offset SET_TO abs_radius * cos(turn2);
X        offset = abs_radius * cos(turn2);
N        *center_x SET_TO mid_x + (offset * cos(theta));
X        *center_x = mid_x + (offset * cos(theta));
N        *center_y SET_TO mid_y + (offset * sin(theta));
X        *center_y = mid_y + (offset * sin(theta));
N        *turn SET_TO (move IS G_2) ? -1 : 1;
X        *turn = (move == 20) ? -1 : 1;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* check_g_codes
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. NCE_DWELL_TIME_MISSING_WITH_G4
N   2. NCE_MUST_USE_G0_OR_G1_WITH_G53
N   3. NCE_CANNOT_USE_G53_INCREMENTAL
N   4. NCE_LINE_WITH_G10_DOES_NOT_HAVE_L2
N   5. NCE_P_VALUE_NOT_AN_INTEGER_WITH_G10_L2
N   6. NCE_P_VALUE_OUT_OF_RANGE_WITH_G10_L2
N   7. NCE_BUG_BAD_G_CODE_MODAL_GROUP_0
N
N   Side effects: none
N
N   Called by: check_items
N
N   This runs checks on g_codes from a block of RS274/NGC instructions.
N   Currently, all checks are on g_codes in modal group 0.
N
N   The read_g function checks for errors which would foul up the reading.
N   The enhance_block function checks for logical errors in the use of
N   axis values by g-codes in modal groups 0 and 1.
N   This function checks for additional logical errors in g_codes.
N
N   [Fanuc, page 45, note 4] says there is no maximum for how many g_codes
N   may be put on the same line, [NCMS] says nothing one way or the other,
N   so the test for that is not used.
N
N   We are suspending any implicit motion g_code when a g_code from our
N   group 0 is used.  The implicit motion g_code takes effect again
N   automatically after the line on which the group 0 g_code occurs.  It
N   is not clear what the intent of [Fanuc] is in this regard. The
N   alternative is to require that any implicit motion be explicitly
N   cancelled.
N
N   Not all checks on g_codes are included here. Those checks that are
N   sensitive to whether other g_codes on the same line have been executed
N   yet are made by the functions called by convert_g.
N
N   Our reference sources differ regarding what codes may be used for
N   dwell time.  [Fanuc, page 58] says use "p" or "x". [NCMS, page 23] says
N   use "p", "x", or "u". We are allowing "p" only, since it is consistent
N   with both sources and "x" would be confusing. However, "p" is also used
N   with G10, where it must be an integer, so reading "p" values is a bit
N   more trouble than would be nice.
N
N   */
N
N    static int check_g_codes(                     /* ARGUMENTS                        */
N    block_pointer block,                          /* pointer to a block to be checked */
N    setup_pointer settings)                       /* pointer to machine settings      */
N    {
N        static char name[] SET_TO "check_g_codes";
X        static char name[] = "check_g_codes";
N        int mode0;
N        int p_int;
N
N        mode0 SET_TO block->g_modes[0];
X        mode0 = block->g_modes[0];
N
N        if (mode0 IS -1)
X        if (mode0 == -1)
N            {}
N            else if (mode0 IS G_4)
X            else if (mode0 == 40)
N        {
N            CHK((block->p_number IS -1.0), NCE_DWELL_TIME_MISSING_WITH_G4);
X            if ((block->p_number == -1.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 72; } else;
N        }
N        else if (mode0 IS G_10)
X        else if (mode0 == 100)
N        {
N            p_int SET_TO (int)(block->p_number + 0.0001);
X            p_int = (int)(block->p_number + 0.0001);
N            CHK((block->l_number ISNT 2), NCE_LINE_WITH_G10_DOES_NOT_HAVE_L2);
X            if ((block->l_number != 2)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 99; } else;
N            CHK((((block->p_number + 0.0001) - p_int) > 0.0002),
N                NCE_P_VALUE_NOT_AN_INTEGER_WITH_G10_L2);
X            if ((((block->p_number + 0.0001) - p_int) > 0.0002)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 138; } else;
N            CHK(((p_int < 1) OR (p_int > 9)), NCE_P_VALUE_OUT_OF_RANGE_WITH_G10_L2);
X            if (((p_int < 1) || (p_int > 9))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 139; } else;
N        }
N        else if (mode0 IS G_28)
X        else if (mode0 == 280)
N            {}
N            else if (mode0 IS G_30)
X            else if (mode0 == 300)
N                {}
N                else if (mode0 IS G_53)
X                else if (mode0 == 530)
N                {
N                    CHK(((block->motion_to_be ISNT G_0) AND (block->motion_to_be ISNT G_1)),
N                NCE_MUST_USE_G0_OR_G1_WITH_G53);
X                    if (((block->motion_to_be != 0) && (block->motion_to_be != 10))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 120; } else;
N            CHK(((block->g_modes[3] IS G_91) OR
N                ((block->g_modes[3] ISNT G_90) AND
N                (settings->distance_mode IS MODE_INCREMENTAL))),
N                NCE_CANNOT_USE_G53_INCREMENTAL);
X            if (((block->g_modes[3] == 910) || ((block->g_modes[3] != 900) && (settings->distance_mode == MODE_INCREMENTAL)))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 61; } else;
N        }
N        else if (mode0 IS G_92)
X        else if (mode0 == 920)
N            {}
N            else if ((mode0 IS G_92_1) OR (mode0 IS G_92_2) OR (mode0 IS G_92_3))
X            else if ((mode0 == 921) || (mode0 == 922) || (mode0 == 923))
N                {}
N                else
N                    ERM(NCE_BUG_BAD_G_CODE_MODAL_GROUP_0);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 15; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* check_items
N
N   Returned Value: int
N   If any one of check_g_codes, check_m_codes, and check_other_codes
N   returns an error code, this returns that code.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects: none
N
N   Called by: parse_line
N
N   This runs checks on a block of RS274 code.
N
N   The functions named read_XXXX check for errors which would foul up the
N   reading. This function checks for additional logical errors.
N
N   A block has an array of g_codes, which are initialized to -1
N   (meaning no code). This calls check_g_codes to check the g_codes.
N
N   A block has an array of m_codes, which are initialized to -1
N   (meaning no code). This calls check_m_codes to check the m_codes.
N
N   Items in the block which are not m or g codes are checked by
N   check_other_codes.
N
N   */
N
N    static int check_items(                       /* ARGUMENTS                        */
N    block_pointer block,                          /* pointer to a block to be checked */
N    setup_pointer settings)                       /* pointer to machine settings      */
N    {
N        static char name[] SET_TO "check_items";
X        static char name[] = "check_items";
N        int status;
N
N        CHP(check_g_codes(block, settings));
X        if ((status = (check_g_codes(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHP(check_m_codes(block));
X        if ((status = (check_m_codes(block))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHP(check_other_codes(block));
X        if ((status = (check_other_codes(block))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* check_m_codes
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. There are too many m codes in the block: NCE_TOO_MANY_M_CODES_ON_LINE
N
N   Side effects: none
N
N   Called by: check_items
N
N   This runs checks on m_codes from a block of RS274/NGC instructions.
N
N   The read_m function checks for errors which would foul up the
N   reading. This function checks for additional errors in m_codes.
N
N   */
N
N    static int check_m_codes(                     /* ARGUMENTS                        */
N    block_pointer block)                          /* pointer to a block to be checked */
N    {
N        static char name[] SET_TO "check_m_codes";
X        static char name[] = "check_m_codes";
N
N        CHK((block->m_count > MAX_EMS), NCE_TOO_MANY_M_CODES_ON_LINE);
X        if ((block->m_count > 4)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 163; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* check_other_codes
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. An A-axis value is given with a canned cycle (g80 to g89):
N   NCE_CANNOT_PUT_AN_A_IN_CANNED_CYCLE
N   2. A B-axis value is given with a canned cycle (g80 to g89):
N   NCE_CANNOT_PUT_A_B_IN_CANNED_CYCLE
N   3. A C-axis value is given with a canned cycle (g80 to g89):
N   NCE_CANNOT_PUT_A_C_IN_CANNED_CYCLE
N   4. A d word is in a block with no cutter_radius_compensation_on command:
N   NCE_D_WORD_WITH_NO_G41_OR_G42
N   5. An h_number is in a block with no tool length offset setting:
N   NCE_H_WORD_WITH_NO_G43
N   6. An i_number is in a block with no G code that uses it:
N   NCE_I_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT
N   7. A j_number is in a block with no G code that uses it:
N   NCE_J_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT
N   8. A k_number is in a block with no G code that uses it:
N   NCE_K_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT
N   9. A l_number is in a block with no G code that uses it:
N   NCE_L_WORD_WITH_NO_CANNED_CYCLE_OR_G10
N   10. A p_number is in a block with no G code that uses it:
N   NCE_P_WORD_WITH_NO_G4_G10_G82_G86_G88_G89
N   11. A q_number is in a block with no G code that uses it:
N   NCE_Q_WORD_WITH_NO_G83
N   12. An r_number is in a block with no G code that uses it:
N   NCE_R_WORD_WITH_NO_G_CODE_THAT_USES_IT
N
N   Side effects: none
N
N   Called by: check_items
N
N   This runs checks on codes from a block of RS274/NGC code which are
N   not m or g codes.
N
N   The functions named read_XXXX check for errors which would foul up the
N   reading. This function checks for additional logical errors in codes.
N
N   */
N
N    static int check_other_codes(                 /* ARGUMENTS                               */
N    block_pointer block)                          /* pointer to a block of RS274/NGC instructions */
N    {
N        static char name[] SET_TO "check_other_codes";
X        static char name[] = "check_other_codes";
N        int motion;
N
N        motion SET_TO block->motion_to_be;
X        motion = block->motion_to_be;
N#ifdef AA
S        if (block->a_flag ISNT OFF)
S        {
S            CHK(((block->g_modes[1] > G_80) AND (block->g_modes[1] < G_90)),
S                NCE_CANNOT_PUT_AN_A_IN_CANNED_CYCLE);
S        }
N#endif
N#ifdef BB
S        if (block->b_flag ISNT OFF)
S        {
S            CHK(((block->g_modes[1] > G_80) AND (block->g_modes[1] < G_90)),
S                NCE_CANNOT_PUT_A_B_IN_CANNED_CYCLE);
S        }
N#endif
N#ifdef CC
S        if (block->c_flag ISNT OFF)
S        {
S            CHK(((block->g_modes[1] > G_80) AND (block->g_modes[1] < G_90)),
S                NCE_CANNOT_PUT_A_C_IN_CANNED_CYCLE);
S        }
N#endif
N        if (block->d_number ISNT -1)
X        if (block->d_number != -1)
N        {
N            CHK(((block->g_modes[7] ISNT G_41) AND (block->g_modes[7] ISNT G_42)),
N                NCE_D_WORD_WITH_NO_G41_OR_G42);
X            if (((block->g_modes[7] != 410) && (block->g_modes[7] != 420))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 71; } else;
N        }
N        if (block->h_number ISNT -1)
X        if (block->h_number != -1)
N        {
N            CHK((block->g_modes[8] ISNT G_43), NCE_H_WORD_WITH_NO_G43);
X            if ((block->g_modes[8] != 430)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 85; } else;
N        }
N
N        if (block->i_flag IS ON)                  /* could still be useless if yz_plane arc */
X        if (block->i_flag == 1)                   
N        {
N            CHK(((motion ISNT G_2) AND (motion ISNT G_3) AND (motion ISNT G_87)),
N                NCE_I_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT);
X            if (((motion != 20) && (motion != 30) && (motion != 870))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 88; } else;
N        }
N
N        if (block->j_flag IS ON)                  /* could still be useless if xz_plane arc */
X        if (block->j_flag == 1)                   
N        {
N            CHK(((motion ISNT G_2) AND (motion ISNT G_3) AND (motion ISNT G_87)),
N                NCE_J_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT);
X            if (((motion != 20) && (motion != 30) && (motion != 870))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 91; } else;
N        }
N
N        if (block->k_flag IS ON)                  /* could still be useless if xy_plane arc */
X        if (block->k_flag == 1)                   
N        {
N            CHK(((motion ISNT G_2) AND (motion ISNT G_3) AND (motion ISNT G_87)),
N                NCE_K_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT);
X            if (((motion != 20) && (motion != 30) && (motion != 870))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 94; } else;
N        }
N
N        if (block->l_number ISNT -1)
X        if (block->l_number != -1)
N        {
N            CHK((((motion < G_81) OR (motion > G_89)) AND
N                (block->g_modes[0] ISNT G_10)),
N                NCE_L_WORD_WITH_NO_CANNED_CYCLE_OR_G10);
X            if ((((motion < 810) || (motion > 890)) && (block->g_modes[0] != 100))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 95; } else;
N        }
N
N        if (block->p_number ISNT -1.0)
X        if (block->p_number != -1.0)
N        {
N            CHK(((block->g_modes[0] ISNT G_10) AND
N                (block->g_modes[0] ISNT G_4) AND
N                (motion ISNT G_82) AND (motion ISNT G_86) AND
N                (motion ISNT G_88) AND (motion ISNT G_89)),
N                NCE_P_WORD_WITH_NO_G4_G10_G82_G86_G88_G89);
X            if (((block->g_modes[0] != 100) && (block->g_modes[0] != 40) && (motion != 820) && (motion != 860) && (motion != 880) && (motion != 890))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 140; } else;
N        }
N
N        if (block->q_number ISNT -1.0)
X        if (block->q_number != -1.0)
N        {
N            CHK((motion ISNT G_83), NCE_Q_WORD_WITH_NO_G83);
X            if ((motion != 830)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 144; } else;
N        }
N
N        if (block->r_flag IS ON)
X        if (block->r_flag == 1)
N        {
N            CHK((((motion ISNT G_2) AND (motion ISNT G_3)) AND
N                ((motion < G_81) OR (motion > G_89))),
N                NCE_R_WORD_WITH_NO_G_CODE_THAT_USES_IT);
X            if ((((motion != 20) && (motion != 30)) && ((motion < 810) || (motion > 890)))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 151; } else;
N        }
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* close_and_downcase
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. A left parenthesis is found inside a comment:
N   NCE_NESTED_COMMENT_FOUND
N   2. The line ends before an open comment is closed:
N   NCE_UNCLOSED_COMMENT_FOUND
N   3. A newline character is found that is not followed by null:
N   NCE_NULL_MISSING_AFTER_NEWLINE
N
N   Side effects: See below
N
N   Called by:  read_text
N
N   To simplify handling upper case letters, spaces, and tabs, this
N   function removes spaces and and tabs and downcases everything on a
N   line which is not part of a comment.
N
N   Comments are left unchanged in place. Comments are anything
N   enclosed in parentheses. Nested comments, indicated by a left
N   parenthesis inside a comment, are illegal.
N
N   The line must have a null character at the end when it comes in.
N   The line may have one newline character just before the end. If
N   there is a newline, it will be removed.
N
N   Although this software system detects and rejects all illegal characters
N   and illegal syntax, this particular function does not detect problems
N   with anything but comments.
N
N   We are treating RS274 code here as case-insensitive and spaces and
N   tabs as if they have no meaning. [RS274D, page 6] says spaces and tabs
N   are to be ignored by control.
N
N   The KT and NGC manuals say nothing about case or spaces and tabs.
N
N   */
N
N    static int close_and_downcase(                /* ARGUMENTS                   */
N    char * line)                                  /* string: one line of NC code */
N    {
N        static char name[] SET_TO "close_and_downcase";
X        static char name[] = "close_and_downcase";
N        int m;
N        int n;
N        int comment;
N        char item;
N        comment SET_TO 0;
X        comment = 0;
N        for (n SET_TO 0, m SET_TO 0; (item SET_TO line[m]) ISNT (char) NULL; m++)
X        for (n = 0, m = 0; (item = line[m]) != (char) 0; m++)
N        {
N            if (comment)
N            {
N                line[n++] SET_TO item;
X                line[n++] = item;
N                if (item IS ')')
X                if (item == ')')
N                {
N                    comment SET_TO 0;
X                    comment = 0;
N                }
N                else if (item IS '(')
X                else if (item == '(')
N                    ERM(NCE_NESTED_COMMENT_FOUND);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 132; } else;
N            }
N            else if ((item IS ' ') OR (item IS '\t') OR (item IS '\r'));
X            else if ((item == ' ') || (item == '\t') || (item == '\r'));
N   /* don't copy blank or tab or CR */
N            else if (item IS '\n')                /* don't copy newline            */
X            else if (item == '\n')                 
N            {                                     /* but check null follows        */
N                CHK((line[m+1] ISNT 0), NCE_NULL_MISSING_AFTER_NEWLINE);
X                if ((line[m+1] != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 136; } else;
N            }
N            else if ((64 < item) AND (item < 91)) /* downcase upper case letters */
X            else if ((64 < item) && (item < 91))  
N            {
N                line[n++] SET_TO (32 + item);
X                line[n++] = (32 + item);
N            }
N            else if (item IS '(')                 /* comment is starting */
X            else if (item == '(')                  
N            {
N                comment SET_TO 1;
X                comment = 1;
N                line[n++] SET_TO item;
X                line[n++] = item;
N            }
N            else
N            {
N                line[n++] SET_TO item;            /* copy anything else */
X                line[n++] = item;             
N            }
N        }
N        CHK((comment), NCE_UNCLOSED_COMMENT_FOUND);
X        if ((comment)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 171; } else;
N        line[n] SET_TO 0;
X        line[n] = 0;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_arc
N
N   Returned Value: int
N   If one of the following functions returns an error code,
N   this returns that error code.
N   convert_arc_comp1
N   convert_arc_comp2
N   convert_arc2
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, this returns RS274NGC_OK.
N   1. The block has neither an r value nor any i,j,k values:
N   NCE_R_I_J_K_WORDS_ALL_MISSING_FOR_ARC
N   2. The block has both an r value and one or more i,j,k values:
N   NCE_MIXED_RADIUS_IJK_FORMAT_FOR_ARC
N   3. In the ijk format the XY-plane is selected and
N   the block has a k value: NCE_K_WORD_GIVEN_FOR_ARC_IN_XY_PLANE
N   4. In the ijk format the YZ-plane is selected and
N   the block has an i value: NCE_I_WORD_GIVEN_FOR_ARC_IN_YZ_PLANE
N   5. In the ijk format the XZ-plane is selected and
N   the block has a j value: NCE_J_WORD_GIVEN_FOR_ARC_IN_XZ_PLANE
N   6. In either format any of the following occurs.
N   a. The XY-plane is selected and the block has no x or y value:
N   NCE_X_AND_Y_WORDS_MISSING_FOR_ARC_IN_XY_PLANE
N   b. The YZ-plane is selected and the block has no y or z value:
N   NCE_Y_AND_Z_WORDS_MISSING_FOR_ARC_IN_YZ_PLANE
N   c. The ZX-plane is selected and the block has no z or x value:
N   NCE_X_AND_Z_WORDS_MISSING_FOR_ARC_IN_XZ_PLANE
N   7. The selected plane is an unknown plane:
N   NCE_BUG_PLANE_NOT_XY_YZ__OR_XZ
N   8. The feed rate mode is UNITS_PER_MINUTE and feed rate is zero:
N   NCE_CANNOT_MAKE_ARC_WITH_ZERO_FEED_RATE
N   9. The feed rate mode is INVERSE_TIME and the block has no f word:
N   NCE_F_WORD_MISSING_WITH_INVERSE_TIME_ARC_MOVE
N
N   Side effects:
N   This generates and executes an arc command at feed rate
N   (and, possibly a second arc command). It also updates the setting
N   of the position of the tool point to the end point of the move.
N
N   Called by: convert_motion.
N
N   This converts a helical or circular arc.  The function calls:
N   convert_arc2 (when cutter radius compensation is off) or
N   convert_arc_comp1 (when cutter comp is on and this is the first move) or
N   convert_arc_comp2 (when cutter comp is on and this is not the first move).
N
N   If the ijk format is used, at least one of the offsets in the current
N   plane must be given in the block; it is common but not required to
N   give both offsets. The offsets are always incremental [NCMS, page 21].
N
N   */
N
N    static int convert_arc(                       /* ARGUMENTS                                */
N    int move,                                     /* either G_2 (cw arc) or G_3 (ccw arc)     */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        static char name[] SET_TO "convert_arc";
X        static char name[] = "convert_arc";
N        int status;
N        int first;                                /* flag set ON if this is first move after comp ON */
N        int ijk_flag;                             /* flag set ON if any of i,j,k present in NC code  */
N        double end_x;
N        double end_y;
N        double end_z;
N#ifdef AA
S        double AA_end;                            /*AA*/
N#endif
N#ifdef BB
S        double BB_end;                            /*BB*/
N#endif
N#ifdef CC
S        double CC_end;                            /*CC*/
N#endif
N
N        ijk_flag SET_TO
X        ijk_flag =
N            ((block->i_flag OR block->j_flag) OR block->k_flag) ? ON : OFF;
X            ((block->i_flag || block->j_flag) || block->k_flag) ? 1 : 0;
N        first SET_TO (settings->program_x IS UNKNOWN);
X        first = (settings->program_x == 1e-20);
N
N        CHK(((block->r_flag ISNT ON) AND (ijk_flag ISNT ON)),
N            NCE_R_I_J_K_WORDS_ALL_MISSING_FOR_ARC);
X        if (((block->r_flag != 1) && (ijk_flag != 1))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 147; } else;
N        CHK(((block->r_flag IS ON) AND (ijk_flag IS ON)),
N            NCE_MIXED_RADIUS_IJK_FORMAT_FOR_ARC);
X        if (((block->r_flag == 1) && (ijk_flag == 1))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 101; } else;
N        if (settings->feed_mode IS UNITS_PER_MINUTE)
X        if (settings->feed_mode == 0)
N        {
N            CHK((settings->feed_rate IS 0.0),
N                NCE_CANNOT_MAKE_ARC_WITH_ZERO_FEED_RATE);
X            if ((settings->feed_rate == 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 43; } else;
N        }
N        else if (settings->feed_mode IS INVERSE_TIME)
X        else if (settings->feed_mode == 1)
N        {
N            CHK((block->f_number IS -1.0),
N                NCE_F_WORD_MISSING_WITH_INVERSE_TIME_ARC_MOVE);
X            if ((block->f_number == -1.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 78; } else;
N        }
N        if (ijk_flag)
N        {
N            if (settings->plane IS CANON_PLANE_XY)
X            if (settings->plane == 1)
N            {
N                CHK((block->k_flag), NCE_K_WORD_GIVEN_FOR_ARC_IN_XY_PLANE);
X                if ((block->k_flag)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 92; } else;
N                if (block->i_flag IS OFF)         /* i or j flag on to get here */
X                if (block->i_flag == 0)          
N                    block->i_number SET_TO 0.0;
X                    block->i_number = 0.0;
N                else if (block->j_flag IS OFF)
X                else if (block->j_flag == 0)
N                    block->j_number SET_TO 0.0;
X                    block->j_number = 0.0;
N            }
N            else if (settings->plane IS CANON_PLANE_YZ)
X            else if (settings->plane == 2)
N            {
N                CHK((block->i_flag), NCE_I_WORD_GIVEN_FOR_ARC_IN_YZ_PLANE);
X                if ((block->i_flag)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 86; } else;
N                if (block->j_flag IS OFF)         /* j or k flag on to get here */
X                if (block->j_flag == 0)          
N                    block->j_number SET_TO 0.0;
X                    block->j_number = 0.0;
N                else if (block->k_flag IS OFF)
X                else if (block->k_flag == 0)
N                    block->k_number SET_TO 0.0;
X                    block->k_number = 0.0;
N            }
N            else if (settings->plane IS CANON_PLANE_XZ)
X            else if (settings->plane == 3)
N            {
N                CHK((block->j_flag), NCE_J_WORD_GIVEN_FOR_ARC_IN_XZ_PLANE);
X                if ((block->j_flag)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 89; } else;
N                if (block->i_flag IS OFF)         /* i or k flag on to get here */
X                if (block->i_flag == 0)          
N                    block->i_number SET_TO 0.0;
X                    block->i_number = 0.0;
N                else if (block->k_flag IS OFF)
X                else if (block->k_flag == 0)
N                    block->k_number SET_TO 0.0;
X                    block->k_number = 0.0;
N            }
N            else
N                ERM(NCE_BUG_PLANE_NOT_XY_YZ_OR_XZ);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 34; } else;
N        }
N        else;                                     /* r format arc; no other checks needed specific to this format */
N
N        if (settings->plane IS CANON_PLANE_XY)    /* checks for both formats */
X        if (settings->plane == 1)     
N        {
N            CHK(((block->x_flag IS OFF) AND (block->y_flag IS OFF)),
N                NCE_X_AND_Y_WORDS_MISSING_FOR_ARC_IN_XY_PLANE);
X            if (((block->x_flag == 0) && (block->y_flag == 0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 189; } else;
N        }
N        else if (settings->plane IS CANON_PLANE_YZ)
X        else if (settings->plane == 2)
N        {
N            CHK(((block->y_flag IS OFF) AND (block->z_flag IS OFF)),
N                NCE_Y_AND_Z_WORDS_MISSING_FOR_ARC_IN_YZ_PLANE);
X            if (((block->y_flag == 0) && (block->z_flag == 0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 193; } else;
N        }
N        else if (settings->plane IS CANON_PLANE_XZ)
X        else if (settings->plane == 3)
N        {
N            CHK(((block->x_flag IS OFF) AND (block->z_flag IS OFF)),
N                NCE_X_AND_Z_WORDS_MISSING_FOR_ARC_IN_XZ_PLANE);
X            if (((block->x_flag == 0) && (block->z_flag == 0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 190; } else;
N        }
N
N        find_ends(block, settings, &end_x, &end_y,
N            &end_z
N    #ifdef AA
S            , &AA_end
N    #endif
N
N    #ifdef BB
S            , &BB_end
N    #endif
N
N    #ifdef CC
S            , &CC_end
N    #endif
N            );
N        settings->motion_mode SET_TO move;
X        settings->motion_mode = move;
N
N        if (settings->plane IS CANON_PLANE_XY)
X        if (settings->plane == 1)
N        {
N            if ((settings->cutter_comp_side IS OFF) OR
X            if ((settings->cutter_comp_side == 0) ||
N                (settings->cutter_comp_radius IS 0.0))
X                (settings->cutter_comp_radius == 0.0))
N            {
N                status SET_TO
X                status =
N                    convert_arc2(move, block, settings,
N                    &(settings->current_x), &(settings->current_y),
N                    &(settings->current_z), end_x, end_y,
N                    end_z
N    #ifdef AA
S                    , AA_end
N    #endif
N
N    #ifdef BB
S                    , BB_end
N    #endif
N
N    #ifdef CC
S                    , CC_end
N    #endif
N                    , block->i_number,
N                    block->j_number);
N                CHP(status);
X                if ((status = (status)) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            }
N            else if (first)
N            {
N                status SET_TO
X                status =
N                    convert_arc_comp1(move, block, settings, end_x, end_y,
N                    end_z
N    #ifdef AA
S                    , AA_end
N    #endif
N
N    #ifdef BB
S                    , BB_end
N    #endif
N
N    #ifdef CC
S                    , CC_end
N    #endif
N                    );
N                CHP(status);
X                if ((status = (status)) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            }
N            else
N            {
N                status SET_TO
X                status =
N                    convert_arc_comp2(move, block, settings, end_x, end_y,
N                    end_z
N    #ifdef AA
S                    , AA_end
N    #endif
N
N    #ifdef BB
S                    , BB_end
N    #endif
N
N    #ifdef CC
S                    , CC_end
N    #endif
N                    );
N
N                CHP(status);
X                if ((status = (status)) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            }
N        }
N        else if (settings->plane IS CANON_PLANE_XZ)
X        else if (settings->plane == 3)
N        {
N            status SET_TO
X            status =
N                convert_arc2 (move, block, settings,
N                &(settings->current_z), &(settings->current_x),
N                &(settings->current_y), end_z, end_x,
N                end_y
N    #ifdef AA
S                , AA_end
N    #endif
N
N    #ifdef BB
S                , BB_end
N    #endif
N
N    #ifdef CC
S                , CC_end
N    #endif
N                , block->k_number,
N                block->i_number);
N            CHP(status);
X            if ((status = (status)) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if (settings->plane IS CANON_PLANE_YZ)
X        else if (settings->plane == 2)
N        {
N            status SET_TO
X            status =
N                convert_arc2 (move, block, settings,
N                &(settings->current_y), &(settings->current_z),
N                &(settings->current_x), end_y, end_z,
N                end_x
N    #ifdef AA
S                , AA_end
N    #endif
N
N    #ifdef BB
S                , BB_end
N    #endif
N
N    #ifdef CC
S                , CC_end
N    #endif
N                , block->j_number,
N                block->k_number);
N            CHP(status);
X            if ((status = (status)) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else
N            ERM(NCE_BUG_PLANE_NOT_XY_YZ_OR_XZ);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 34; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_arc2
N
N   Returned Value: int
N   If arc_data_ijk or arc_data_r returns an error code,
N   this returns that code.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   This executes an arc command at feed rate. It also updates the
N   setting of the position of the tool point to the end point of the move.
N   If inverse time feed rate is in effect, it also resets the feed rate.
N
N   Called by: convert_arc.
N
N   This converts a helical or circular arc.
N
N   */
N
N    static int convert_arc2(                      /* ARGUMENTS                                */
N    int move,                                     /* either G_2 (cw arc) or G_3 (ccw arc)     */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings,                       /* pointer to machine settings              */
N    double * current1,                            /* pointer to current value of coordinate 1 */
N    double * current2,                            /* pointer to current value of coordinate 2 */
N    double * current3,                            /* pointer to current value of coordinate 3 */
N    double end1,                                  /* coordinate 1 value at end of arc         */
N    double end2,                                  /* coordinate 2 value at end of arc         */
N    double end3,                                  /* coordinate 3 value at end of arc         */
N#ifdef AA
S    double AA_end,                                /* a-value at end of arc                    *//*AA*/
N#endif
N#ifdef BB
S    double BB_end,                                /* b-value at end of arc                    *//*BB*/
N#endif
N#ifdef CC
S    double CC_end,                                /* c-value at end of arc                    *//*CC*/
N#endif
N    double offset1,                               /* offset of center from current1           */
N    double offset2)                               /* offset of center from current2           */
N    {
N        static char name[] SET_TO "convert_arc2";
X        static char name[] = "convert_arc2";
N        double center1;
N        double center2;
N        int status;                               /* status returned from CHP function call     */
N        double tolerance;                         /* tolerance for difference of radii          */
N        int turn;                                 /* number of full or partial turns CCW in arc */
N
N        tolerance SET_TO (settings->length_units IS CANON_UNITS_INCHES) ?
X        tolerance = (settings->length_units == 1) ?
N            TOLERANCE_INCH : TOLERANCE_MM;
X            0.0002 : 0.002;
N
N        if (block->r_flag)
N        {
N            CHP(arc_data_r(move, *current1, *current2, end1, end2,
N                block->r_number, &center1, &center2, &turn));
X            if ((status = (arc_data_r(move, *current1, *current2, end1, end2, block->r_number, &center1, &center2, &turn))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else
N        {
N            CHP(arc_data_ijk(move, *current1, *current2, end1, end2, offset1,
N                offset2, &center1, &center2, &turn, tolerance));
X            if ((status = (arc_data_ijk(move, *current1, *current2, end1, end2, offset1, offset2, &center1, &center2, &turn, tolerance))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N
N        if (settings->feed_mode IS INVERSE_TIME)
X        if (settings->feed_mode == 1)
N            inverse_time_rate_arc(*current1, *current2, *current3, center1, center2,
N                turn, end1, end2, end3, block, settings);
N        ARC_FEED(end1, end2, center1, center2, turn,
N            end3
N    #ifdef AA
S            , AA_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef BB
S            , BB_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef CC
S            , CC_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N            );
N        *current1 SET_TO end1;
X        *current1 = end1;
N        *current2 SET_TO end2;
X        *current2 = end2;
N        *current3 SET_TO end3;
X        *current3 = end3;
N#ifdef AA
S        settings->AA_current SET_TO AA_end;       /*AA*/
N#endif
N#ifdef BB
S        settings->BB_current SET_TO BB_end;       /*BB*/
N#endif
N#ifdef CC
S        settings->CC_current SET_TO CC_end;       /*CC*/
N#endif
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_arc_comp1
N
N   Returned Value: int
N   If arc_data_comp_ijk or arc_data_comp_r returns an error code,
N   this returns that code.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   This executes an arc command at
N   feed rate. It also updates the setting of the position of
N   the tool point to the end point of the move.
N
N   Called by: convert_arc.
N
N   This function converts a helical or circular arc, generating only one
N   arc. The axis must be parallel to the z-axis. This is called when
N   cutter radius compensation is on and this is the first cut after the
N   turning on.
N
N   The arc which is generated is derived from a second arc which passes
N   through the programmed end point and is tangent to the cutter at its
N   current location. The generated arc moves the tool so that it stays
N   tangent to the second arc throughout the move.
N
N   */
N
N    static int convert_arc_comp1(                 /* ARGUMENTS                                   */
N    int move,                                     /* either G_2 (cw arc) or G_3 (ccw arc)             */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions     */
N    setup_pointer settings,                       /* pointer to machine settings                      */
N    double end_x,                                 /* x-value at end of programmed (then actual) arc   */
N    double end_y,                                 /* y-value at end of programmed (then actual) arc   */
N    double end_z                                  /* z-value at end of arc                            */
N#ifdef AA
S    , double AA_end                               /* a-value at end of arc                      *//*AA*/
N#endif
N#ifdef BB
S    , double BB_end                               /* b-value at end of arc                      *//*BB*/
N#endif
N#ifdef CC
S    , double CC_end                               /* c-value at end of arc                      *//*CC*/
N#endif
N    )
N    {
N        static char name[] SET_TO "convert_arc_comp1";
X        static char name[] = "convert_arc_comp1";
N        double center_x;
N        double center_y;
N        double gamma;                             /* direction of perpendicular to arc at end */
N        int side;                                 /* offset side - right or left              */
N        int status;                               /* status returned from CHP function call   */
N        double tolerance;                         /* tolerance for difference of radii        */
N        double tool_radius;
N        int turn;                                 /* 1 for counterclockwise, -1 for clockwise */
N
N        side SET_TO settings->cutter_comp_side;
X        side = settings->cutter_comp_side;
N   /* always is positive */
N        tool_radius SET_TO settings->cutter_comp_radius;
X        tool_radius = settings->cutter_comp_radius;
N        tolerance SET_TO (settings->length_units IS CANON_UNITS_INCHES) ?
X        tolerance = (settings->length_units == 1) ?
N            TOLERANCE_INCH : TOLERANCE_MM;
X            0.0002 : 0.002;
N
N        CHK((hypot((end_x - settings->current_x),
N            (end_y - settings->current_y)) <= tool_radius),
N            NCE_CUTTER_GOUGING_WITH_CUTTER_RADIUS_COMP);
X        if ((hypot((end_x - settings->current_x), (end_y - settings->current_y)) <= tool_radius)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 70; } else;
N
N        if (block->r_flag)
N        {
N            CHP(arc_data_comp_r(move, side, tool_radius, settings->current_x,
N                settings->current_y, end_x, end_y, block->r_number,
N                &center_x, &center_y, &turn));
X            if ((status = (arc_data_comp_r(move, side, tool_radius, settings->current_x, settings->current_y, end_x, end_y, block->r_number, &center_x, &center_y, &turn))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else
N        {
N            CHP(arc_data_comp_ijk(move, side, tool_radius, settings->current_x,
N                settings->current_y, end_x, end_y,
N                block->i_number, block->j_number,
N                &center_x, &center_y, &turn, tolerance));
X            if ((status = (arc_data_comp_ijk(move, side, tool_radius, settings->current_x, settings->current_y, end_x, end_y, block->i_number, block->j_number, &center_x, &center_y, &turn, tolerance))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N
N        gamma SET_TO
X        gamma =
N            (((side IS LEFT) AND (move IS G_3)) OR
X            (((side == 2) && (move == 30)) ||
N            ((side IS RIGHT) AND (move IS G_2))) ?
X            ((side == 1) && (move == 20))) ?
N            atan2 ((center_y - end_y), (center_x - end_x)) :
N        atan2 ((end_y - center_y), (end_x - center_x));
N
N        settings->program_x SET_TO end_x;
X        settings->program_x = end_x;
N        settings->program_y SET_TO end_y;
X        settings->program_y = end_y;
N   /* end_x reset actual */
N        end_x SET_TO (end_x + (tool_radius * cos(gamma)));
X        end_x = (end_x + (tool_radius * cos(gamma)));
N   /* end_y reset actual */
N        end_y SET_TO (end_y + (tool_radius * sin(gamma)));
X        end_y = (end_y + (tool_radius * sin(gamma)));
N
N        if (settings->feed_mode IS INVERSE_TIME)
X        if (settings->feed_mode == 1)
N            inverse_time_rate_arc(settings->current_x, settings->current_y,
N                settings->current_z, center_x, center_y, turn,
N                end_x, end_y, end_z, block, settings);
N        ARC_FEED(end_x, end_y, center_x, center_y, turn,
N            end_z
N    #ifdef AA
S            , AA_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef BB
S            , BB_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef CC
S            , CC_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N            );
N        settings->current_x SET_TO end_x;
X        settings->current_x = end_x;
N        settings->current_y SET_TO end_y;
X        settings->current_y = end_y;
N        settings->current_z SET_TO end_z;
X        settings->current_z = end_z;
N#ifdef AA
S        settings->AA_current SET_TO AA_end;       /*AA*/
N#endif
N#ifdef BB
S        settings->BB_current SET_TO BB_end;       /*BB*/
N#endif
N#ifdef CC
S        settings->CC_current SET_TO CC_end;       /*CC*/
N#endif
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_arc_comp2
N
N   Returned Value: int
N   If arc_data_ijk or arc_data_r returns an error code,
N   this returns that code.
N   If any of the following errors occurs, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. A concave corner is found: NCE_CONCAVE_CORNER_WITH_CUTTER_RADIUS_COMP
N   2. The tool will not fit inside an arc:
N   NCE_TOOL_RADIUS_NOT_LESS_THAN_ARC_RADIUS_WITH_COMP
N
N   Side effects:
N   This executes an arc command feed rate. If needed, at also generates
N   an arc to go around a convex corner. It also updates the setting of
N   the position of the tool point to the end point of the move. If
N   inverse time feed rate mode is in effect, the feed rate is reset.
N
N   Called by: convert_arc.
N
N   This function converts a helical or circular arc. The axis must be
N   parallel to the z-axis. This is called when cutter radius compensation
N   is on and this is not the first cut after the turning on.
N
N   If one or more rotary axes is moved in this block and an extra arc is
N   required to go around a sharp corner, all the rotary axis motion
N   occurs on the main arc and none on the extra arc.  An alternative
N   might be to distribute the rotary axis motion over the extra arc and
N   the programmed arc in proportion to their lengths.
N
N   If the Z-axis is moved in this block and an extra arc is required to
N   go around a sharp corner, all the Z-axis motion occurs on the main arc
N   and none on the extra arc.  An alternative might be to distribute the
N   Z-axis motion over the extra arc and the main arc in proportion to
N   their lengths.
N
N   */
N
N    static int convert_arc_comp2(                 /* ARGUMENTS                                 */
N    int move,                                     /* either G_2 (cw arc) or G_3 (ccw arc)           */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions   */
N    setup_pointer settings,                       /* pointer to machine settings                    */
N    double end_x,                                 /* x-value at end of programmed (then actual) arc */
N    double end_y,                                 /* y-value at end of programmed (then actual) arc */
N    double end_z                                  /* z-value at end of arc                          */
N#ifdef AA
S    , double AA_end                               /* a-value at end of arc                    *//*AA*/
N#endif
N#ifdef BB
S    , double BB_end                               /* b-value at end of arc                    *//*BB*/
N#endif
N#ifdef CC
S    , double CC_end                               /* c-value at end of arc                    *//*CC*/
N#endif
N    )
N    {
N        static char name[] SET_TO "convert_arc_comp2";
X        static char name[] = "convert_arc_comp2";
N        double alpha;                             /* direction of tangent to start of arc */
N        double arc_radius;
N        double beta;                              /* angle between two tangents above */
N        double center_x;                          /* center of arc */
N        double center_y;
N        double delta;                             /* direction of radius from start of arc to center of arc */
N        double gamma;                             /* direction of perpendicular to arc at end */
N        double mid_x;
N        double mid_y;
N        int side;
N   /* angle for testing corners */
N        double small SET_TO TOLERANCE_CONCAVE_CORNER;
X        double small = 0.01;
N        double start_x;
N        double start_y;
N        int status;                               /* status returned from CHP function call     */
N        double theta;                             /* direction of tangent to last cut */
N        double tolerance;
N        double tool_radius;
N        int turn;                                 /* number of full or partial circles CCW */
N
N   /* find basic arc data: center_x, center_y, and turn */
N
N        start_x SET_TO settings->program_x;
X        start_x = settings->program_x;
N        start_y SET_TO settings->program_y;
X        start_y = settings->program_y;
N        tolerance SET_TO (settings->length_units IS CANON_UNITS_INCHES) ?
X        tolerance = (settings->length_units == 1) ?
N            TOLERANCE_INCH : TOLERANCE_MM;
X            0.0002 : 0.002;
N
N        if (block->r_flag)
N        {
N            CHP(arc_data_r(move, start_x, start_y, end_x, end_y,
N                block->r_number, &center_x, &center_y, &turn));
X            if ((status = (arc_data_r(move, start_x, start_y, end_x, end_y, block->r_number, &center_x, &center_y, &turn))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else
N        {
N            CHP(arc_data_ijk(move, start_x, start_y, end_x, end_y,
N                block->i_number, block->j_number,
N                &center_x, &center_y, &turn, tolerance));
X            if ((status = (arc_data_ijk(move, start_x, start_y, end_x, end_y, block->i_number, block->j_number, &center_x, &center_y, &turn, tolerance))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N
N   /* compute other data */
N        side SET_TO settings->cutter_comp_side;
X        side = settings->cutter_comp_side;
N   /* always is positive */
N        tool_radius SET_TO settings->cutter_comp_radius;
X        tool_radius = settings->cutter_comp_radius;
N        arc_radius SET_TO hypot((center_x - end_x), (center_y - end_y));
X        arc_radius = hypot((center_x - end_x), (center_y - end_y));
N        theta SET_TO
X        theta =
N            atan2(settings->current_y - start_y, settings->current_x - start_x);
N        theta SET_TO (side IS LEFT) ? (theta - PI2) : (theta + PI2);
X        theta = (side == 2) ? (theta - 1.5707963267948966) : (theta + 1.5707963267948966);
N        delta SET_TO atan2(center_y - start_y, center_x - start_x);
X        delta = atan2(center_y - start_y, center_x - start_x);
N        alpha SET_TO (move IS G_3) ? (delta - PI2) : (delta + PI2);
X        alpha = (move == 30) ? (delta - 1.5707963267948966) : (delta + 1.5707963267948966);
N        beta SET_TO (side IS LEFT) ? (theta - alpha) : (alpha - theta);
X        beta = (side == 2) ? (theta - alpha) : (alpha - theta);
N        beta SET_TO (beta > (1.5 * PI))  ? (beta - TWO_PI) :
X        beta = (beta > (1.5 * 3.1415926535897932))  ? (beta - 6.2831853071795864) :
N        (beta < -PI2) ? (beta + TWO_PI) : beta;
X        (beta < -1.5707963267948966) ? (beta + 6.2831853071795864) : beta;
N
N        if (((side IS LEFT)  AND (move IS G_3)) OR
X        if (((side == 2)  && (move == 30)) ||
N            ((side IS RIGHT) AND (move IS G_2)))
X            ((side == 1) && (move == 20)))
N        {
N            gamma SET_TO atan2 ((center_y - end_y), (center_x - end_x));
X            gamma = atan2 ((center_y - end_y), (center_x - end_x));
N            CHK((arc_radius <= tool_radius),
N                NCE_TOOL_RADIUS_NOT_LESS_THAN_ARC_RADIUS_WITH_COMP);
X            if ((arc_radius <= tool_radius)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 167; } else;
N        }
N        else
N        {
N            gamma SET_TO atan2 ((end_y - center_y), (end_x - center_x));
X            gamma = atan2 ((end_y - center_y), (end_x - center_x));
N            delta SET_TO (delta + PI);
X            delta = (delta + 3.1415926535897932);
N        }
N
N        settings->program_x SET_TO end_x;
X        settings->program_x = end_x;
N        settings->program_y SET_TO end_y;
X        settings->program_y = end_y;
N   /* end_x reset actual */
N        end_x SET_TO (end_x + (tool_radius * cos(gamma)));
X        end_x = (end_x + (tool_radius * cos(gamma)));
N   /* end_y reset actual */
N        end_y SET_TO (end_y + (tool_radius * sin(gamma)));
X        end_y = (end_y + (tool_radius * sin(gamma)));
N
N   /* check if extra arc needed and insert if so */
N
N        CHK(((beta < -small) OR (beta > (PI + small))),
N            NCE_CONCAVE_CORNER_WITH_CUTTER_RADIUS_COMP);
X        if (((beta < -small) || (beta > (3.1415926535897932 + small)))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 67; } else;
N        if (beta > small)                         /* two arcs needed */
N        {
N            mid_x SET_TO (start_x + (tool_radius * cos(delta)));
X            mid_x = (start_x + (tool_radius * cos(delta)));
N            mid_y SET_TO (start_y + (tool_radius * sin(delta)));
X            mid_y = (start_y + (tool_radius * sin(delta)));
N            if (settings->feed_mode IS INVERSE_TIME)
X            if (settings->feed_mode == 1)
N                inverse_time_rate_arc2(start_x, start_y, (side IS LEFT) ? -1 : 1,
X                inverse_time_rate_arc2(start_x, start_y, (side == 2) ? -1 : 1,
N                mid_x, mid_y, center_x, center_y, turn,
N                end_x, end_y, end_z, block, settings);
N            ARC_FEED(mid_x, mid_y, start_x, start_y, ((side IS LEFT) ? -1 : 1),
X            ARC_FEED(mid_x, mid_y, start_x, start_y, ((side == 2) ? -1 : 1),
N                settings->current_z
N    #ifdef AA
S                , AA_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                , BB_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                , CC_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N            ARC_FEED(end_x, end_y, center_x, center_y, turn,
N                end_z
N    #ifdef AA
S                , AA_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                , BB_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                , CC_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N        }
N        else                                      /* one arc needed */
N        {
N            if (settings->feed_mode IS INVERSE_TIME)
X            if (settings->feed_mode == 1)
N                inverse_time_rate_arc(settings->current_x, settings->current_y,
N                    settings->current_z, center_x, center_y, turn,
N                    end_x, end_y, end_z, block, settings);
N            ARC_FEED(end_x, end_y, center_x, center_y, turn,
N                end_z
N    #ifdef AA
S                , AA_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                , BB_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                , CC_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N        }
N
N        settings->current_x SET_TO end_x;
X        settings->current_x = end_x;
N        settings->current_y SET_TO end_y;
X        settings->current_y = end_y;
N        settings->current_z SET_TO end_z;
X        settings->current_z = end_z;
N#ifdef AA
S        settings->AA_current SET_TO AA_end;       /*AA*/
N#endif
N#ifdef BB
S        settings->BB_current SET_TO BB_end;       /*BB*/
N#endif
N#ifdef CC
S        settings->CC_current SET_TO CC_end;       /*CC*/
N#endif
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_axis_offsets
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The function is called when cutter radius compensation is on:
N   NCE_CANNOT_CHANGE_AXIS_OFFSETS_WITH_CUTTER_RADIUS_COMP
N   2. The g_code argument is not G_92, G_92_1, G_92_2, or G_92_3
N   NCE_BUG_CODE_NOT_IN_G92_SERIES
N
N   Side effects:
N   SET_PROGRAM_ORIGIN is called, and the coordinate
N   values for the axis offsets are reset. The coordinates of the
N   current point are reset. Parameters may be set.
N
N   Called by: convert_modal_0.
N
N   The action of G92 is described in [NCMS, pages 10 - 11] and {Fanuc,
N   pages 61 - 63]. [NCMS] is ambiguous about the intent, but [Fanuc]
N   is clear. When G92 is executed, an offset of the origin is calculated
N   so that the coordinates of the current point with respect to the moved
N   origin are as specified on the line containing the G92. If an axis
N   is not mentioned on the line, the coordinates of the current point
N   are not changed. The execution of G92 results in an axis offset being
N   calculated and saved for each of the six axes, and the axis offsets
N   are always used when motion is specified with respect to absolute
N   distance mode using any of the nine coordinate systems (those designated
N   by G54 - G59.3). Thus all nine coordinate systems are affected by G92.
N
N   Being in incremental distance mode has no effect on the action of G92
N   in this implementation. [NCMS] is not explicit about this, but it is
N   implicit in the second sentence of [Fanuc, page 61].
N
N   The offset is the amount the origin must be moved so that the
N   coordinate of the controlled point has the specified value. For
N   example, if the current point is at X=4 in the currently specified
N   coordinate system and the current X-axis offset is zero, then "G92 x7"
N   causes the X-axis offset to be reset to -3.
N
N   Since a non-zero offset may be already be in effect when the G92 is
N   called, that must be taken into account.
N
N   In addition to causing the axis offset values in the _setup model to be
N   set, G92 sets parameters 5211 to 5216 to the x,y,z,a,b,c axis offsets.
N
N   The action of G92.2 is described in [NCMS, page 12]. There is no
N   equivalent command in [Fanuc]. G92.2 resets axis offsets to zero.
N   G92.1, also included in [NCMS, page 12] (but the usage here differs
N   slightly from the spec), is like G92.2, except that it also causes
N   the axis offset parameters to be set to zero, whereas G92.2 does not
N   zero out the parameters.
N
N   G92.3 is not in [NCMS]. It sets the axis offset values to the values
N   given in the parameters.
N
N   */
N
N    static int convert_axis_offsets(              /* ARGUMENTS                               */
N    int g_code,                                   /* g_code being executed (must be in G_92 series) */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions   */
N    setup_pointer settings)                       /* pointer to machine settings                    */
N    {
N        static char name[] SET_TO "convert_axis_offsets";
X        static char name[] = "convert_axis_offsets";
N        double * pars;                            /* short name for settings->parameters            */
N
N        CHK((settings->cutter_comp_side ISNT OFF),/* not "IS ON" */
N            NCE_CANNOT_CHANGE_AXIS_OFFSETS_WITH_CUTTER_RADIUS_COMP);
X        if ((settings->cutter_comp_side != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 38; } else;
N        pars SET_TO settings->parameters;
X        pars = settings->parameters;
N        if (g_code IS G_92)
X        if (g_code == 920)
N        {
N            if (block->x_flag IS ON)
X            if (block->x_flag == 1)
N            {
N                settings->axis_offset_x SET_TO
X                settings->axis_offset_x =
N                    (settings->current_x + settings->axis_offset_x - block->x_number);
N                settings->current_x SET_TO block->x_number;
X                settings->current_x = block->x_number;
N            }
N
N            if (block->y_flag IS ON)
X            if (block->y_flag == 1)
N            {
N                settings->axis_offset_y SET_TO
X                settings->axis_offset_y =
N                    (settings->current_y + settings->axis_offset_y - block->y_number);
N                settings->current_y SET_TO block->y_number;
X                settings->current_y = block->y_number;
N            }
N
N            if (block->z_flag IS ON)
X            if (block->z_flag == 1)
N            {
N                settings->axis_offset_z SET_TO
X                settings->axis_offset_z =
N                    (settings->current_z + settings->axis_offset_z - block->z_number);
N                settings->current_z SET_TO block->z_number;
X                settings->current_z = block->z_number;
N            }
N
N#ifdef AA
S            if (block->a_flag IS ON)              /*AA*/
N#endif
N#ifdef AA
S            {                                     /*AA*/
S                settings->AA_axis_offset SET_TO (settings->AA_current +
N    #endif
N    #ifdef AA
S   /*AA*/
S                    settings->AA_axis_offset - block->a_number);
N#endif
N#ifdef AA
S   /*AA*/
S                settings->AA_current SET_TO block->a_number;
S            }
N#endif
N
N#ifdef BB
S            if (block->b_flag IS ON)              /*BB*/
N#endif
N#ifdef BB
S            {                                     /*BB*/
S                settings->BB_axis_offset SET_TO (settings->BB_current +
N    #endif
N    #ifdef BB
S   /*BB*/
S                    settings->BB_axis_offset - block->b_number);
N#endif
N#ifdef BB
S   /*BB*/
S                settings->BB_current SET_TO block->b_number;
S            }
N#endif
N
N#ifdef CC
S            if (block->c_flag IS ON)              /*CC*/
N#endif
N#ifdef CC
S            {                                     /*CC*/
S                settings->CC_axis_offset SET_TO (settings->CC_current +
N    #endif
N    #ifdef CC
S   /*CC*/
S                    settings->CC_axis_offset - block->c_number);
N#endif
N#ifdef CC
S   /*CC*/
S                settings->CC_current SET_TO block->c_number;
S            }
N#endif
N
N            SET_ORIGIN_OFFSETS(settings->origin_offset_x + settings->axis_offset_x,
N                settings->origin_offset_y + settings->axis_offset_y,
N                settings->origin_offset_z + settings->axis_offset_z
N    #ifdef AA
S                ,                      (settings->AA_origin_offset + settings->AA_axis_offset)
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,                      (settings->BB_origin_offset + settings->BB_axis_offset)
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,                      (settings->CC_origin_offset + settings->CC_axis_offset)
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N            pars[5211] SET_TO settings->axis_offset_x;
X            pars[5211] = settings->axis_offset_x;
N            pars[5212] SET_TO settings->axis_offset_y;
X            pars[5212] = settings->axis_offset_y;
N            pars[5213] SET_TO settings->axis_offset_z;
X            pars[5213] = settings->axis_offset_z;
N#ifdef AA
S   /*AA*/
S            pars[5214] SET_TO settings->AA_axis_offset;
N#endif
N#ifdef BB
S   /*BB*/
S            pars[5215] SET_TO settings->BB_axis_offset;
N#endif
N#ifdef CC
S   /*CC*/
S            pars[5216] SET_TO settings->CC_axis_offset;
N#endif
N
N        }
N        else if ((g_code IS G_92_1) OR (g_code IS G_92_2))
X        else if ((g_code == 921) || (g_code == 922))
N        {
N            settings->current_x SET_TO
X            settings->current_x =
N                settings->current_x + settings->axis_offset_x;
N            settings->current_y SET_TO
X            settings->current_y =
N                settings->current_y + settings->axis_offset_y;
N            settings->current_z SET_TO
X            settings->current_z =
N                settings->current_z + settings->axis_offset_z;
N#ifdef AA
S            settings->AA_current SET_TO           /*AA*/
N    #endif
N    #ifdef AA
S   /*AA*/
S                (settings->AA_current + settings->AA_axis_offset);
N#endif
N#ifdef BB
S            settings->BB_current SET_TO           /*BB*/
N    #endif
N    #ifdef BB
S   /*BB*/
S                (settings->BB_current + settings->BB_axis_offset);
N#endif
N#ifdef CC
S            settings->CC_current SET_TO           /*CC*/
N    #endif
N    #ifdef CC
S   /*CC*/
S                (settings->CC_current + settings->CC_axis_offset);
N#endif
N            SET_ORIGIN_OFFSETS(settings->origin_offset_x,
N                settings->origin_offset_y,
N                settings->origin_offset_z
N    #ifdef AA
S                ,            settings->AA_origin_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,            settings->BB_origin_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,            settings->CC_origin_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N            settings->axis_offset_x SET_TO 0.0;
X            settings->axis_offset_x = 0.0;
N            settings->axis_offset_y SET_TO 0.0;
X            settings->axis_offset_y = 0.0;
N            settings->axis_offset_z SET_TO 0.0;
X            settings->axis_offset_z = 0.0;
N#ifdef AA
S            settings->AA_axis_offset SET_TO 0.0;  /*AA*/
N#endif
N#ifdef BB
S            settings->BB_axis_offset SET_TO 0.0;  /*BB*/
N#endif
N#ifdef CC
S            settings->CC_axis_offset SET_TO 0.0;  /*CC*/
N#endif
N            if (g_code IS G_92_1)
X            if (g_code == 921)
N            {
N                pars[5211] SET_TO 0.0;
X                pars[5211] = 0.0;
N                pars[5212] SET_TO 0.0;
X                pars[5212] = 0.0;
N                pars[5213] SET_TO 0.0;
X                pars[5213] = 0.0;
N#ifdef AA
S                pars[5214] SET_TO 0.0;            /*AA*/
N#endif
N#ifdef BB
S                pars[5215] SET_TO 0.0;            /*BB*/
N#endif
N#ifdef CC
S                pars[5216] SET_TO 0.0;            /*CC*/
N#endif
N            }
N        }
N        else if (g_code IS G_92_3)
X        else if (g_code == 923)
N        {
N            settings->current_x SET_TO
X            settings->current_x =
N                settings->current_x + settings->axis_offset_x - pars[5211];
N            settings->current_y SET_TO
X            settings->current_y =
N                settings->current_y + settings->axis_offset_y - pars[5212];
N            settings->current_z SET_TO
X            settings->current_z =
N                settings->current_z + settings->axis_offset_z - pars[5213];
N#ifdef AA
S            settings->AA_current SET_TO           /*AA*/
N    #endif
N    #ifdef AA
S   /*AA*/
S                settings->AA_current + settings->AA_axis_offset - pars[5214];
N#endif
N#ifdef BB
S            settings->BB_current SET_TO           /*BB*/
N    #endif
N    #ifdef BB
S   /*BB*/
S                settings->BB_current + settings->BB_axis_offset - pars[5215];
N#endif
N#ifdef CC
S            settings->CC_current SET_TO           /*CC*/
N    #endif
N    #ifdef CC
S   /*CC*/
S                settings->CC_current + settings->CC_axis_offset - pars[5216];
N#endif
N            settings->axis_offset_x SET_TO pars[5211];
X            settings->axis_offset_x = pars[5211];
N            settings->axis_offset_y SET_TO pars[5212];
X            settings->axis_offset_y = pars[5212];
N            settings->axis_offset_z SET_TO pars[5213];
X            settings->axis_offset_z = pars[5213];
N#ifdef AA
S   /*AA*/
S            settings->AA_axis_offset SET_TO pars[5214];
N#endif
N#ifdef BB
S   /*BB*/
S            settings->BB_axis_offset SET_TO pars[5215];
N#endif
N#ifdef CC
S   /*CC*/
S            settings->CC_axis_offset SET_TO pars[5216];
N#endif
N            SET_ORIGIN_OFFSETS(settings->origin_offset_x + settings->axis_offset_x,
N                settings->origin_offset_y + settings->axis_offset_y,
N                settings->origin_offset_z + settings->axis_offset_z
N    #ifdef AA
S                ,                      (settings->AA_origin_offset + settings->AA_axis_offset)
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,                      (settings->BB_origin_offset + settings->BB_axis_offset)
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,                      (settings->CC_origin_offset + settings->CC_axis_offset)
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_IN_G92_SERIES);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 28; } else;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_comment
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The message function is called if the string starts with "MSG,".
N   Otherwise, the comment function is called.
N
N   Called by: execute_block
N
N   To be a message, the first four characters of the comment after the
N   opening left parenthesis must be "MSG,", ignoring the case of the
N   letters and allowing spaces or tabs anywhere before the comma (to make
N   the treatment of case and white space consistent with how it is
N   handled elsewhere).
N
N   Messages are not provided for in [NCMS]. They are implemented here as a
N   subtype of comment. This is an extension to the rs274NGC language.
N
N   */
N
N    static int convert_comment(                   /*ARGUMENTS            */
N    char * comment)                               /* string with comment */
N    {
N        int m;
N        int item;
N
N        for (m SET_TO 0; ((item SET_TO comment[m]) IS ' ') OR (item IS '\t') ; m++);
X        for (m = 0; ((item = comment[m]) == ' ') || (item == '\t') ; m++);
N        if ((item ISNT 'M') AND (item ISNT 'm'))
X        if ((item != 'M') && (item != 'm'))
N        {
N            COMMENT(comment);
N            return RS274NGC_OK;
X            return 0;
N        }
N        for (m++; ((item SET_TO comment[m]) IS ' ') OR (item IS '\t') ; m++);
X        for (m++; ((item = comment[m]) == ' ') || (item == '\t') ; m++);
N        if ((item ISNT 'S') AND (item ISNT 's'))
X        if ((item != 'S') && (item != 's'))
N        {
N            COMMENT(comment);
N            return RS274NGC_OK;
X            return 0;
N        }
N        for (m++; ((item SET_TO comment[m]) IS ' ') OR (item IS '\t') ; m++);
X        for (m++; ((item = comment[m]) == ' ') || (item == '\t') ; m++);
N        if ((item ISNT 'G') AND (item ISNT 'g'))
X        if ((item != 'G') && (item != 'g'))
N        {
N            COMMENT(comment);
N            return RS274NGC_OK;
X            return 0;
N        }
N        for (m++; ((item SET_TO comment[m]) IS ' ') OR (item IS '\t') ; m++);
X        for (m++; ((item = comment[m]) == ' ') || (item == '\t') ; m++);
N        if (item ISNT ',')
X        if (item != ',')
N        {
N            COMMENT(comment);
N            return RS274NGC_OK;
X            return 0;
N        }
N        MESSAGE(comment + m + 1);
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_control_mode
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. g_code isn't G_61, G_61_1 or G_64: NCE_BUG_CODE_NOT_G61_G61_1_OR_G64
N
N   Side effects: See below
N
N   Called by: convert_g.
N
N   The interpreter switches the machine settings to indicate the
N   control mode (CANON_EXACT_STOP, CANON_EXACT_PATH or CANON_CONTINUOUS).
N
N   A call is made to SET_MOTION_CONTROL_MODE(CANON_XXX), where CANON_XXX is
N   CANON_EXACT_PATH if g_code is G_61, CANON_EXACT_STOP if g_code is G_61_1,
N   and CANON_CONTINUOUS if g_code is G_64.
N
N   Setting the control mode to CANON_EXACT_STOP on G_61 would correspond
N   more closely to the meaning of G_61 as given in [NCMS, page 40], but
N   CANON_EXACT_PATH has the advantage that the tool does not stop if it
N   does not have to, and no evident disadvantage compared to
N   CANON_EXACT_STOP, so it is being used for G_61. G_61_1 is not defined
N   in [NCMS], so it is available and is used here for setting the control
N   mode to CANON_EXACT_STOP.
N
N   It is OK to call SET_MOTION_CONTROL_MODE(CANON_XXX) when CANON_XXX is
N   already in force.
N
N   */
N
N    static int convert_control_mode(              /* ARGUMENTS                             */
N    int g_code,                                   /* g_code being executed (G_61, G61_1, OR G_64) */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_control_mode";
X        static char name[] = "convert_control_mode";
N        if (g_code IS G_61)
X        if (g_code == 610)
N        {
N            SET_MOTION_CONTROL_MODE(CANON_EXACT_PATH);
X            SET_MOTION_CONTROL_MODE(2);
N            settings->control_mode SET_TO CANON_EXACT_PATH;
X            settings->control_mode = 2;
N        }
N        else if (g_code IS G_61_1)
X        else if (g_code == 611)
N        {
N            SET_MOTION_CONTROL_MODE(CANON_EXACT_STOP);
X            SET_MOTION_CONTROL_MODE(1);
N            settings->control_mode SET_TO CANON_EXACT_STOP;
X            settings->control_mode = 1;
N        }
N        else if (g_code IS G_64)
X        else if (g_code == 640)
N        {
N            SET_MOTION_CONTROL_MODE(CANON_CONTINUOUS);
X            SET_MOTION_CONTROL_MODE(3);
N            settings->control_mode SET_TO CANON_CONTINUOUS;
X            settings->control_mode = 3;
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G61_G61_1_OR_G64);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 24; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_coordinate_system
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The value of the g_code argument is not 540, 550, 560, 570, 580, 590
N   591, 592, or 593:
N   NCE_BUG_CODE_NOT_IN_RANGE_G54_TO_G593
N
N   Side effects:
N   If the coordinate system selected by the g_code is not already in
N   use, the canonical program coordinate system axis offset values are
N   reset and the coordinate values of the current point are reset.
N
N   Called by: convert_g.
N
N   COORDINATE SYSTEMS (involves g10, g53, g54 - g59.3, g92)
N
N   The canonical machining functions view of coordinate systems is:
N   1. There are two coordinate systems: absolute and program.
N   2. All coordinate values are given in terms of the program coordinate system.
N   3. The offsets of the program coordinate system may be reset.
N
N   The RS274/NGC view of coordinate systems, as given in section 3.2
N   of [NCMS] is:
N   1. there are ten coordinate systems: absolute and 9 program. The
N   program coordinate systems are numbered 1 to 9.
N   2. you can switch among the 9 but not to the absolute one. G54
N   selects coordinate system 1, G55 selects 2, and so on through
N   G56, G57, G58, G59, G59.1, G59.2, and G59.3.
N   3. you can set the offsets of the 9 program coordinate systems
N   using G10 L2 Pn (n is the number of the coordinate system) with
N   values for the axes in terms of the absolute coordinate system.
N   4. the first one of the 9 program coordinate systems is the default.
N   5. data for coordinate systems is stored in parameters [NCMS, pages 59 - 60].
N   6. g53 means to interpret coordinate values in terms of the absolute
N   coordinate system for the one block in which g53 appears.
N   7. You can offset the current coordinate system using g92. This offset
N   will then apply to all nine program coordinate systems.
N
N   The approach used in the interpreter mates the canonical and NGC views
N   of coordinate systems as follows:
N
N   During initialization, data from the parameters for the first NGC
N   coordinate system is used in a SET_ORIGIN_OFFSETS function call and
N   origin_index in the machine model is set to 1.
N
N   If a g_code in the range g54 - g59.3 is encountered in an NC program,
N   the data from the appropriate NGC coordinate system is copied into the
N   origin offsets used by the interpreter, a SET_ORIGIN_OFFSETS function
N   call is made, and the current position is reset.
N
N   If a g10 is encountered, the convert_setup function is called to reset
N   the offsets of the program coordinate system indicated by the P number
N   given in the same block.
N
N   If a g53 is encountered, the axis values given in that block are used
N   to calculate what the coordinates are of that point in the current
N   coordinate system, and a STRAIGHT_TRAVERSE or STRAIGHT_FEED function
N   call to that point using the calculated values is made. No offset
N   values are changed.
N
N   If a g92 is encountered, that is handled by the convert_axis_offsets
N   function. A g92 results in an axis offset for each axis being calculated
N   and stored in the machine model. The axis offsets are applied to all
N   nine coordinate systems. Axis offsets are initialized to zero.
N
N   */
N
N    static int convert_coordinate_system(         /* ARGUMENTS                         */
N    int g_code,                                   /* g_code called (must be one listed above)      */
N    setup_pointer settings)                       /* pointer to machine settings                   */
N    {
N        static char name[] SET_TO "convert_coordinate_system";
X        static char name[] = "convert_coordinate_system";
N        int origin;
N        double x;
N        double y;
N        double z;
N#ifdef AA
S        double a;                                 /*AA*/
N#endif
N#ifdef BB
S        double b;                                 /*BB*/
N#endif
N#ifdef CC
S        double c;                                 /*CC*/
N#endif
N        double * parameters;
N
N        parameters SET_TO settings->parameters;
X        parameters = settings->parameters;
N        switch(g_code)
N        {
N            case 540:
N                origin SET_TO 1;
X                origin = 1;
N                break;
N            case 550:
N                origin SET_TO 2;
X                origin = 2;
N                break;
N            case 560:
N                origin SET_TO 3;
X                origin = 3;
N                break;
N            case 570:
N                origin SET_TO 4;
X                origin = 4;
N                break;
N            case 580:
N                origin SET_TO 5;
X                origin = 5;
N                break;
N            case 590:
N                origin SET_TO 6;
X                origin = 6;
N                break;
N            case 591:
N                origin SET_TO 7;
X                origin = 7;
N                break;
N            case 592:
N                origin SET_TO 8;
X                origin = 8;
N                break;
N            case 593:
N                origin SET_TO 9;
X                origin = 9;
N                break;
N            default:
N                ERM(NCE_BUG_CODE_NOT_IN_RANGE_G54_TO_G593);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 29; } else;
N        }
N
N        if (origin IS settings->origin_index)     /* already using this origin */
X        if (origin == settings->origin_index)      
N        {
N#ifdef DEBUG_EMC
N            COMMENT("interpreter: continuing to use same coordinate system");
N#endif
N            return RS274NGC_OK;
X            return 0;
N        }
N
N        settings->origin_index SET_TO origin;
X        settings->origin_index = origin;
N        parameters[5220] SET_TO (double)origin;
X        parameters[5220] = (double)origin;
N
N   /* axis offsets could be included in the two set of calculations for
N      current_x, current_y, etc., but do not need to be because the results
N      would be the same. They would be added in then subtracted out. */
N        settings->current_x SET_TO
X        settings->current_x =
N            (settings->current_x + settings->origin_offset_x);
N        settings->current_y SET_TO
X        settings->current_y =
N            (settings->current_y + settings->origin_offset_y);
N        settings->current_z SET_TO
X        settings->current_z =
N            (settings->current_z + settings->origin_offset_z);
N#ifdef AA
S        settings->AA_current SET_TO               /*AA*/
N    #endif
N    #ifdef AA
S   /*AA*/
S            (settings->AA_current + settings->AA_origin_offset);
N#endif
N#ifdef BB
S        settings->BB_current SET_TO               /*BB*/
N    #endif
N    #ifdef BB
S   /*BB*/
S            (settings->BB_current + settings->BB_origin_offset);
N#endif
N#ifdef CC
S        settings->CC_current SET_TO               /*CC*/
N    #endif
N    #ifdef CC
S   /*CC*/
S            (settings->CC_current + settings->CC_origin_offset);
N#endif
N
N        x SET_TO parameters[5201 + (origin * 20)];
X        x = parameters[5201 + (origin * 20)];
N        y SET_TO parameters[5202 + (origin * 20)];
X        y = parameters[5202 + (origin * 20)];
N        z SET_TO parameters[5203 + (origin * 20)];
X        z = parameters[5203 + (origin * 20)];
N#ifdef AA
S        a SET_TO parameters[5204 + (origin * 20)];/*AA*/
N#endif
N#ifdef BB
S        b SET_TO parameters[5205 + (origin * 20)];/*BB*/
N#endif
N#ifdef CC
S        c SET_TO parameters[5206 + (origin * 20)];/*CC*/
N#endif
N
N        settings->origin_offset_x SET_TO x;
X        settings->origin_offset_x = x;
N        settings->origin_offset_y SET_TO y;
X        settings->origin_offset_y = y;
N        settings->origin_offset_z SET_TO z;
X        settings->origin_offset_z = z;
N#ifdef AA
S        settings->AA_origin_offset SET_TO a;      /*AA*/
N#endif
N#ifdef BB
S        settings->BB_origin_offset SET_TO b;      /*BB*/
N#endif
N#ifdef CC
S        settings->CC_origin_offset SET_TO c;      /*CC*/
N#endif
N
N        settings->current_x SET_TO (settings->current_x - x);
X        settings->current_x = (settings->current_x - x);
N        settings->current_y SET_TO (settings->current_y - y);
X        settings->current_y = (settings->current_y - y);
N        settings->current_z SET_TO (settings->current_z - z);
X        settings->current_z = (settings->current_z - z);
N#ifdef AA
S   /*AA*/
S        settings->AA_current SET_TO (settings->AA_current - a);
N#endif
N#ifdef BB
S   /*BB*/
S        settings->BB_current SET_TO (settings->BB_current - b);
N#endif
N#ifdef CC
S   /*CC*/
S        settings->CC_current SET_TO (settings->CC_current - c);
N#endif
N
N        SET_ORIGIN_OFFSETS(x + settings->axis_offset_x,
N            y + settings->axis_offset_y,
N            z + settings->axis_offset_z
N    #ifdef AA
S            ,            a + settings->AA_axis_offset
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef BB
S            ,            b + settings->BB_axis_offset
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef CC
S            ,            c + settings->CC_axis_offset
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N            );
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cutter_compensation
N
N   Returned Value: int
N   If convert_cutter_compensation_on or convert_cutter_compensation_off
N   is called and returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. g_code is not G_40, G_41, or G_42:
N   NCE_BUG_CODE_NOT_G40_G41_OR_G42
N
N   Side effects:
N   The value of cutter_comp_side in the machine model mode is
N   set to RIGHT, LEFT, or OFF. The currently active tool table index in
N   the machine model (which is the index of the slot whose diameter
N   value is used in cutter radius compensation) is updated.
N
N   Since cutter radius compensation is performed in the interpreter, no
N   call is made to any canonical function regarding cutter radius compensation.
N
N   Called by: convert_g
N
N   */
N
N    static int convert_cutter_compensation(       /* ARGUMENTS                  */
N    int g_code,                                   /* must be G_40, G_41, or G_42              */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        static char name[] SET_TO "convert_cutter_compensation";
X        static char name[] = "convert_cutter_compensation";
N        int status;
N
N        if (g_code IS G_40)
X        if (g_code == 400)
N        {
N            CHP(convert_cutter_compensation_off(settings));
X            if ((status = (convert_cutter_compensation_off(settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if (g_code IS G_41)
X        else if (g_code == 410)
N        {
N            CHP(convert_cutter_compensation_on(LEFT, block, settings));
X            if ((status = (convert_cutter_compensation_on(2, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if (g_code IS G_42)
X        else if (g_code == 420)
N        {
N            CHP(convert_cutter_compensation_on(RIGHT, block, settings));
X            if ((status = (convert_cutter_compensation_on(1, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G40_G41_OR_G42);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 21; } else;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cutter_compensation_off
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   A comment is made that cutter radius compensation is turned off.
N   The machine model of the cutter radius compensation mode is set to OFF.
N   The value of program_x in the machine model is set to UNKNOWN.
N   This serves as a flag when cutter radius compensation is
N   turned on again.
N
N   Called by: convert_cutter_compensation
N
N   */
N
N    static int convert_cutter_compensation_off(   /* ARGUMENTS                   */
N    setup_pointer settings)                       /* pointer to machine settings */
N    {
N#ifdef DEBUG_EMC
N        COMMENT("interpreter: cutter radius compensation off");
N#endif
N        settings->cutter_comp_side SET_TO OFF;
X        settings->cutter_comp_side = 0;
N        settings->program_x SET_TO UNKNOWN;
X        settings->program_x = 1e-20;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cutter_compensation_on
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The selected plane is not the XY plane:
N   NCE_CANNOT_TURN_CUTTER_RADIUS_COMP_ON_OUT_OF_XY_PLANE
N   2. Cutter radius compensation is already on:
N   NCE_CANNOT_TURN_CUTTER_RADIUS_COMP_ON_WHEN_ON
N
N   Side effects:
N   A COMMENT function call is made (conditionally) saying that the
N   interpreter is switching mode so that cutter radius compensation is on.
N   The value of cutter_comp_radius in the machine model mode is
N   set to the absolute value of the radius given in the tool table.
N   The value of cutter_comp_side in the machine model mode is
N   set to RIGHT or LEFT. The currently active tool table index in
N   the machine model is updated.
N
N   Called by: convert_cutter_compensation
N
N   check_other_codes checks that a d word occurs only in a block with g41
N   or g42.
N
N   Cutter radius compensation is carried out in the interpreter, so no
N   call is made to a canonical function (although there is a canonical
N   function, START_CUTTER_RADIUS_COMPENSATION, that could be called if
N   the primitive level could execute it).
N
N   This version uses a D word if there is one in the block, but it does
N   not require a D word, since the sample programs which the interpreter
N   is supposed to handle do not have them.  Logically, the D word is
N   optional, since the D word is always (except in cases we have never
N   heard of) the slot number of the tool in the spindle. Not requiring a
N   D word is contrary to [Fanuc, page 116] and [NCMS, page 79], however.
N   Both manuals require the use of the D-word with G41 and G42.
N
N   This version handles a negative offset radius, which may be
N   encountered if the programmed tool path is a center line path for
N   cutting a profile and the path was constructed using a nominal tool
N   diameter. Then the value in the tool table for the diameter is set to
N   be the difference between the actual diameter and the nominal
N   diameter. If the actual diameter is less than the nominal, the value
N   in the table is negative. The method of handling a negative radius is
N   to switch the side of the offset and use a positive radius. This
N   requires that the profile use arcs (not straight lines) to go around
N   convex corners.
N
N   */
N
N    static int convert_cutter_compensation_on(    /* ARGUMENTS               */
N    int side,                                     /* side of path cutter is on (LEFT or RIGHT) */
N    block_pointer block,                          /* pointer to a block of RS274 instructions  */
N    setup_pointer settings)                       /* pointer to machine settings               */
N    {
N        static char name[] SET_TO "convert_cutter_compensation_on";
X        static char name[] = "convert_cutter_compensation_on";
N        double radius;
N        int index;
N
N        CHK((settings->plane ISNT CANON_PLANE_XY),
N            NCE_CANNOT_TURN_CUTTER_RADIUS_COMP_ON_OUT_OF_XY_PLANE);
X        if ((settings->plane != 1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 53; } else;
N        CHK((settings->cutter_comp_side ISNT OFF),
N            NCE_CANNOT_TURN_CUTTER_RADIUS_COMP_ON_WHEN_ON);
X        if ((settings->cutter_comp_side != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 54; } else;
N        index SET_TO
X        index =
N            (block->d_number ISNT -1) ? block->d_number : settings->current_slot;
X            (block->d_number != -1) ? block->d_number : settings->current_slot;
N        radius SET_TO ((settings->tool_table[index].diameter)/2.0);
X        radius = ((settings->tool_table[index].diameter)/2.0);
N
N        if (radius < 0.0)                         /* switch side & make radius positive if radius negative */
N        {
N            radius SET_TO -radius;
X            radius = -radius;
N            if (side IS RIGHT)
X            if (side == 1)
N                side SET_TO LEFT;
X                side = 2;
N            else
N                side SET_TO RIGHT;
X                side = 1;
N        }
N
N#ifdef DEBUG_EMC
N        if (side IS RIGHT)
X        if (side == 1)
N            COMMENT("interpreter: cutter radius compensation on right");
N        else
N            COMMENT("interpreter: cutter radius compensation on left");
N#endif
N
N        settings->cutter_comp_radius SET_TO radius;
X        settings->cutter_comp_radius = radius;
N        settings->tool_table_index SET_TO index;
X        settings->tool_table_index = index;
N        settings->cutter_comp_side SET_TO side;
X        settings->cutter_comp_side = side;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle
N
N   Returned Value: int
N   If any of the specific functions called returns an error code,
N   this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The r-value is not given the first time this code is called after
N   some other motion mode has been in effect:
N   NCE_R_CLEARANCE_PLANE_UNSPECIFIED_IN_CYCLE
N   2. The l number is zero: NCE_CANNOT_DO_ZERO_REPEATS_OF_CYCLE
N   3. The currently selected plane in not XY, YZ, or XZ.
N   NCE_BUG_PLANE_NOT_XY_YZ_OR_XZ
N
N   Side effects:
N   A number of moves are made to execute a canned cycle. The current
N   position is reset. The values of the cycle attributes in the settings
N   may be reset.
N
N   Called by: convert_motion
N
N   This function makes a couple checks and then calls one of three
N   functions, according to which plane is currently selected.
N
N   See the documentation of convert_cycle_xy for most of the details.
N
N   */
N
N    static int convert_cycle(                     /* ARGUMENTS                                      */
N    int motion,                                   /* a g-code between G_81 and G_89, a canned cycle */
N    block_pointer block,                          /* pointer to a block of RS274 instructions       */
N    setup_pointer settings)                       /* pointer to machine settings                    */
N    {
N        static char name[] SET_TO "convert_cycle";
X        static char name[] = "convert_cycle";
N        CANON_PLANE plane;
N        int status;
N
N        plane SET_TO settings->plane;
X        plane = settings->plane;
N        if (block->r_flag IS OFF)
X        if (block->r_flag == 0)
N        {
N            if (settings->motion_mode IS motion)
X            if (settings->motion_mode == motion)
N                block->r_number SET_TO settings->cycle_r;
X                block->r_number = settings->cycle_r;
N            else
N                ERM(NCE_R_CLEARANCE_PLANE_UNSPECIFIED_IN_CYCLE);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 146; } else;
N        }
N
N        CHK((block->l_number IS 0), NCE_CANNOT_DO_ZERO_REPEATS_OF_CYCLE);
X        if ((block->l_number == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 42; } else;
N        if (block->l_number IS -1)
X        if (block->l_number == -1)
N            block->l_number SET_TO 1;
X            block->l_number = 1;
N
N        if (plane IS CANON_PLANE_XY)
X        if (plane == 1)
N        {
N            CHP(convert_cycle_xy(motion, block, settings));
X            if ((status = (convert_cycle_xy(motion, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if (plane IS CANON_PLANE_YZ)
X        else if (plane == 2)
N        {
N            CHP(convert_cycle_yz(motion, block, settings));
X            if ((status = (convert_cycle_yz(motion, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if (plane IS CANON_PLANE_XZ)
X        else if (plane == 3)
N        {
N            CHP(convert_cycle_zx(motion, block, settings));
X            if ((status = (convert_cycle_zx(motion, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else
N            ERM(NCE_BUG_PLANE_NOT_XY_YZ_OR_XZ);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 34; } else;
N
N        settings->cycle_l SET_TO block->l_number;
X        settings->cycle_l = block->l_number;
N        settings->cycle_r SET_TO block->r_number;
X        settings->cycle_r = block->r_number;
N        settings->motion_mode SET_TO motion;
X        settings->motion_mode = motion;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g81
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects: See below
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   For the XY plane, this implements the following RS274/NGC cycle, which
N   is usually drilling:
N   1. Move the z-axis only at the current feed rate to the specified bottom_z.
N   2. Retract the z-axis at traverse rate to clear_z.
N
N   See [NCMS, page 99].
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, a, b, c) when this starts.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N    static int convert_cycle_g81(                 /* ARGUMENTS                        */
N    CANON_PLANE plane,                            /* selected plane                   */
N    double x,                                     /* x-value where cycle is executed  */
N    double y,                                     /* y-value where cycle is executed  */
N    double clear_z,                               /* z-value of clearance plane       */
N    double bottom_z)                              /* value of z at bottom of cycle    */
N    {
N        static char name[] SET_TO "convert_cycle_g81";
X        static char name[] = "convert_cycle_g81";
N
N        cycle_feed(plane, x, y, bottom_z);
N        cycle_traverse(plane, x, y, clear_z);
N
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 3474 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g82
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects: See below
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   For the XY plane, this implements the following RS274/NGC cycle, which
N   is usually drilling:
N   1. Move the z_axis only at the current feed rate to the specified z-value.
N   2. Dwell for the given number of seconds.
N   3. Retract the z-axis at traverse rate to the clear_z.
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, a, b, c) when this starts.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N    static int convert_cycle_g82(                 /* ARGUMENTS                        */
N    CANON_PLANE plane,                            /* selected plane                   */
N    double x,                                     /* x-value where cycle is executed  */
N    double y,                                     /* y-value where cycle is executed  */
N    double clear_z,                               /* z-value of clearance plane       */
N    double bottom_z,                              /* value of z at bottom of cycle    */
N    double dwell)                                 /* dwell time                       */
N    {
N        static char name[] SET_TO "convert_cycle_g82";
X        static char name[] = "convert_cycle_g82";
N
N        cycle_feed(plane, x, y, bottom_z);
N        DWELL(dwell);
N        cycle_traverse(plane, x, y, clear_z);
N
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 3515 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g83
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects: See below
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   For the XY plane, this implements the following RS274/NGC cycle,
N   which is usually peck drilling:
N   1. Move the z-axis only at the current feed rate downward by delta or
N   to the specified bottom_z, whichever is less deep.
N   2. Rapid back out to the clear_z.
N   3. Rapid back down to the current hole bottom, backed off a bit.
N   4. Repeat steps 1, 2, and 3 until the specified bottom_z is reached.
N   5. Retract the z-axis at traverse rate to clear_z.
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, a, b, c) when this starts.
N
N   The rapid out and back in causes any long stringers (which are common
N   when drilling in aluminum) to be cut off and clears chips from the
N   hole.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N#define G83_RAPID_DELTA 0.010
N   /* how far above hole bottom for rapid
N                      return, in inches */
N
N    static int convert_cycle_g83(                 /* ARGUMENTS                        */
N    CANON_PLANE plane,                            /* selected plane                   */
N    double x,                                     /* x-value where cycle is executed  */
N    double y,                                     /* y-value where cycle is executed  */
N    double r,                                     /* initial z-value                  */
N    double clear_z,                               /* z-value of clearance plane       */
N    double bottom_z,                              /* value of z at bottom of cycle    */
N    double delta)                                 /* size of z-axis feed increment    */
N    {
N        static char name[] SET_TO "convert_cycle_g83";
X        static char name[] = "convert_cycle_g83";
N        double current_depth;
N        double rapid_delta;
N
N        rapid_delta SET_TO G83_RAPID_DELTA;
X        rapid_delta = 0.010;
N        if (_setup.length_units IS CANON_UNITS_MM)
X        if (_setup.length_units == 2)
N            rapid_delta SET_TO (rapid_delta * 25.4);
X            rapid_delta = (rapid_delta * 25.4);
N
N        for (current_depth SET_TO (r - delta);
X        for (current_depth = (r - delta);
N            current_depth > bottom_z;
N            current_depth SET_TO (current_depth - delta))
X            current_depth = (current_depth - delta))
N        {
N            cycle_feed(plane, x, y, current_depth);
N            cycle_traverse(plane, x, y, clear_z);
N            cycle_traverse(plane, x, y, current_depth + rapid_delta);
N        }
N        cycle_feed(plane, x, y, bottom_z);
N        cycle_traverse(plane, x, y, clear_z);
N
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 3569 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g84
N
N   Returned Value: int
N   If the spindle is not turning clockwise, this returns
N   NCE_SPINDLE_NOT_TURNING_CLOCKWISE_IN_G84.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects: See below
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   For the XY plane, this implements the following RS274/NGC cycle,
N   which is right-hand tapping:
N   1. Start speed-feed synchronization.
N   2. Move the z-axis only at the current feed rate to the specified bottom_z.
N   3. Stop the spindle.
N   4. Start the spindle counterclockwise.
N   5. Retract the z-axis at current feed rate to clear_z.
N   6. If speed-feed synch was not on before the cycle started, stop it.
N   7. Stop the spindle.
N   8. Start the spindle clockwise.
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, a, b, c) when this starts.
N   The direction argument must be clockwise.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N    static int convert_cycle_g84(                 /* ARGUMENTS                           */
N    CANON_PLANE plane,                            /* selected plane                      */
N    double x,                                     /* x-value where cycle is executed     */
N    double y,                                     /* y-value where cycle is executed     */
N    double clear_z,                               /* z-value of clearance plane          */
N    double bottom_z,                              /* value of z at bottom of cycle       */
N    CANON_DIRECTION direction,                    /* direction spindle turning at outset */
N    CANON_SPEED_FEED_MODE mode)                   /* the speed-feed mode at outset       */
N    {
N        static char name[] SET_TO "convert_cycle_g84";
X        static char name[] = "convert_cycle_g84";
N
N        CHK((direction ISNT CANON_CLOCKWISE),
N            NCE_SPINDLE_NOT_TURNING_CLOCKWISE_IN_G84);
X        if ((direction != 2)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 157; } else;
N        START_SPEED_FEED_SYNCH();
N        cycle_feed(plane, x, y, bottom_z);
N        STOP_SPINDLE_TURNING();
N        START_SPINDLE_COUNTERCLOCKWISE();
N        cycle_feed(plane, x, y, clear_z);
N        if (mode ISNT CANON_SYNCHED)
X        if (mode != 1)
N            STOP_SPEED_FEED_SYNCH();
N        STOP_SPINDLE_TURNING();
N        START_SPINDLE_CLOCKWISE();
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g85
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   A number of moves are made as described below.
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   For the XY plane, this implements the following RS274/NGC cycle,
N   which is usually boring or reaming:
N   1. Move the z-axis only at the current feed rate to the specified z-value.
N   2. Retract the z-axis at the current feed rate to clear_z.
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, ?, ?) when this starts.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N    static int convert_cycle_g85(                 /* ARGUMENTS                        */
N    CANON_PLANE plane,                            /* selected plane                   */
N    double x,                                     /* x-value where cycle is executed  */
N    double y,                                     /* y-value where cycle is executed  */
N    double clear_z,                               /* z-value of clearance plane       */
N    double bottom_z)                              /* value of z at bottom of cycle    */
N    {
N        static char name[] SET_TO "convert_cycle_g85";
X        static char name[] = "convert_cycle_g85";
N
N        cycle_feed(plane, x, y, bottom_z);
N        cycle_feed(plane, x, y, clear_z);
N
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 3683 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g86
N
N   Returned Value: int
N   If the spindle is not turning clockwise or counterclockwise,
N   this returns NCE_SPINDLE_NOT_TURNING_IN_G86.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   A number of moves are made as described below.
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   For the XY plane, this implements the RS274/NGC following cycle,
N   which is usually boring:
N   1. Move the z-axis only at the current feed rate to bottom_z.
N   2. Dwell for the given number of seconds.
N   3. Stop the spindle turning.
N   4. Retract the z-axis at traverse rate to clear_z.
N   5. Restart the spindle in the direction it was going.
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, a, b, c) when this starts.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N    static int convert_cycle_g86(                 /* ARGUMENTS                           */
N    CANON_PLANE plane,                            /* selected plane                      */
N    double x,                                     /* x-value where cycle is executed     */
N    double y,                                     /* y-value where cycle is executed     */
N    double clear_z,                               /* z-value of clearance plane          */
N    double bottom_z,                              /* value of z at bottom of cycle       */
N    double dwell,                                 /* dwell time                          */
N    CANON_DIRECTION direction)                    /* direction spindle turning at outset */
N    {
N        static char name[] SET_TO "convert_cycle_g86";
X        static char name[] = "convert_cycle_g86";
N
N        CHK(((direction ISNT CANON_CLOCKWISE) AND
N            (direction ISNT CANON_COUNTERCLOCKWISE)),
N            NCE_SPINDLE_NOT_TURNING_IN_G86);
X        if (((direction != 2) && (direction != 3))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 158; } else;
N
N        cycle_feed(plane, x, y, bottom_z);
N        DWELL(dwell);
N        STOP_SPINDLE_TURNING();
N        cycle_traverse(plane, x, y, clear_z);
N        if (direction IS CANON_CLOCKWISE)
X        if (direction == 2)
N            START_SPINDLE_CLOCKWISE();
N        else
N            START_SPINDLE_COUNTERCLOCKWISE();
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g87
N
N   Returned Value: int
N   If the spindle is not turning clockwise or counterclockwise,
N   this returns NCE_SPINDLE_NOT_TURNING_IN_G87.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   A number of moves are made as described below. This cycle is a
N   modified version of [Monarch, page 5-24] since [NCMS, pages 98 - 100]
N   gives no clue as to what the cycle is supposed to do. [KT] does not
N   have a back boring cycle. [Fanuc, page 132] in "Canned cycle II"
N   describes the G87 cycle as given here, except that the direction of
N   spindle turning is always clockwise and step 7 below is omitted
N   in [Fanuc].
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   For the XY plane, this implements the following RS274/NGC cycle, which
N   is usually back boring.  The situation is that you have a through hole
N   and you want to counterbore the bottom of hole. To do this you put an
N   L-shaped tool in the spindle with a cutting surface on the UPPER side
N   of its base. You stick it carefully through the hole when it is not
N   spinning and is oriented so it fits through the hole, then you move it
N   so the stem of the L is on the axis of the hole, start the spindle,
N   and feed the tool upward to make the counterbore. Then you get the
N   tool out of the hole.
N
N   1. Move at traverse rate parallel to the XY-plane to the point
N   with x-value offset_x and y-value offset_y.
N   2. Stop the spindle in a specific orientation.
N   3. Move the z-axis only at traverse rate downward to the bottom_z.
N   4. Move at traverse rate parallel to the XY-plane to the x,y location.
N   5. Start the spindle in the direction it was going before.
N   6. Move the z-axis only at the given feed rate upward to the middle_z.
N   7. Move the z-axis only at the given feed rate back down to bottom_z.
N   8. Stop the spindle in the same orientation as before.
N   9. Move at traverse rate parallel to the XY-plane to the point
N   with x-value offset_x and y-value offset_y.
N   10. Move the z-axis only at traverse rate to the clear z value.
N   11. Move at traverse rate parallel to the XY-plane to the specified x,y
N   location.
N   12. Restart the spindle in the direction it was going before.
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, a, b, c) before this starts.
N
N   It might be useful to add a check that clear_z > middle_z > bottom_z.
N   Without the check, however, this can be used to counterbore a hole in
N   material that can only be accessed through a hole in material above it.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N    static int convert_cycle_g87(                 /* ARGUMENTS                           */
N    CANON_PLANE plane,                            /* selected plane                      */
N    double x,                                     /* x-value where cycle is executed     */
N    double offset_x,                              /* x-axis offset position              */
N    double y,                                     /* y-value where cycle is executed     */
N    double offset_y,                              /* y-axis offset position              */
N    double r,                                     /* z_value of r_plane                  */
N    double clear_z,                               /* z-value of clearance plane          */
N    double middle_z,                              /* z-value of top of back bore         */
N    double bottom_z,                              /* value of z at bottom of cycle       */
N    CANON_DIRECTION direction)                    /* direction spindle turning at outset */
N    {
N        static char name[] SET_TO "convert_cycle_g87";
X        static char name[] = "convert_cycle_g87";
N
N        CHK(((direction ISNT CANON_CLOCKWISE) AND
N            (direction ISNT CANON_COUNTERCLOCKWISE)),
N            NCE_SPINDLE_NOT_TURNING_IN_G87);
X        if (((direction != 2) && (direction != 3))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 159; } else;
N
N        cycle_traverse(plane, offset_x, offset_y, r);
N        STOP_SPINDLE_TURNING();
N        ORIENT_SPINDLE(0.0, direction);
N        cycle_traverse(plane, offset_x, offset_y, bottom_z);
N        cycle_traverse(plane, x, y, bottom_z);
N        if (direction IS CANON_CLOCKWISE)
X        if (direction == 2)
N            START_SPINDLE_CLOCKWISE();
N        else
N            START_SPINDLE_COUNTERCLOCKWISE();
N        cycle_feed(plane, x, y, middle_z);
N        cycle_feed(plane, x, y, bottom_z);
N        STOP_SPINDLE_TURNING();
N        ORIENT_SPINDLE(0.0, direction);
N        cycle_traverse(plane, offset_x, offset_y, bottom_z);
N        cycle_traverse(plane, offset_x, offset_y, clear_z);
N        cycle_traverse(plane, x, y, clear_z);
N        if (direction IS CANON_CLOCKWISE)
X        if (direction == 2)
N            START_SPINDLE_CLOCKWISE();
N        else
N            START_SPINDLE_COUNTERCLOCKWISE();
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g88
N
N   Returned Value: int
N   If the spindle is not turning clockwise or counterclockwise, this
N   returns NCE_SPINDLE_NOT_TURNING_IN_G88.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects: See below
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   For the XY plane, this implements the following RS274/NGC cycle,
N   which is usually boring:
N   1. Move the z-axis only at the current feed rate to the specified z-value.
N   2. Dwell for the given number of seconds.
N   3. Stop the spindle turning.
N   4. Stop the program so the operator can retract the spindle manually.
N   5. Restart the spindle.
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, a, b, c) when this starts.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N    static int convert_cycle_g88(                 /* ARGUMENTS                           */
N    CANON_PLANE plane,                            /* selected plane                      */
N    double x,                                     /* x-value where cycle is executed     */
N    double y,                                     /* y-value where cycle is executed     */
N    double bottom_z,                              /* value of z at bottom of cycle       */
N    double dwell,                                 /* dwell time                          */
N    CANON_DIRECTION direction)                    /* direction spindle turning at outset */
N    {
N        static char name[] SET_TO "convert_cycle_g88";
X        static char name[] = "convert_cycle_g88";
N
N        CHK(((direction ISNT CANON_CLOCKWISE) AND
N            (direction ISNT CANON_COUNTERCLOCKWISE)),
N            NCE_SPINDLE_NOT_TURNING_IN_G88);
X        if (((direction != 2) && (direction != 3))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 160; } else;
N
N        cycle_feed(plane, x, y, bottom_z);
N        DWELL(dwell);
N        STOP_SPINDLE_TURNING();
N        PROGRAM_STOP();                           /* operator retracts the spindle here */
N        if (direction IS CANON_CLOCKWISE)
X        if (direction == 2)
N            START_SPINDLE_CLOCKWISE();
N        else
N            START_SPINDLE_COUNTERCLOCKWISE();
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_g89
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects: See below
N
N   Called by:
N   convert_cycle_xy
N   convert_cycle_yz
N   convert_cycle_zx
N
N   This implements the following RS274/NGC cycle, which is intended for boring:
N   1. Move the z-axis only at the current feed rate to the specified z-value.
N   2. Dwell for the given number of seconds.
N   3. Retract the z-axis at the current feed rate to clear_z.
N
N   CYCLE_MACRO has positioned the tool at (x, y, r, a, b, c) when this starts.
N
N   For the XZ and YZ planes, this makes analogous motions.
N
N   */
N
N    static int convert_cycle_g89(                 /* ARGUMENTS                        */
N    CANON_PLANE plane,                            /* selected plane                   */
N    double x,                                     /* x-value where cycle is executed  */
N    double y,                                     /* y-value where cycle is executed  */
N    double clear_z,                               /* z-value of clearance plane       */
N    double bottom_z,                              /* value of z at bottom of cycle    */
N    double dwell)                                 /* dwell time                       */
N    {
N        static char name[] SET_TO "convert_cycle_g89";
X        static char name[] = "convert_cycle_g89";
N
N        cycle_feed(plane, x, y, bottom_z);
N        DWELL(dwell);
N        cycle_feed(plane, x, y, clear_z);
N
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 3938 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_xy
N
N   Returned Value: int
N   If any of the specific functions called returns an error code,
N   this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The z-value is not given the first time this code is called after
N   some other motion mode has been in effect:
N   NCE_Z_VALUE_UNSPECIFIED_IN_XY_PLANE_CANNED_CYCLE
N   2. The r clearance plane is below the bottom_z:
N   NCE_R_LESS_THAN_Z_IN_CYCLE_IN_XY_PLANE
N   3. the distance mode is neither absolute or incremental:
N   NCE_BUG_DISTANCE_MODE_NOT_G90_OR_G91
N   4. G82, G86, G88, or G89 is called when it is not already in effect,
N   and no p number is in the block:
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G82
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G86
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G88
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G89
N   5. G83 is called when it is not already in effect,
N   and no q number is in the block: NCE_Q_WORD_MISSING_WITH_G83
N   6. G87 is called when it is not already in effect,
N   and any of the i number, j number, or k number is missing:
N   NCE_I_WORD_MISSING_WITH_G87
N   NCE_J_WORD_MISSING_WITH_G87
N   NCE_K_WORD_MISSING_WITH_G87
N   7. the G code is not between G_81 and G_89.
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N
N   Side effects:
N   A number of moves are made to execute the g-code
N
N   Called by: convert_cycle
N
N   The function does not require that any of x,y,z, or r be specified in
N   the block, except that if the last motion mode command executed was
N   not the same as this one, the r-value and z-value must be specified.
N
N   This function is handling the repeat feature of RS274/NGC, wherein
N   the L word represents the number of repeats [NCMS, page 99]. We are
N   not allowing L=0, contrary to the manual. We are allowing L > 1
N   in absolute distance mode to mean "do the same thing in the same
N   place several times", as provided in the manual, although this seems
N   abnormal.
N
N   In incremental distance mode, x, y, and r values are treated as
N   increments to the current position and z as an increment from r.  In
N   absolute distance mode, x, y, r, and z are absolute. In g87, i and j
N   will always be increments, regardless of the distance mode setting, as
N   implied in [NCMS, page 98], but k (z-value of top of counterbore) will
N   be an absolute z-value in absolute distance mode, and an increment
N   (from bottom z) in incremental distance mode.
N
N   If the r position of a cycle is above the current_z position, this
N   retracts the z-axis to the r position before moving parallel to the
N   XY plane.
N
N   In the code for this function, there is a nearly identical "for" loop
N   in every case of the switch. The loop is the done with a compiler
N   macro, "CYCLE_MACRO" so that the code is easy to read, automatically
N   kept identical from case to case and, and much shorter than it would
N   be without the macro. The loop could be put outside the switch, but
N   then the switch would run every time around the loop, not just once,
N   as it does here. The loop could also be placed in the called
N   functions, but then it would not be clear that all the loops are the
N   same, and it would be hard to keep them the same when the code is
N   modified.  The macro would be very awkward as a regular function
N   because it would have to be passed all of the arguments used by any of
N   the specific cycles, and, if another switch in the function is to be
N   avoided, it would have to passed a function pointer, but the different
N   cycle functions have different arguments so the type of the pointer
N   could not be declared unless the cycle functions were re-written to
N   take the same arguments (in which case most of them would have several
N   unused arguments).
N
N   The motions within the CYCLE_MACRO (but outside a specific cycle) are
N   a straight traverse parallel to the selected plane to the given
N   position in the plane and a straight traverse of the third axis only
N   (if needed) to the r position.
N
N   The CYCLE_MACRO is defined here but is also used in convert_cycle_yz
N   and convert_cycle_zx. The variables aa, bb, and cc are used in
N   CYCLE_MACRO and in the other two functions just mentioned. Those
N   variables represent the first axis of the selected plane, the second
N   axis of the selected plane, and third axis which is perpendicular to
N   the selected plane.  In this function aa represents x, bb represents
N   y, and cc represents z. This usage makes it possible to have only one
N   version of each of the cycle functions.  The cycle_traverse and
N   cycle_feed functions help accomplish this.
N
N   The height of the retract move at the end of each repeat of a cycle is
N   determined by the setting of the retract_mode: either to the r
N   position (if the retract_mode is R_PLANE) or to the original
N   z-position (if that is above the r position and the retract_mode is
N   not R_PLANE). This is a slight departure from [NCMS, page 98], which
N   does not require checking that the original z-position is above r.
N
N   The rotary axes may not move during a canned cycle.
N
N   */
N
N#define CYCLE_MACRO(call) for (repeat SET_TO block->l_number; \
Nrepeat > 0; \
Nrepeat--) \
N{ \
N    aa SET_TO (aa + aa_increment); \
N    bb SET_TO (bb + bb_increment); \
N    cycle_traverse(plane, aa, bb, old_cc); \
N    if (old_cc ISNT r) \
N    cycle_traverse(plane, aa, bb, r); \
N    CHP(call); \
N    old_cc SET_TO clear_cc; \
N}
X#define CYCLE_MACRO(call) for (repeat SET_TO block->l_number; repeat > 0; repeat--) {     aa SET_TO (aa + aa_increment);     bb SET_TO (bb + bb_increment);     cycle_traverse(plane, aa, bb, old_cc);     if (old_cc ISNT r)     cycle_traverse(plane, aa, bb, r);     CHP(call);     old_cc SET_TO clear_cc; }
N
N        static int convert_cycle_xy(              /* ARGUMENTS                                 */
N        int motion,                               /* a g-code between G_81 and G_89, a canned cycle */
N        block_pointer block,                      /* pointer to a block of RS274 instructions       */
N        setup_pointer settings)                   /* pointer to machine settings                    */
N    {
N        static char name[] SET_TO "convert_cycle_xy";
X        static char name[] = "convert_cycle_xy";
N        double aa;
N        double aa_increment;
N        double bb;
N        double bb_increment;
N        double cc;
N        double clear_cc;
N        double i;
N        double j;
N        double k;
N        double old_cc;
N        CANON_PLANE plane;
N        double r;
N        int repeat;
N        CANON_MOTION_MODE save_mode;
N        int status;
N
N        plane SET_TO CANON_PLANE_XY;
X        plane = 1;
N        if (settings->motion_mode ISNT motion)
X        if (settings->motion_mode != motion)
N        {
N            CHK((block->z_flag IS OFF),
N                NCE_Z_VALUE_UNSPECIFIED_IN_XY_PLANE_CANNED_CYCLE);
X            if ((block->z_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 195; } else;
N        }
N        block->z_number SET_TO
X        block->z_number =
N            block->z_flag IS ON ? block->z_number : settings->cycle_cc;
X            block->z_flag == 1 ? block->z_number : settings->cycle_cc;
N        old_cc SET_TO settings->current_z;
X        old_cc = settings->current_z;
N
N        if (settings->distance_mode IS MODE_ABSOLUTE)
X        if (settings->distance_mode == MODE_ABSOLUTE)
N        {
N            aa_increment SET_TO 0.0;
X            aa_increment = 0.0;
N            bb_increment SET_TO 0.0;
X            bb_increment = 0.0;
N            r SET_TO block->r_number;
X            r = block->r_number;
N            cc SET_TO block->z_number;
X            cc = block->z_number;
N            aa SET_TO block->x_flag IS ON ? block->x_number : settings->current_x;
X            aa = block->x_flag == 1 ? block->x_number : settings->current_x;
N            bb SET_TO block->y_flag IS ON ? block->y_number : settings->current_y;
X            bb = block->y_flag == 1 ? block->y_number : settings->current_y;
N        }
N        else if (settings->distance_mode IS MODE_INCREMENTAL)
X        else if (settings->distance_mode == MODE_INCREMENTAL)
N        {
N            aa_increment SET_TO block->x_number;
X            aa_increment = block->x_number;
N            bb_increment SET_TO block->y_number;
X            bb_increment = block->y_number;
N            r SET_TO (block->r_number + old_cc);
X            r = (block->r_number + old_cc);
N            cc SET_TO (r + block->z_number);      /* [NCMS, page 98] */
X            cc = (r + block->z_number);       
N            aa SET_TO settings->current_x;
X            aa = settings->current_x;
N            bb SET_TO settings->current_y;
X            bb = settings->current_y;
N        }
N        else
N            ERM(NCE_BUG_DISTANCE_MODE_NOT_G90_OR_G91);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 31; } else;
N        CHK((r < cc), NCE_R_LESS_THAN_Z_IN_CYCLE_IN_XY_PLANE);
X        if ((r < cc)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 150; } else;
N
N        if (old_cc < r)
N        {
N            STRAIGHT_TRAVERSE(settings->current_x, settings->current_y, r
N    #ifdef AA
S                ,     settings->AA_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,  settings->BB_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,  settings->CC_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N            old_cc SET_TO r;
X            old_cc = r;
N        }
N        clear_cc SET_TO (settings->retract_mode IS R_PLANE) ? r : old_cc;
X        clear_cc = (settings->retract_mode == R_PLANE) ? r : old_cc;
N
N        save_mode SET_TO GET_EXTERNAL_MOTION_CONTROL_MODE();
X        save_mode = GET_EXTERNAL_MOTION_CONTROL_MODE();
N        if (save_mode ISNT CANON_EXACT_PATH)
X        if (save_mode != 2)
N            SET_MOTION_CONTROL_MODE(CANON_EXACT_PATH);
X            SET_MOTION_CONTROL_MODE(2);
N
N        switch(motion)
N        {
N            case G_81:
X            case 810:
N                CYCLE_MACRO(convert_cycle_g81(CANON_PLANE_XY, aa, bb, clear_cc, cc))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g81(1, aa, bb, clear_cc, cc))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_82:
X            case 820:
N                CHK(((settings->motion_mode ISNT G_82) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G82);
X                if (((settings->motion_mode != 820) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 73; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g82 (CANON_PLANE_XY, aa, bb, clear_cc, cc,
N                    block->p_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g82 (1, aa, bb, clear_cc, cc, block->p_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_83:
X            case 830:
N                CHK(((settings->motion_mode ISNT G_83) AND (block->q_number IS -1.0)),
N                    NCE_Q_WORD_MISSING_WITH_G83);
X                if (((settings->motion_mode != 830) && (block->q_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 143; } else;
N                block->q_number SET_TO
X                block->q_number =
N                    block->q_number IS -1.0 ? settings->cycle_q : block->q_number;
X                    block->q_number == -1.0 ? settings->cycle_q : block->q_number;
N                CYCLE_MACRO(convert_cycle_g83 (CANON_PLANE_XY, aa, bb, r, clear_cc, cc,
N                    block->q_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g83 (1, aa, bb, r, clear_cc, cc, block->q_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_q SET_TO block->q_number;
X                    settings->cycle_q = block->q_number;
N                break;
N            case G_84:
X            case 840:
N                CYCLE_MACRO(convert_cycle_g84 (CANON_PLANE_XY, aa, bb, clear_cc, cc,
N                    settings->spindle_turning, settings->speed_feed_mode))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g84 (1, aa, bb, clear_cc, cc, settings->spindle_turning, settings->speed_feed_mode))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_85:
X            case 850:
N                CYCLE_MACRO(convert_cycle_g85 (CANON_PLANE_XY, aa, bb, clear_cc, cc))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g85 (1, aa, bb, clear_cc, cc))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_86:
X            case 860:
N                CHK(((settings->motion_mode ISNT G_86) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G86);
X                if (((settings->motion_mode != 860) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 74; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g86 (CANON_PLANE_XY, aa, bb, clear_cc, cc,
N                    block->p_number, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g86 (1, aa, bb, clear_cc, cc, block->p_number, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_87:
X            case 870:
N                if (settings->motion_mode ISNT G_87)
X                if (settings->motion_mode != 870)
N                {
N                    CHK((block->i_flag IS OFF), NCE_I_WORD_MISSING_WITH_G87);
X                    if ((block->i_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 87; } else;
N                    CHK((block->j_flag IS OFF), NCE_J_WORD_MISSING_WITH_G87);
X                    if ((block->j_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 90; } else;
N                    CHK((block->k_flag IS OFF), NCE_K_WORD_MISSING_WITH_G87);
X                    if ((block->k_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 93; } else;
N                }
N                i SET_TO block->i_flag IS ON ? block->i_number : settings->cycle_i;
X                i = block->i_flag == 1 ? block->i_number : settings->cycle_i;
N                j SET_TO block->j_flag IS ON ? block->j_number : settings->cycle_j;
X                j = block->j_flag == 1 ? block->j_number : settings->cycle_j;
N                k SET_TO block->k_flag IS ON ? block->k_number : settings->cycle_k;
X                k = block->k_flag == 1 ? block->k_number : settings->cycle_k;
N                settings->cycle_i SET_TO i;
X                settings->cycle_i = i;
N                settings->cycle_j SET_TO j;
X                settings->cycle_j = j;
N                settings->cycle_k SET_TO k;
X                settings->cycle_k = k;
N                if (settings->distance_mode IS MODE_INCREMENTAL)
X                if (settings->distance_mode == MODE_INCREMENTAL)
N                {
N                    k SET_TO (cc + k);            /* k always absolute in function call below */
X                    k = (cc + k);             
N                }
N                CYCLE_MACRO(convert_cycle_g87 (CANON_PLANE_XY, aa, (aa + i), bb,
N                    (bb + j), r, clear_cc, k, cc, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g87 (1, aa, (aa + i), bb, (bb + j), r, clear_cc, k, cc, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_88:
X            case 880:
N                CHK(((settings->motion_mode ISNT G_88) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G88);
X                if (((settings->motion_mode != 880) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 75; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g88 (CANON_PLANE_XY, aa, bb, cc,
N                    block->p_number, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g88 (1, aa, bb, cc, block->p_number, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_89:
X            case 890:
N                CHK(((settings->motion_mode ISNT G_89) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G89);
X                if (((settings->motion_mode != 890) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 76; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g89 (CANON_PLANE_XY, aa, bb, clear_cc, cc,
N                    block->p_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g89 (1, aa, bb, clear_cc, cc, block->p_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            default:
N                ERM(NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        }
N        settings->current_x SET_TO aa;            /* CYCLE_MACRO updates aa and bb */
X        settings->current_x = aa;             
N        settings->current_y SET_TO bb;
X        settings->current_y = bb;
N        settings->current_z SET_TO clear_cc;
X        settings->current_z = clear_cc;
N        settings->cycle_cc SET_TO block->z_number;
X        settings->cycle_cc = block->z_number;
N
N        if (save_mode ISNT CANON_EXACT_PATH)
X        if (save_mode != 2)
N            SET_MOTION_CONTROL_MODE(save_mode);
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_yz
N
N   Returned Value: int
N   If any of the specific functions called returns an error code,
N   this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The x-value is not given the first time this code is called after
N   some other motion mode has been in effect:
N   NCE_X_VALUE_UNSPECIFIED_IN_YZ_PLANE_CANNED_CYCLE
N   2. The r clearance plane is below the bottom_x:
N   NCE_R_LESS_THAN_X_IN_CYCLE_IN_YZ_PLANE
N   3. the distance mode is neither absolute or incremental:
N   NCE_BUG_DISTANCE_MODE_NOT_G90_OR_G91
N   4. G82, G86, G88, or G89 is called when it is not already in effect,
N   and no p number is in the block:
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G82
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G86
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G88
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G89
N   5. G83 is called when it is not already in effect,
N   and no q number is in the block: NCE_Q_WORD_MISSING_WITH_G83
N   6. G87 is called when it is not already in effect,
N   and any of the i number, j number, or k number is missing:
N   NCE_I_WORD_MISSING_WITH_G87
N   NCE_J_WORD_MISSING_WITH_G87
N   NCE_K_WORD_MISSING_WITH_G87
N   7. the G code is not between G_81 and G_89.
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N
N   Side effects:
N   A number of moves are made to execute a canned cycle.
N
N   Called by: convert_cycle
N
N   See the documentation of convert_cycle_xy. This function is entirely
N   similar. In this function aa represents y, bb represents z, and cc
N   represents x.
N
N   The CYCLE_MACRO is defined just before the convert_cycle_xy function.
N
N   Tool length offsets work only when the tool axis is parallel to the
N   Z-axis, so if this function is used, tool length offsets should be
N   turned off, and the NC code written to take tool length into account.
N
N   */
N
N    static int convert_cycle_yz(                  /* ARGUMENTS                                 */
N    int motion,                                   /* a g-code between G_81 and G_89, a canned cycle */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions   */
N    setup_pointer settings)                       /* pointer to machine settings                    */
N    {
N        static char name[] SET_TO "convert_cycle_yz";
X        static char name[] = "convert_cycle_yz";
N        double aa;
N        double aa_increment;
N        double bb;
N        double bb_increment;
N        double cc;
N        double clear_cc;
N        double i;
N        double j;
N        double k;
N        double old_cc;
N        CANON_PLANE plane;
N        double r;
N        int repeat;
N        CANON_MOTION_MODE save_mode;
N        int status;
N
N        plane SET_TO CANON_PLANE_YZ;
X        plane = 2;
N        if (settings->motion_mode ISNT motion)
X        if (settings->motion_mode != motion)
N        {
N            CHK((block->x_flag IS OFF),
N                NCE_X_VALUE_UNSPECIFIED_IN_YZ_PLANE_CANNED_CYCLE);
X            if ((block->x_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 191; } else;
N        }
N        block->x_number SET_TO
X        block->x_number =
N            block->x_flag IS ON ? block->x_number : settings->cycle_cc;
X            block->x_flag == 1 ? block->x_number : settings->cycle_cc;
N        old_cc SET_TO settings->current_x;
X        old_cc = settings->current_x;
N
N        if (settings->distance_mode IS MODE_ABSOLUTE)
X        if (settings->distance_mode == MODE_ABSOLUTE)
N        {
N            aa_increment SET_TO 0.0;
X            aa_increment = 0.0;
N            bb_increment SET_TO 0.0;
X            bb_increment = 0.0;
N            r SET_TO block->r_number;
X            r = block->r_number;
N            cc SET_TO block->x_number;
X            cc = block->x_number;
N            aa SET_TO block->y_flag IS ON ? block->y_number : settings->current_y;
X            aa = block->y_flag == 1 ? block->y_number : settings->current_y;
N            bb SET_TO block->z_flag IS ON ? block->z_number : settings->current_z;
X            bb = block->z_flag == 1 ? block->z_number : settings->current_z;
N        }
N        else if (settings->distance_mode IS MODE_INCREMENTAL)
X        else if (settings->distance_mode == MODE_INCREMENTAL)
N        {
N            aa_increment SET_TO block->y_number;
X            aa_increment = block->y_number;
N            bb_increment SET_TO block->z_number;
X            bb_increment = block->z_number;
N            r SET_TO (block->r_number + old_cc);
X            r = (block->r_number + old_cc);
N            cc SET_TO (r + block->x_number);      /* [NCMS, page 98] */
X            cc = (r + block->x_number);       
N            aa SET_TO settings->current_y;
X            aa = settings->current_y;
N            bb SET_TO settings->current_z;
X            bb = settings->current_z;
N        }
N        else
N            ERM(NCE_BUG_DISTANCE_MODE_NOT_G90_OR_G91);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 31; } else;
N        CHK((r < cc), NCE_R_LESS_THAN_X_IN_CYCLE_IN_YZ_PLANE);
X        if ((r < cc)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 148; } else;
N
N        if (old_cc < r)
N        {
N            STRAIGHT_TRAVERSE(r, settings->current_y, settings->current_z
N    #ifdef AA
S                ,      settings->AA_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,  settings->BB_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,  settings->CC_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N            old_cc SET_TO r;
X            old_cc = r;
N        }
N        clear_cc SET_TO (settings->retract_mode IS R_PLANE) ? r : old_cc;
X        clear_cc = (settings->retract_mode == R_PLANE) ? r : old_cc;
N
N        save_mode = GET_EXTERNAL_MOTION_CONTROL_MODE();
N        if (save_mode ISNT CANON_EXACT_PATH)
X        if (save_mode != 2)
N            SET_MOTION_CONTROL_MODE(CANON_EXACT_PATH);
X            SET_MOTION_CONTROL_MODE(2);
N
N        switch(motion)
N        {
N            case G_81:
X            case 810:
N                CYCLE_MACRO(convert_cycle_g81(CANON_PLANE_YZ, aa, bb, clear_cc, cc))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g81(2, aa, bb, clear_cc, cc))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_82:
X            case 820:
N                CHK(((settings->motion_mode ISNT G_82) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G82);
X                if (((settings->motion_mode != 820) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 73; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g82 (CANON_PLANE_YZ, aa, bb, clear_cc, cc,
N                    block->p_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g82 (2, aa, bb, clear_cc, cc, block->p_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_83:
X            case 830:
N                CHK(((settings->motion_mode ISNT G_83) AND (block->q_number IS -1.0)),
N                    NCE_Q_WORD_MISSING_WITH_G83);
X                if (((settings->motion_mode != 830) && (block->q_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 143; } else;
N                block->q_number SET_TO
X                block->q_number =
N                    block->q_number IS -1.0 ? settings->cycle_q : block->q_number;
X                    block->q_number == -1.0 ? settings->cycle_q : block->q_number;
N                CYCLE_MACRO(convert_cycle_g83 (CANON_PLANE_YZ, aa, bb, r, clear_cc, cc,
N                    block->q_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g83 (2, aa, bb, r, clear_cc, cc, block->q_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_q SET_TO block->q_number;
X                    settings->cycle_q = block->q_number;
N                break;
N            case G_84:
X            case 840:
N                CYCLE_MACRO(convert_cycle_g84 (CANON_PLANE_YZ, aa, bb, clear_cc, cc,
N                    settings->spindle_turning, settings->speed_feed_mode))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g84 (2, aa, bb, clear_cc, cc, settings->spindle_turning, settings->speed_feed_mode))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_85:
X            case 850:
N                CYCLE_MACRO(convert_cycle_g85 (CANON_PLANE_YZ, aa, bb, clear_cc, cc))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g85 (2, aa, bb, clear_cc, cc))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_86:
X            case 860:
N                CHK(((settings->motion_mode ISNT G_86) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G86);
X                if (((settings->motion_mode != 860) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 74; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g86 (CANON_PLANE_YZ, aa, bb, clear_cc, cc,
N                    block->p_number, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g86 (2, aa, bb, clear_cc, cc, block->p_number, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_87:
X            case 870:
N                if (settings->motion_mode ISNT G_87)
X                if (settings->motion_mode != 870)
N                {
N                    CHK((block->i_flag IS OFF), NCE_I_WORD_MISSING_WITH_G87);
X                    if ((block->i_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 87; } else;
N                    CHK((block->j_flag IS OFF), NCE_J_WORD_MISSING_WITH_G87);
X                    if ((block->j_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 90; } else;
N                    CHK((block->k_flag IS OFF), NCE_K_WORD_MISSING_WITH_G87);
X                    if ((block->k_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 93; } else;
N                }
N                i SET_TO block->i_flag IS ON ? block->i_number : settings->cycle_i;
X                i = block->i_flag == 1 ? block->i_number : settings->cycle_i;
N                j SET_TO block->j_flag IS ON ? block->j_number : settings->cycle_j;
X                j = block->j_flag == 1 ? block->j_number : settings->cycle_j;
N                k SET_TO block->k_flag IS ON ? block->k_number : settings->cycle_k;
X                k = block->k_flag == 1 ? block->k_number : settings->cycle_k;
N                settings->cycle_i SET_TO i;
X                settings->cycle_i = i;
N                settings->cycle_j SET_TO j;
X                settings->cycle_j = j;
N                settings->cycle_k SET_TO k;
X                settings->cycle_k = k;
N                if (settings->distance_mode IS MODE_INCREMENTAL)
X                if (settings->distance_mode == MODE_INCREMENTAL)
N                {
N                    i SET_TO (cc + i);            /* i always absolute in function call below */
X                    i = (cc + i);             
N                }
N                CYCLE_MACRO(convert_cycle_g87 (CANON_PLANE_YZ, aa, (aa + j), bb,
N                    (bb + k), r, clear_cc, i, cc, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g87 (2, aa, (aa + j), bb, (bb + k), r, clear_cc, i, cc, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_88:
X            case 880:
N                CHK(((settings->motion_mode ISNT G_88) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G88);
X                if (((settings->motion_mode != 880) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 75; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g88 (CANON_PLANE_YZ, aa, bb, cc,
N                    block->p_number, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g88 (2, aa, bb, cc, block->p_number, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_89:
X            case 890:
N                CHK(((settings->motion_mode ISNT G_89) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G89);
X                if (((settings->motion_mode != 890) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 76; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g89 (CANON_PLANE_YZ, aa, bb, clear_cc, cc,
N                    block->p_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g89 (2, aa, bb, clear_cc, cc, block->p_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            default:
N                ERM(NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        }
N        settings->current_y SET_TO aa;            /* CYCLE_MACRO updates aa and bb */
X        settings->current_y = aa;             
N        settings->current_z SET_TO bb;
X        settings->current_z = bb;
N        settings->current_x SET_TO clear_cc;
X        settings->current_x = clear_cc;
N        settings->cycle_cc SET_TO block->x_number;
X        settings->cycle_cc = block->x_number;
N
N        if (save_mode ISNT CANON_EXACT_PATH)
X        if (save_mode != 2)
N            SET_MOTION_CONTROL_MODE(save_mode);
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_cycle_zx
N
N   Returned Value: int
N   If any of the specific functions called returns an error code,
N   this returns that code.
N   If any of the following errors occur, this returns the ERROR code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The y-value is not given the first time this code is called after
N   some other motion mode has been in effect:
N   NCE_Y_VALUE_UNSPECIFIED_IN_XZ_PLANE_CANNED_CYCLE
N   2. The r clearance plane is below the bottom_y:
N   NCE_R_LESS_THAN_Y_IN_CYCLE_IN_XZ_PLANE
N   3. the distance mode is neither absolute or incremental:
N   NCE_BUG_DISTANCE_MODE_NOT_G90_OR_G91
N   4. G82, G86, G88, or G89 is called when it is not already in effect,
N   and no p number is in the block:
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G82
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G86
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G88
N   NCE_DWELL_TIME_P_WORD_MISSING_WITH_G89
N   5. G83 is called when it is not already in effect,
N   and no q number is in the block: NCE_Q_WORD_MISSING_WITH_G83
N   6. G87 is called when it is not already in effect,
N   and any of the i number, j number, or k number is missing:
N   NCE_I_WORD_MISSING_WITH_G87
N   NCE_J_WORD_MISSING_WITH_G87
N   NCE_K_WORD_MISSING_WITH_G87
N   7. the G code is not between G_81 and G_89.
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N
N   Side effects:
N   A number of moves are made to execute a canned cycle.
N
N   Called by: convert_cycle
N
N   See the documentation of convert_cycle_xy. This function is entirely
N   similar. In this function aa represents z, bb represents x, and cc
N   represents y.
N
N   The CYCLE_MACRO is defined just before the convert_cycle_xy function.
N
N   Tool length offsets work only when the tool axis is parallel to the
N   Z-axis, so if this function is used, tool length offsets should be
N   turned off, and the NC code written to take tool length into account.
N
N   It is a little distracting that this function uses zx in some places
N   and xz in others; uniform use of zx would be nice, since that is the
N   order for a right-handed coordinate system. Also with that usage,
N   permutation of the symbols x, y, and z would allow for automatically
N   converting the convert_cycle_xy function (or convert_cycle_yz) into
N   the convert_cycle_xz function. However, the canonical interface uses
N   CANON_PLANE_XZ.
N
N   */
N
N    static int convert_cycle_zx(                  /* ARGUMENTS                                 */
N    int motion,                                   /* a g-code between G_81 and G_89, a canned cycle */
N    block_pointer block,                          /* pointer to a block of RS274 instructions       */
N    setup_pointer settings)                       /* pointer to machine settings                    */
N    {
N        static char name[] SET_TO "convert_cycle_zx";
X        static char name[] = "convert_cycle_zx";
N        double aa;
N        double aa_increment;
N        double bb;
N        double bb_increment;
N        double cc;
N        double clear_cc;
N        double i;
N        double j;
N        double k;
N        double old_cc;
N        CANON_PLANE plane;
N        double r;
N        int repeat;
N        CANON_MOTION_MODE save_mode;
N        int status;
N
N        plane SET_TO CANON_PLANE_XZ;
X        plane = 3;
N        if (settings->motion_mode ISNT motion)
X        if (settings->motion_mode != motion)
N        {
N            CHK((block->y_flag IS OFF),
N                NCE_Y_VALUE_UNSPECIFIED_IN_XZ_PLANE_CANNED_CYCLE);
X            if ((block->y_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 194; } else;
N        }
N        block->y_number SET_TO
X        block->y_number =
N            block->y_flag IS ON ? block->y_number : settings->cycle_cc;
X            block->y_flag == 1 ? block->y_number : settings->cycle_cc;
N        old_cc SET_TO settings->current_y;
X        old_cc = settings->current_y;
N
N        if (settings->distance_mode IS MODE_ABSOLUTE)
X        if (settings->distance_mode == MODE_ABSOLUTE)
N        {
N            aa_increment SET_TO 0.0;
X            aa_increment = 0.0;
N            bb_increment SET_TO 0.0;
X            bb_increment = 0.0;
N            r SET_TO block->r_number;
X            r = block->r_number;
N            cc SET_TO block->y_number;
X            cc = block->y_number;
N            aa SET_TO block->z_flag IS ON ? block->z_number : settings->current_z;
X            aa = block->z_flag == 1 ? block->z_number : settings->current_z;
N            bb SET_TO block->x_flag IS ON ? block->x_number : settings->current_x;
X            bb = block->x_flag == 1 ? block->x_number : settings->current_x;
N        }
N        else if (settings->distance_mode IS MODE_INCREMENTAL)
X        else if (settings->distance_mode == MODE_INCREMENTAL)
N        {
N            aa_increment SET_TO block->z_number;
X            aa_increment = block->z_number;
N            bb_increment SET_TO block->x_number;
X            bb_increment = block->x_number;
N            r SET_TO (block->r_number + old_cc);
X            r = (block->r_number + old_cc);
N            cc SET_TO (r + block->y_number);      /* [NCMS, page 98] */
X            cc = (r + block->y_number);       
N            aa SET_TO settings->current_z;
X            aa = settings->current_z;
N            bb SET_TO settings->current_x;
X            bb = settings->current_x;
N        }
N        else
N            ERM(NCE_BUG_DISTANCE_MODE_NOT_G90_OR_G91);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 31; } else;
N        CHK((r < cc), NCE_R_LESS_THAN_Y_IN_CYCLE_IN_XZ_PLANE);
X        if ((r < cc)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 149; } else;
N
N        if (old_cc < r)
N        {
N            STRAIGHT_TRAVERSE(settings->current_x, r, settings->current_z
N    #ifdef AA
S                ,           settings->AA_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,  settings->BB_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,  settings->CC_current
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N            old_cc SET_TO r;
X            old_cc = r;
N        }
N        clear_cc SET_TO (settings->retract_mode IS R_PLANE) ? r : old_cc;
X        clear_cc = (settings->retract_mode == R_PLANE) ? r : old_cc;
N
N        save_mode = GET_EXTERNAL_MOTION_CONTROL_MODE();
N        if (save_mode ISNT CANON_EXACT_PATH)
X        if (save_mode != 2)
N            SET_MOTION_CONTROL_MODE(CANON_EXACT_PATH);
X            SET_MOTION_CONTROL_MODE(2);
N
N        switch(motion)
N        {
N            case G_81:
X            case 810:
N                CYCLE_MACRO(convert_cycle_g81(CANON_PLANE_XZ, aa, bb, clear_cc, cc))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g81(3, aa, bb, clear_cc, cc))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_82:
X            case 820:
N                CHK(((settings->motion_mode ISNT G_82) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G82);
X                if (((settings->motion_mode != 820) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 73; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g82 (CANON_PLANE_XZ, aa, bb, clear_cc, cc,
N                    block->p_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g82 (3, aa, bb, clear_cc, cc, block->p_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_83:
X            case 830:
N                CHK(((settings->motion_mode ISNT G_83) AND (block->q_number IS -1.0)),
N                    NCE_Q_WORD_MISSING_WITH_G83);
X                if (((settings->motion_mode != 830) && (block->q_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 143; } else;
N                block->q_number SET_TO
X                block->q_number =
N                    block->q_number IS -1.0 ? settings->cycle_q : block->q_number;
X                    block->q_number == -1.0 ? settings->cycle_q : block->q_number;
N                CYCLE_MACRO(convert_cycle_g83 (CANON_PLANE_XZ, aa, bb, r, clear_cc, cc,
N                    block->q_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g83 (3, aa, bb, r, clear_cc, cc, block->q_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_q SET_TO block->q_number;
X                    settings->cycle_q = block->q_number;
N                break;
N            case G_84:
X            case 840:
N                CYCLE_MACRO(convert_cycle_g84 (CANON_PLANE_XZ, aa, bb, clear_cc, cc,
N                    settings->spindle_turning, settings->speed_feed_mode))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g84 (3, aa, bb, clear_cc, cc, settings->spindle_turning, settings->speed_feed_mode))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_85:
X            case 850:
N                CYCLE_MACRO(convert_cycle_g85 (CANON_PLANE_XZ, aa, bb, clear_cc, cc))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g85 (3, aa, bb, clear_cc, cc))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_86:
X            case 860:
N                CHK(((settings->motion_mode ISNT G_86) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G86);
X                if (((settings->motion_mode != 860) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 74; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g86 (CANON_PLANE_XZ, aa, bb, clear_cc, cc,
N                    block->p_number, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g86 (3, aa, bb, clear_cc, cc, block->p_number, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_87:
X            case 870:
N                if (settings->motion_mode ISNT G_87)
X                if (settings->motion_mode != 870)
N                {
N                    CHK((block->i_flag IS OFF), NCE_I_WORD_MISSING_WITH_G87);
X                    if ((block->i_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 87; } else;
N                    CHK((block->j_flag IS OFF), NCE_J_WORD_MISSING_WITH_G87);
X                    if ((block->j_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 90; } else;
N                    CHK((block->k_flag IS OFF), NCE_K_WORD_MISSING_WITH_G87);
X                    if ((block->k_flag == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 93; } else;
N                }
N                i SET_TO block->i_flag IS ON ? block->i_number : settings->cycle_i;
X                i = block->i_flag == 1 ? block->i_number : settings->cycle_i;
N                j SET_TO block->j_flag IS ON ? block->j_number : settings->cycle_j;
X                j = block->j_flag == 1 ? block->j_number : settings->cycle_j;
N                k SET_TO block->k_flag IS ON ? block->k_number : settings->cycle_k;
X                k = block->k_flag == 1 ? block->k_number : settings->cycle_k;
N                settings->cycle_i SET_TO i;
X                settings->cycle_i = i;
N                settings->cycle_j SET_TO j;
X                settings->cycle_j = j;
N                settings->cycle_k SET_TO k;
X                settings->cycle_k = k;
N                if (settings->distance_mode IS MODE_INCREMENTAL)
X                if (settings->distance_mode == MODE_INCREMENTAL)
N                {
N                    j SET_TO (cc + j);            /* j always absolute in function call below */
X                    j = (cc + j);             
N                }
N                CYCLE_MACRO(convert_cycle_g87 (CANON_PLANE_XZ, aa, (aa + k), bb,
N                    (bb + i), r, clear_cc, j, cc, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g87 (3, aa, (aa + k), bb, (bb + i), r, clear_cc, j, cc, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    break;
N            case G_88:
X            case 880:
N                CHK(((settings->motion_mode ISNT G_88) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G88);
X                if (((settings->motion_mode != 880) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 75; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g88 (CANON_PLANE_XZ, aa, bb, cc,
N                    block->p_number, settings->spindle_turning))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g88 (3, aa, bb, cc, block->p_number, settings->spindle_turning))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            case G_89:
X            case 890:
N                CHK(((settings->motion_mode ISNT G_89) AND (block->p_number IS -1.0)),
N                    NCE_DWELL_TIME_P_WORD_MISSING_WITH_G89);
X                if (((settings->motion_mode != 890) && (block->p_number == -1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 76; } else;
N                block->p_number SET_TO
X                block->p_number =
N                    block->p_number IS -1.0 ? settings->cycle_p : block->p_number;
X                    block->p_number == -1.0 ? settings->cycle_p : block->p_number;
N                CYCLE_MACRO(convert_cycle_g89 (CANON_PLANE_XZ, aa, bb, clear_cc, cc,
N                    block->p_number))
X                for (repeat = block->l_number; repeat > 0; repeat--) { aa = (aa + aa_increment); bb = (bb + bb_increment); cycle_traverse(plane, aa, bb, old_cc); if (old_cc != r) cycle_traverse(plane, aa, bb, r); if ((status = (convert_cycle_g89 (3, aa, bb, clear_cc, cc, block->p_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else; old_cc = clear_cc; }
N                    settings->cycle_p SET_TO block->p_number;
X                    settings->cycle_p = block->p_number;
N                break;
N            default:
N                ERM(NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        }
N        settings->current_z SET_TO aa;            /* CYCLE_MACRO updates aa and bb */
X        settings->current_z = aa;             
N        settings->current_x SET_TO bb;
X        settings->current_x = bb;
N        settings->current_y SET_TO clear_cc;
X        settings->current_y = clear_cc;
N        settings->cycle_cc SET_TO block->y_number;
X        settings->cycle_cc = block->y_number;
N
N        if (save_mode ISNT CANON_EXACT_PATH)
X        if (save_mode != 2)
N            SET_MOTION_CONTROL_MODE(save_mode);
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_distance_mode
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. g_code isn't G_90 or G_91: NCE_BUG_CODE_NOT_G90_OR_G91
N
N   Side effects:
N   The interpreter switches the machine settings to indicate the current
N   distance mode (absolute or incremental).
N
N   The canonical machine to which commands are being sent does not have
N   an incremental mode, so no command setting the distance mode is
N   generated in this function. A comment function call explaining the
N   change of mode is made (conditionally), however, if there is a change.
N
N   Called by: convert_g.
N
N   */
N
N    static int convert_distance_mode(             /* ARGUMENTS                             */
N    int g_code,                                   /* g_code being executed (must be G_90 or G_91) */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_distance_mode";
X        static char name[] = "convert_distance_mode";
N        if (g_code IS G_90)
X        if (g_code == 900)
N        {
N            if (settings->distance_mode ISNT MODE_ABSOLUTE)
X            if (settings->distance_mode != MODE_ABSOLUTE)
N            {
N#ifdef DEBUG_EMC
N                COMMENT("interpreter: distance mode changed to absolute");
N#endif
N                settings->distance_mode SET_TO MODE_ABSOLUTE;
X                settings->distance_mode = MODE_ABSOLUTE;
N            }
N        }
N        else if (g_code IS G_91)
X        else if (g_code == 910)
N        {
N            if (settings->distance_mode ISNT MODE_INCREMENTAL)
X            if (settings->distance_mode != MODE_INCREMENTAL)
N            {
N#ifdef DEBUG_EMC
N                COMMENT("interpreter: distance mode changed to incremental");
N#endif
N                settings->distance_mode SET_TO MODE_INCREMENTAL;
X                settings->distance_mode = MODE_INCREMENTAL;
N            }
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G90_OR_G91);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 25; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_dwell
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   A dwell command is executed.
N
N   Called by: convert_g.
N
N   */
N
N    static int convert_dwell(                     /* ARGUMENTS                 */
N    double time)                                  /* time in seconds to dwell  */
N    {
N        DWELL(time);
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_feed_mode
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1.  g_code isn't G_93 or G_94: NCE_BUG_CODE_NOT_G93_OR_G94
N
N   Side effects:
N   The interpreter switches the machine settings to indicate the current
N   feed mode (UNITS_PER_MINUTE or INVERSE_TIME).
N
N   The canonical machine to which commands are being sent does not have
N   a feed mode, so no command setting the distance mode is generated in
N   this function. A comment function call is made (conditionally)
N   explaining the change in mode, however.
N
N   Called by: execute_block.
N
N   */
N
N    static int convert_feed_mode(                 /* ARGUMENTS                                 */
N    int g_code,                                   /* g_code being executed (must be G_93 or G_94) */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_feed_mode";
X        static char name[] = "convert_feed_mode";
N        if (g_code IS G_93)
X        if (g_code == 930)
N        {
N#ifdef DEBUG_EMC
N            COMMENT("interpreter: feed mode set to inverse time");
N#endif
N            settings->feed_mode SET_TO INVERSE_TIME;
X            settings->feed_mode = 1;
N        }
N        else if (g_code IS G_94)
X        else if (g_code == 940)
N        {
N#ifdef DEBUG_EMC
N            COMMENT("interpreter: feed mode set to units per minute");
N#endif
N            settings->feed_mode SET_TO UNITS_PER_MINUTE;
X            settings->feed_mode = 0;
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G93_OR_G94);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 26; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_feed_rate
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The machine feed_rate is set to the value of f_number in the
N   block by function call.
N   The machine model feed_rate is set to that value.
N
N   Called by: execute_block
N
N   This is called only if the feed mode is UNITS_PER_MINUTE.
N
N   */
N
N    static int convert_feed_rate(                 /* ARGUMENTS                                */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        SET_FEED_RATE(block->f_number);
N        settings->feed_rate SET_TO block->f_number;
X        settings->feed_rate = block->f_number;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_g
N
N   Returned Value: int
N   If one of the following functions is called and returns an error code,
N   this returns that code.
N   convert_control_mode
N   convert_coordinate_system
N   convert_cutter_compensation
N   convert_distance_mode
N   convert_dwell
N   convert_length_units
N   convert_modal_0
N   convert_motion
N   convert_retract_mode
N   convert_set_plane
N   convert_tool_length_offset
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   Any g_codes in the block (excluding g93 and 94) and any implicit
N   motion g_code are executed.
N
N   Called by: execute_block.
N
N   This takes a pointer to a block of RS274/NGC instructions (already
N   read in) and creates the appropriate output commands corresponding to
N   any "g" codes in the block.
N
N   Codes g93 and g94, which set the feed mode, are executed earlier by
N   execute_block before reading the feed rate.
N
N   G codes are are executed in the following order.
N   1.  mode 0, G4 only - dwell. Left here from earlier versions.
N   2.  mode 2, one of (G17, G18, G19) - plane selection.
N   3.  mode 6, one of (G20, G21) - length units.
N   4.  mode 7, one of (G40, G41, G42) - cutter radius compensation.
N   5.  mode 8, one of (G43, G49) - tool length offset
N   6.  mode 12, one of (G54, G55, G56, G57, G58, G59, G59.1, G59.2, G59.3)
N   - coordinate system selection.
N   7.  mode 13, one of (G61, G61.1, G64) - control mode
N   8.  mode 3, one of (G90, G91) - distance mode.
N   9.  mode 10, one of (G98, G99) - retract mode.
N   10. mode 0, one of (G10, G28, G30, G92, G92.1, G92.2, G92.3) -
N   setting coordinate system locations, return to reference point 1,
N   return to reference point 2, setting or cancelling axis offsets.
N   11. mode 1, one of (G0, G1, G2, G3, G38.2, G80, G81 to G89) - motion or cancel.
N   G53 from mode 0 is also handled here, if present.
N
N   Some mode 0 and most mode 1 G codes must be executed after the length units
N   are set, since they use coordinate values. Mode 1 codes also must wait
N   until most of the other modes are set.
N
N   */
N
N    static int convert_g(                         /* ARGUMENTS                                    */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_g";
X        static char name[] = "convert_g";
N        int status;
N
N        if (block->g_modes[0] IS G_4)
X        if (block->g_modes[0] == 40)
N        {
N            CHP(convert_dwell(block->p_number));
X            if ((status = (convert_dwell(block->p_number))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[2] ISNT -1)
X        if (block->g_modes[2] != -1)
N        {
N            CHP(convert_set_plane(block->g_modes[2], settings));
X            if ((status = (convert_set_plane(block->g_modes[2], settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[6] ISNT -1)
X        if (block->g_modes[6] != -1)
N        {
N            CHP(convert_length_units(block->g_modes[6], settings));
X            if ((status = (convert_length_units(block->g_modes[6], settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[7] ISNT -1)
X        if (block->g_modes[7] != -1)
N        {
N            CHP(convert_cutter_compensation(block->g_modes[7], block, settings));
X            if ((status = (convert_cutter_compensation(block->g_modes[7], block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[8] ISNT -1)
X        if (block->g_modes[8] != -1)
N        {
N            CHP(convert_tool_length_offset(block->g_modes[8], block, settings));
X            if ((status = (convert_tool_length_offset(block->g_modes[8], block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[12] ISNT -1)
X        if (block->g_modes[12] != -1)
N        {
N            CHP(convert_coordinate_system(block->g_modes[12], settings));
X            if ((status = (convert_coordinate_system(block->g_modes[12], settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[13] ISNT -1)
X        if (block->g_modes[13] != -1)
N        {
N            CHP(convert_control_mode(block->g_modes[13], settings));
X            if ((status = (convert_control_mode(block->g_modes[13], settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[3] ISNT -1)
X        if (block->g_modes[3] != -1)
N        {
N            CHP(convert_distance_mode(block->g_modes[3], settings));
X            if ((status = (convert_distance_mode(block->g_modes[3], settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[10] ISNT -1)
X        if (block->g_modes[10] != -1)
N        {
N            CHP(convert_retract_mode(block->g_modes[10], settings));
X            if ((status = (convert_retract_mode(block->g_modes[10], settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[0] ISNT -1)
X        if (block->g_modes[0] != -1)
N        {
N            CHP(convert_modal_0(block->g_modes[0], block, settings));
X            if ((status = (convert_modal_0(block->g_modes[0], block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->motion_to_be ISNT -1)
X        if (block->motion_to_be != -1)
N        {
N            CHP(convert_motion(block->motion_to_be, block, settings));
X            if ((status = (convert_motion(block->motion_to_be, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_home
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. cutter radius compensation is on:
N   NCE_CANNOT_USE_G28_OR_G30_WITH_CUTTER_RADIUS_COMP
N   2. The code is not G28 or G30: NCE_BUG_CODE_NOT_G28_OR_G30
N
N   Side effects:
N   This executes a straight traverse to the programmed point, using
N   the current coordinate system, tool length offset, and motion mode
N   to interpret the coordinate values. Then it executes a straight
N   traverse to the location of reference point 1 (if G28) or reference
N   point 2 (if G30). It also updates the setting of the position of the
N   tool point to the end point of the move.
N
N   Called by: convert_modal_0.
N
N   During the motion from the intermediate point to the home point, this
N   function currently makes the A and C axes turn counterclockwise if a
N   turn is needed.  This is not necessarily the most efficient way to do
N   it. A check might be made of which direction to turn to have the least
N   turn to get to the reference position, and the axis would turn that
N   way.
N
N   */
N
N    static int convert_home(                      /* ARGUMENTS                                */
N    int move,                                     /* G code, must be G_28 or G_30             */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        static char name[] SET_TO "convert_home";
X        static char name[] = "convert_home";
N        double end_x;
N        double end_y;
N        double end_z;
N#ifdef AA
S        double AA_end;                            /*AA*/
N#endif
N#ifdef AA
S        double AA_end2;                           /*AA*/
N#endif
N#ifdef BB
S        double BB_end;                            /*BB*/
N#endif
N#ifdef BB
S        double BB_end2;                           /*BB*/
N#endif
N#ifdef CC
S        double CC_end;                            /*CC*/
N#endif
N#ifdef CC
S        double CC_end2;                           /*CC*/
N#endif
N        double * parameters;
N
N        parameters SET_TO settings->parameters;
X        parameters = settings->parameters;
N        find_ends(block, settings, &end_x, &end_y,
N            &end_z
N    #ifdef AA
S            , &AA_end
N    #endif
N
N    #ifdef BB
S            , &BB_end
N    #endif
N
N    #ifdef CC
S            , &CC_end
N    #endif
N            );
N
N        CHK((settings->cutter_comp_side ISNT OFF),
N            NCE_CANNOT_USE_G28_OR_G30_WITH_CUTTER_RADIUS_COMP);
X        if ((settings->cutter_comp_side != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 60; } else;
N        STRAIGHT_TRAVERSE(end_x, end_y, end_z
N    #ifdef AA
S            ,           AA_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef BB
S            ,  BB_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef CC
S            ,  CC_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N            );
N        if (move IS G_28)
X        if (move == 280)
N        {
N            find_relative
N                (parameters[5161], parameters[5162], parameters[5163],
N    #ifdef AA
S                parameters[5164],                 /*AA*/
N    #endif
N    #ifdef BB
S                parameters[5165],                 /*BB*/
N    #endif
N    #ifdef CC
S                parameters[5166],                 /*CC*/
N    #endif
N                &end_x, &end_y, &end_z
N    #ifdef AA
S                , &AA_end2
N    #endif
N
N    #ifdef BB
S                , &BB_end2
N    #endif
N
N    #ifdef CC
S                , &CC_end2
N    #endif
N                , settings);
N        }
N        else if (move IS G_30)
X        else if (move == 300)
N        {
N            find_relative
N                (parameters[5181], parameters[5182], parameters[5183],
N    #ifdef AA
S                parameters[5184],                 /*AA*/
N    #endif
N    #ifdef BB
S                parameters[5185],                 /*BB*/
N    #endif
N    #ifdef CC
S                parameters[5186],                 /*CC*/
N    #endif
N                &end_x, &end_y, &end_z
N    #ifdef AA
S                , &AA_end2
N    #endif
N
N    #ifdef BB
S                , &BB_end2
N    #endif
N
N    #ifdef CC
S                , &CC_end2
N    #endif
N                , settings);
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G28_OR_G30);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 19; } else;
N        STRAIGHT_TRAVERSE(end_x, end_y, end_z
N    #ifdef AA
S            ,           AA_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef BB
S            ,  BB_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef CC
S            ,  CC_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N            );
N        settings->current_x SET_TO end_x;
X        settings->current_x = end_x;
N        settings->current_y SET_TO end_y;
X        settings->current_y = end_y;
N        settings->current_z SET_TO end_z;
X        settings->current_z = end_z;
N#ifdef AA
S        settings->AA_current SET_TO AA_end2;      /*AA*/
N#endif
N#ifdef BB
S        settings->BB_current SET_TO BB_end2;      /*BB*/
N#endif
N#ifdef CC
S        settings->CC_current SET_TO CC_end2;      /*CC*/
N#endif
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_length_units
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The g_code argument isnt G_20 or G_21:
N   NCE_BUG_CODE_NOT_G20_OR_G21
N   2. Cutter radius compensation is on:
N   NCE_CANNOT_CHANGE_UNITS_WITH_CUTTER_RADIUS_COMP
N
N   Side effects:
N   A command setting the length units is executed. The machine
N   settings are reset regarding length units and current position.
N
N   Called by: convert_g.
N
N   We are not changing tool length offset values or tool diameter values.
N   Those values must be given in the table in the correct units. Thus it
N   will generally not be feasible to switch units in the middle of a
N   program.
N
N   We are not changing the parameters that represent the positions
N   of the nine work coordinate systems.
N
N   We are also not changing feed rate values when length units are
N   changed, so the actual behavior may change.
N
N   Several other distance items in the settings (such as the various
N   parameters for cycles) are also not reset.
N
N   We are changing origin offset and axis offset values, which are
N   critical. If this were not done, when length units are set and the new
N   length units are not the same as the default length units
N   (millimeters), and any XYZ origin or axis offset is not zero, then any
N   subsequent change in XYZ origin or axis offset values will be
N   incorrect.  Also, g53 (motion in absolute coordinates) will not work
N   correctly.
N
N   */
N
N    static int convert_length_units(              /* ARGUMENTS                             */
N    int g_code,                                   /* g_code being executed (must be G_20 or G_21) */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_length_units";
X        static char name[] = "convert_length_units";
N        CHK((settings->cutter_comp_side ISNT OFF),
N            NCE_CANNOT_CHANGE_UNITS_WITH_CUTTER_RADIUS_COMP);
X        if ((settings->cutter_comp_side != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 39; } else;
N        if (g_code IS G_20)
X        if (g_code == 200)
N        {
N            USE_LENGTH_UNITS(CANON_UNITS_INCHES);
X            USE_LENGTH_UNITS(1);
N            if (settings->length_units ISNT CANON_UNITS_INCHES)
X            if (settings->length_units != 1)
N            {
N                settings->length_units SET_TO CANON_UNITS_INCHES;
X                settings->length_units = 1;
N                settings->current_x SET_TO (settings->current_x * INCH_PER_MM);
X                settings->current_x = (settings->current_x * 0.039370078740157477);
N                settings->current_y SET_TO (settings->current_y * INCH_PER_MM);
X                settings->current_y = (settings->current_y * 0.039370078740157477);
N                settings->current_z SET_TO (settings->current_z * INCH_PER_MM);
X                settings->current_z = (settings->current_z * 0.039370078740157477);
N                settings->axis_offset_x SET_TO
X                settings->axis_offset_x =
N                    (settings->axis_offset_x * INCH_PER_MM);
X                    (settings->axis_offset_x * 0.039370078740157477);
N                settings->axis_offset_y SET_TO
X                settings->axis_offset_y =
N                    (settings->axis_offset_y * INCH_PER_MM);
X                    (settings->axis_offset_y * 0.039370078740157477);
N                settings->axis_offset_z SET_TO
X                settings->axis_offset_z =
N                    (settings->axis_offset_z * INCH_PER_MM);
X                    (settings->axis_offset_z * 0.039370078740157477);
N                settings->origin_offset_x SET_TO
X                settings->origin_offset_x =
N                    (settings->origin_offset_x * INCH_PER_MM);
X                    (settings->origin_offset_x * 0.039370078740157477);
N                settings->origin_offset_y SET_TO
X                settings->origin_offset_y =
N                    (settings->origin_offset_y * INCH_PER_MM);
X                    (settings->origin_offset_y * 0.039370078740157477);
N                settings->origin_offset_z SET_TO
X                settings->origin_offset_z =
N                    (settings->origin_offset_z * INCH_PER_MM);
X                    (settings->origin_offset_z * 0.039370078740157477);
N            }
N        }
N        else if (g_code IS G_21)
X        else if (g_code == 210)
N        {
N            USE_LENGTH_UNITS(CANON_UNITS_MM);
X            USE_LENGTH_UNITS(2);
N            if (settings->length_units ISNT CANON_UNITS_MM)
X            if (settings->length_units != 2)
N            {
N                settings->length_units SET_TO CANON_UNITS_MM;
X                settings->length_units = 2;
N                settings->current_x SET_TO (settings->current_x * MM_PER_INCH);
X                settings->current_x = (settings->current_x * 25.4);
N                settings->current_y SET_TO (settings->current_y * MM_PER_INCH);
X                settings->current_y = (settings->current_y * 25.4);
N                settings->current_z SET_TO (settings->current_z * MM_PER_INCH);
X                settings->current_z = (settings->current_z * 25.4);
N                settings->axis_offset_x SET_TO
X                settings->axis_offset_x =
N                    (settings->axis_offset_x * MM_PER_INCH);
X                    (settings->axis_offset_x * 25.4);
N                settings->axis_offset_y SET_TO
X                settings->axis_offset_y =
N                    (settings->axis_offset_y * MM_PER_INCH);
X                    (settings->axis_offset_y * 25.4);
N                settings->axis_offset_z SET_TO
X                settings->axis_offset_z =
N                    (settings->axis_offset_z * MM_PER_INCH);
X                    (settings->axis_offset_z * 25.4);
N                settings->origin_offset_x SET_TO
X                settings->origin_offset_x =
N                    (settings->origin_offset_x * MM_PER_INCH);
X                    (settings->origin_offset_x * 25.4);
N                settings->origin_offset_y SET_TO
X                settings->origin_offset_y =
N                    (settings->origin_offset_y * MM_PER_INCH);
X                    (settings->origin_offset_y * 25.4);
N                settings->origin_offset_z SET_TO
X                settings->origin_offset_z =
N                    (settings->origin_offset_z * MM_PER_INCH);
X                    (settings->origin_offset_z * 25.4);
N            }
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G20_OR_G21);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 18; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_m
N
N   Returned Value: int
N   If convert_tool_change returns an error code, this returns that code.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   m_codes in the block are executed. For each m_code
N   this consists of making a function call(s) to a canonical machining
N   function(s) and setting the machine model.
N
N   Called by: execute_block.
N
N   This handles four separate types of activity in order:
N   1. changing the tool (m6) - which also retracts and stops the spindle.
N   2. Turning the spindle on or off (m3, m4, and m5)
N   3. Turning coolant on and off (m7, m8, and m9)
N   4. turning a-axis clamping on and off (m26, m27) - commented out.
N   5. enabling or disabling feed and speed overrides (m49, m49).
N   Within each group, only the first code encountered will be executed.
N
N   This does nothing with m0, m1, m2, m30, or m60 (which are handled in
N   convert_stop).
N
N   */
N
N    static int convert_m(                         /* ARGUMENTS                                    */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_m";
X        static char name[] = "convert_m";
N        int status;
N
N        if (block->m_modes[6] ISNT -1)
X        if (block->m_modes[6] != -1)
N        {
N            CHP(convert_tool_change(settings));
X            if ((status = (convert_tool_change(settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N
N        if (block->m_modes[7] IS 3)
X        if (block->m_modes[7] == 3)
N        {
N            START_SPINDLE_CLOCKWISE();
N            settings->spindle_turning SET_TO CANON_CLOCKWISE;
X            settings->spindle_turning = 2;
N        }
N        else if (block->m_modes[7] IS 4)
X        else if (block->m_modes[7] == 4)
N        {
N            START_SPINDLE_COUNTERCLOCKWISE();
N            settings->spindle_turning SET_TO CANON_COUNTERCLOCKWISE;
X            settings->spindle_turning = 3;
N        }
N        else if (block->m_modes[7] IS 5)
X        else if (block->m_modes[7] == 5)
N        {
N            STOP_SPINDLE_TURNING();
N            settings->spindle_turning SET_TO CANON_STOPPED;
X            settings->spindle_turning = 1;
N        }
N
N        if (block->m_modes[8] IS 7)
X        if (block->m_modes[8] == 7)
N        {
N            MIST_ON();
N            settings->mist SET_TO ON;
X            settings->mist = 1;
N        }
N        else if (block->m_modes[8] IS 8)
X        else if (block->m_modes[8] == 8)
N        {
N            FLOOD_ON();
N            settings->flood SET_TO ON;
X            settings->flood = 1;
N        }
N        else if (block->m_modes[8] IS 9)
X        else if (block->m_modes[8] == 9)
N        {
N            MIST_OFF();
N            settings->mist SET_TO OFF;
X            settings->mist = 0;
N            FLOOD_OFF();
N            settings->flood SET_TO OFF;
X            settings->flood = 0;
N        }
N
N   /* No axis clamps in this version
N     if (block->m_modes[2] IS 26)
N       {
N   #ifdef DEBUG_EMC
N   COMMENT("interpreter: automatic A-axis clamping turned on");
N   #endif
N   settings->a_axis_clamping SET_TO ON;
N   }
N   else if (block->m_modes[2] IS 27)
N   {
N   #ifdef DEBUG_EMC
N   COMMENT("interpreter: automatic A-axis clamping turned off");
N   #endif
N   settings->a_axis_clamping SET_TO OFF;
N   }
N   */
N
N        if (block->m_modes[9] IS 48)
X        if (block->m_modes[9] == 48)
N        {
N            ENABLE_FEED_OVERRIDE();
N            ENABLE_SPEED_OVERRIDE();
N            settings->feed_override SET_TO ON;
X            settings->feed_override = 1;
N            settings->speed_override SET_TO ON;
X            settings->speed_override = 1;
N        }
N        else if (block->m_modes[9] IS 49)
X        else if (block->m_modes[9] == 49)
N        {
N            DISABLE_FEED_OVERRIDE();
N            DISABLE_SPEED_OVERRIDE();
N            settings->feed_override SET_TO OFF;
X            settings->feed_override = 0;
N            settings->speed_override SET_TO OFF;
X            settings->speed_override = 0;
N        }
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_modal_0
N
N   Returned Value: int
N   If one of the following functions is called and returns an error code,
N   this returns that code.
N   convert_axis_offsets
N   convert_home
N   convert_setup
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. code is not G_4, G_10, G_28, G_30, G_53, G92, G_92_1, G_92_2, or G_92_3:
N   NCE_BUG_CODE_NOT_G4_G10_G28_G30_G53_OR_G92_SERIES
N
N   Side effects: See below
N
N   Called by: convert_g
N
N   If the g_code is g10, g28, g30, g92, g92.1, g92.2, or g92.3 (all are in
N   modal group 0), it is executed. The other two in modal group 0 (G4 and
N   G53) are executed elsewhere.
N
N   */
N
N    static int convert_modal_0(                   /* ARGUMENTS                                    */
N    int code,                                     /* G code, must be from group 0                 */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_modal_0";
X        static char name[] = "convert_modal_0";
N        int status;
N
N        if (code IS G_10)
X        if (code == 100)
N        {
N            CHP(convert_setup(block, settings));
X            if ((status = (convert_setup(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if ((code IS G_28) OR (code IS G_30))
X        else if ((code == 280) || (code == 300))
N        {
N            CHP(convert_home(code, block, settings));
X            if ((status = (convert_home(code, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if ((code IS G_92)   OR (code IS G_92_1) OR
X        else if ((code == 920)   || (code == 921) ||
N            (code IS G_92_2) OR (code IS G_92_3))
X            (code == 922) || (code == 923))
N        {
N            CHP(convert_axis_offsets(code, block, settings));
X            if ((status = (convert_axis_offsets(code, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if ((code IS G_4) OR (code IS G_53));/* handled elsewhere */
X        else if ((code == 40) || (code == 530)); 
N        else
N            ERM(NCE_BUG_CODE_NOT_G4_G10_G28_G30_G53_OR_G92_SERIES);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 23; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_motion
N
N   Returned Value: int
N   If one of the following functions is called and returns an error code,
N   this returns that code.
N   convert_arc
N   convert_cycle
N   convert_probe
N   convert_straight
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The motion code is not 0,1,2,3,38.2,80,81,82,83,84,85,86,87, 88, or 89:
N   NCE_BUG_UNKNOWN_MOTION_CODE
N
N   Side effects:
N   A g_code from the group causing motion (mode 1) is executed.
N
N   Called by: convert_g.
N
N   */
N
N    static int convert_motion(                    /* ARGUMENTS                                 */
N    int motion,                                   /* g_code for a line, arc, canned cycle      */
N    block_pointer block,                          /* pointer to a block of RS274 instructions  */
N    setup_pointer settings)                       /* pointer to machine settings               */
N    {
N        static char name[] SET_TO "convert_motion";
X        static char name[] = "convert_motion";
N        int status;
N
N        if ((motion IS G_0) OR (motion IS G_1))
X        if ((motion == 0) || (motion == 10))
N        {
N            CHP(convert_straight(motion, block, settings));
X            if ((status = (convert_straight(motion, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if ((motion IS G_3) OR (motion IS G_2))
X        else if ((motion == 30) || (motion == 20))
N        {
N            CHP(convert_arc(motion, block, settings));
X            if ((status = (convert_arc(motion, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if (motion IS G_38_2)
X        else if (motion == 382)
N        {
N            CHP(convert_probe(block, settings));
X            if ((status = (convert_probe(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else if (motion IS G_80)
X        else if (motion == 800)
N        {
N#ifdef DEBUG_EMC
N            COMMENT("interpreter: motion mode set to none");
N#endif
N            settings->motion_mode SET_TO G_80;
X            settings->motion_mode = 800;
N        }
N        else if ((motion > G_80) AND (motion < G_90))
X        else if ((motion > 800) && (motion < 900))
N        {
N            CHP(convert_cycle(motion, block, settings));
X            if ((status = (convert_cycle(motion, block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        else
N            ERM(NCE_BUG_UNKNOWN_MOTION_CODE);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 36; } else;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_probe
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. No value is given in the block for any of X, Y, or Z:
N   NCE_X_Y_AND_Z_WORDS_ALL_MISSING_WITH_G38_2
N   2. feed mode is inverse time: NCE_CANNOT_PROBE_IN_INVERSE_TIME_FEED_MODE
N   3. cutter radius comp is on: NCE_CANNOT_PROBE_WITH_CUTTER_RADIUS_COMP_ON
N   4. Feed rate is zero: NCE_CANNOT_PROBE_WITH_ZERO_FEED_RATE
N   5. Rotary axis motion is programmed:
N   NCE_CANNOT_MOVE_ROTARY_AXES_DURING_PROBING
N   6. The starting point for the probe move is within 0.01 inch or 0.254
N   millimeters of the point to be probed:
N   NCE_START_POINT_TOO_CLOSE_TO_PROBE_POINT
N
N   Side effects:
N   This executes a straight_probe command.
N   The probe_flag in the settings is set to ON.
N   The motion mode in the settings is set to G_38_2.
N
N   Called by: convert_motion.
N
N   The approach to operating in incremental distance mode (g91) is to
N   put the the absolute position values into the block before using the
N   block to generate a move.
N
N   After probing is performed, the location of the probe cannot be
N   predicted. This differs from every other command, all of which have
N   predictable results. The next call to the interpreter (with either
N   rs274ngc_read or rs274ngc_execute) will result in updating the
N   current position by calls to get_external_position_x, etc.
N
N   */
N
N    static int convert_probe(                     /* ARGUMENTS                                */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        static char name[] SET_TO "convert_probe";
X        static char name[] = "convert_probe";
N        double distance;
N        double end_x;
N        double end_y;
N        double end_z;
N#ifdef AA
S        double AA_end;                            /*AA*/
N#endif
N#ifdef BB
S        double BB_end;                            /*BB*/
N#endif
N#ifdef CC
S        double CC_end;                            /*CC*/
N#endif
N
N        CHK((((block->x_flag IS OFF) AND (block->y_flag IS OFF)) AND
N            (block->z_flag IS OFF)), NCE_X_Y_AND_Z_WORDS_ALL_MISSING_WITH_G38_2);
X        if ((((block->x_flag == 0) && (block->y_flag == 0)) && (block->z_flag == 0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 192; } else;
N        CHK((settings->feed_mode IS INVERSE_TIME),
N            NCE_CANNOT_PROBE_IN_INVERSE_TIME_FEED_MODE);
X        if ((settings->feed_mode == 1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 47; } else;
N        CHK((settings->cutter_comp_side ISNT OFF),
N            NCE_CANNOT_PROBE_WITH_CUTTER_RADIUS_COMP_ON);
X        if ((settings->cutter_comp_side != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 48; } else;
N        CHK((settings->feed_rate IS 0.0), NCE_CANNOT_PROBE_WITH_ZERO_FEED_RATE);
X        if ((settings->feed_rate == 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 49; } else;
N        find_ends(block, settings, &end_x, &end_y,
N            &end_z
N    #ifdef AA
S            , &AA_end
N    #endif
N
N    #ifdef BB
S            , &BB_end
N    #endif
N
N    #ifdef CC
S            , &CC_end
N    #endif
N            );
N        if (0
N    #ifdef AA
S            OR (AA_end ISNT settings->AA_current) /*AA*/
N    #endif
N    #ifdef BB
S            OR (BB_end ISNT settings->BB_current) /*BB*/
N    #endif
N    #ifdef CC
S            OR (CC_end ISNT settings->CC_current) /*CC*/
N    #endif
N            )
N            ERM(NCE_CANNOT_MOVE_ROTARY_AXES_DURING_PROBING);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 44; } else;
N        distance SET_TO sqrt(pow((settings->current_x - end_x), 2) +
X        distance = sqrt(pow((settings->current_x - end_x), 2) +
N            pow((settings->current_y - end_y), 2) +
N            pow((settings->current_z - end_z), 2));
N        CHK((distance < ((settings->length_units IS CANON_UNITS_MM) ? 0.254 : 0.01)),
N            NCE_START_POINT_TOO_CLOSE_TO_PROBE_POINT);
X        if ((distance < ((settings->length_units == 2) ? 0.254 : 0.01))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 162; } else;
N        TURN_PROBE_ON();
N        STRAIGHT_PROBE(end_x, end_y, end_z
N    #ifdef AA
S            ,        AA_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef BB
S            ,  BB_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef CC
S            ,  CC_end
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N            );
N        TURN_PROBE_OFF();
N        settings->motion_mode SET_TO G_38_2;
X        settings->motion_mode = 382;
N        settings->probe_flag SET_TO ON;
X        settings->probe_flag = 1;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_retract_mode
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. g_code isn't G_98 or G_99: NCE_BUG_CODE_NOT_G98_OR_G99
N
N   Side effects:
N   The interpreter switches the machine settings to indicate the current
N   retract mode for canned cycles (OLD_Z or R_PLANE).
N
N   Called by: convert_g.
N
N   The canonical machine to which commands are being sent does not have a
N   retract mode, so no command setting the retract mode is generated in
N   this function.
N
N   */
N
N    static int convert_retract_mode(              /* ARGUMENTS                             */
N    int g_code,                                   /* g_code being executed (must be G_98 or G_99) */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_retract_mode";
X        static char name[] = "convert_retract_mode";
N        if (g_code IS G_98)
X        if (g_code == 980)
N        {
N#ifdef DEBUG_EMC
N            COMMENT("interpreter: retract mode set to old_z");
N#endif
N            settings->retract_mode SET_TO OLD_Z;
X            settings->retract_mode = OLD_Z;
N        }
N        else if (g_code IS G_99)
X        else if (g_code == 990)
N        {
N#ifdef DEBUG_EMC
N            COMMENT("interpreter: retract mode set to r_plane");
N#endif
N            settings->retract_mode SET_TO R_PLANE;
X            settings->retract_mode = R_PLANE;
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G98_OR_G99);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 27; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_setup
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   SET_PROGRAM_ORIGIN is called, and the coordinate
N   values for the program origin are reset.
N   If the program origin is currently in use, the values of the
N   the coordinates of the current point are updated.
N
N   Called by: convert_modal_0.
N
N   This is called only if g10 is called. g10 L2 may be used to alter the
N   location of coordinate systems as described in [NCMS, pages 9 - 10] and
N   [Fanuc, page 65]. [Fanuc] has only six coordinate systems, while
N   [NCMS] has nine (the first six of which are the same as the six [Fanuc]
N   has). All nine are implemented here.
N
N   Being in incremental distance mode has no effect on the action of G10
N   in this implementation. The manual is not explicit about what is
N   intended.
N
N   See documentation of convert_coordinate_system for more information.
N
N   */
N
N    static int convert_setup(                     /* ARGUMENTS                                    */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_setup";
X        static char name[] = "convert_setup";
N        double x;
N        double y;
N        double z;
N#ifdef AA
S        double a;                                 /*AA*/
N#endif
N#ifdef BB
S        double b;                                 /*BB*/
N#endif
N#ifdef CC
S        double c;                                 /*CC*/
N#endif
N        double * parameters;
N        int p_int;
N
N        parameters SET_TO settings->parameters;
X        parameters = settings->parameters;
N        p_int SET_TO (int)(block->p_number + 0.0001);
X        p_int = (int)(block->p_number + 0.0001);
N
N        if (block->x_flag IS ON)
X        if (block->x_flag == 1)
N        {
N            x SET_TO block->x_number;
X            x = block->x_number;
N            parameters[5201 + (p_int * 20)] SET_TO x;
X            parameters[5201 + (p_int * 20)] = x;
N        }
N        else
N            x SET_TO parameters[5201 + (p_int * 20)];
X            x = parameters[5201 + (p_int * 20)];
N
N        if (block->y_flag IS ON)
X        if (block->y_flag == 1)
N        {
N            y SET_TO block->y_number;
X            y = block->y_number;
N            parameters[5202 + (p_int * 20)] SET_TO y;
X            parameters[5202 + (p_int * 20)] = y;
N        }
N        else
N            y SET_TO parameters[5202 + (p_int * 20)];
X            y = parameters[5202 + (p_int * 20)];
N        if (block->z_flag IS ON)
X        if (block->z_flag == 1)
N        {
N            z SET_TO block->z_number;
X            z = block->z_number;
N            parameters[5203 + (p_int * 20)] SET_TO z;
X            parameters[5203 + (p_int * 20)] = z;
N        }
N        else
N            z SET_TO parameters[5203 + (p_int * 20)];
X            z = parameters[5203 + (p_int * 20)];
N
N#ifdef AA
S        if (block->a_flag IS ON)
S        {
S            a SET_TO block->a_number;
S            parameters[5204 + (p_int * 20)] SET_TO a;
S        }
S        else
S            a SET_TO parameters[5204 + (p_int * 20)];
N#endif
N
N#ifdef BB
S        if (block->b_flag IS ON)
S        {
S            b SET_TO block->b_number;
S            parameters[5205 + (p_int * 20)] SET_TO b;
S        }
S        else
S            b SET_TO parameters[5205 + (p_int * 20)];
N#endif
N
N#ifdef CC
S        if (block->c_flag IS ON)
S        {
S            c SET_TO block->c_number;
S            parameters[5206 + (p_int * 20)] SET_TO c;
S        }
S        else
S            c SET_TO parameters[5206 + (p_int * 20)];
N#endif
N
N   /* axis offsets could be included in the two sets of calculations for
N      current_x, current_y, etc., but do not need to be because the results
N      would be the same. They would be added in then subtracted out. */
N        if (p_int IS settings->origin_index)      /* system is currently used */
X        if (p_int == settings->origin_index)       
N        {
N            settings->current_x SET_TO
X            settings->current_x =
N                (settings->current_x + settings->origin_offset_x);
N            settings->current_y SET_TO
X            settings->current_y =
N                (settings->current_y + settings->origin_offset_y);
N            settings->current_z SET_TO
X            settings->current_z =
N                (settings->current_z + settings->origin_offset_z);
N#ifdef AA
S            settings->AA_current SET_TO           /*AA*/
N    #endif
N    #ifdef AA
S   /*AA*/
S                (settings->AA_current + settings->AA_origin_offset);
N#endif
N#ifdef BB
S            settings->BB_current SET_TO           /*BB*/
N    #endif
N    #ifdef BB
S   /*BB*/
S                (settings->BB_current + settings->BB_origin_offset);
N#endif
N#ifdef CC
S            settings->CC_current SET_TO           /*CC*/
N    #endif
N    #ifdef CC
S   /*CC*/
S                (settings->CC_current + settings->CC_origin_offset);
N#endif
N
N            settings->origin_offset_x SET_TO x;
X            settings->origin_offset_x = x;
N            settings->origin_offset_y SET_TO y;
X            settings->origin_offset_y = y;
N            settings->origin_offset_z SET_TO z;
X            settings->origin_offset_z = z;
N#ifdef AA
S            settings->AA_origin_offset SET_TO a;  /*AA*/
N#endif
N#ifdef BB
S            settings->BB_origin_offset SET_TO b;  /*BB*/
N#endif
N#ifdef CC
S            settings->CC_origin_offset SET_TO c;  /*CC*/
N#endif
N
N            settings->current_x SET_TO (settings->current_x - x);
X            settings->current_x = (settings->current_x - x);
N            settings->current_y SET_TO (settings->current_y - y);
X            settings->current_y = (settings->current_y - y);
N            settings->current_z SET_TO (settings->current_z - z);
X            settings->current_z = (settings->current_z - z);
N#ifdef AA
S   /*AA*/
S            settings->AA_current SET_TO (settings->AA_current - a);
N#endif
N#ifdef BB
S   /*BB*/
S            settings->BB_current SET_TO (settings->BB_current - b);
N#endif
N#ifdef CC
S   /*CC*/
S            settings->CC_current SET_TO (settings->CC_current - c);
N#endif
N
N            SET_ORIGIN_OFFSETS(x + settings->axis_offset_x,
N                y + settings->axis_offset_y,
N                z + settings->axis_offset_z
N    #ifdef AA
S                ,            a + settings->AA_axis_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,            b + settings->BB_axis_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,            c + settings->CC_axis_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N        }
N#ifdef DEBUG_EMC
N        else
N            COMMENT("interpreter: setting coordinate system origin");
N#endif
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 5674 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* convert_set_plane
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. G_18 or G_19 is called when cutter radius compensation is on:
N   NCE_CANNOT_USE_XZ_PLANE_WITH_CUTTER_RADIUS_COMP
N   NCE_CANNOT_USE_YZ_PLANE_WITH_CUTTER_RADIUS_COMP
N   2. The g_code is not G_17, G_18, or G_19:
N   NCE_BUG_CODE_NOT_G17_G18_OR_G19
N
N   Side effects:
N   A canonical command setting the current plane is executed.
N
N   Called by: convert_g.
N
N   */
N
N    static int convert_set_plane(                 /* ARGUMENTS                    */
N    int g_code,                                   /* must be G_17, G_18, or G_19  */
N    setup_pointer settings)                       /* pointer to machine settings  */
N    {
N        static char name[] SET_TO "convert_set_plane";
X        static char name[] = "convert_set_plane";
N        if (g_code IS G_17)
X        if (g_code == 170)
N        {
N            SELECT_PLANE(CANON_PLANE_XY);
X            SELECT_PLANE(1);
N            settings->plane SET_TO CANON_PLANE_XY;
X            settings->plane = 1;
N        }
N        else if (g_code IS G_18)
X        else if (g_code == 180)
N        {
N            CHK((settings->cutter_comp_side ISNT OFF),
N                NCE_CANNOT_USE_XZ_PLANE_WITH_CUTTER_RADIUS_COMP);
X            if ((settings->cutter_comp_side != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 64; } else;
N            SELECT_PLANE(CANON_PLANE_XZ);
X            SELECT_PLANE(3);
N            settings->plane SET_TO CANON_PLANE_XZ;
X            settings->plane = 3;
N        }
N        else if (g_code IS G_19)
X        else if (g_code == 190)
N        {
N            CHK((settings->cutter_comp_side ISNT OFF),
N                NCE_CANNOT_USE_YZ_PLANE_WITH_CUTTER_RADIUS_COMP);
X            if ((settings->cutter_comp_side != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 65; } else;
N            SELECT_PLANE(CANON_PLANE_YZ);
X            SELECT_PLANE(2);
N            settings->plane SET_TO CANON_PLANE_YZ;
X            settings->plane = 2;
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G17_G18_OR_G19);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 17; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_speed
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The machine spindle speed is set to the value of s_number in the
N   block by a call to SET_SPINDLE_SPEED.
N   The machine model for spindle speed is set to that value.
N
N   Called by: execute_block.
N
N   */
N
N    static int convert_speed(                     /* ARGUMENTS                                */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        SET_SPINDLE_SPEED(block->s_number);
N        settings->speed SET_TO block->s_number;
X        settings->speed = block->s_number;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_stop
N
N   Returned Value: int
N   When an m2 or m30 (program_end) is encountered, this returns RS274NGC_EXIT.
N   If the code is not m0, m1, m2, m30, or m60, this returns
N   NCE_BUG_CODE_NOT_M0_M1_M2_M30_M60
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   An m0, m1, m2, m30, or m60 in the block is executed.
N
N   For m0, m1, and m60, this makes a function call to the PROGRAM_STOP
N   canonical machining function (which stops program execution).
N   In addition, m60 calls PALLET_SHUTTLE.
N
N   For m2 and m30, this resets the machine and then calls PROGRAM_END.
N   In addition, m30 calls PALLET_SHUTTLE.
N
N   Called by: execute_block.
N
N   This handles stopping or ending the program (m0, m1, m2, m30, m60)
N
N   [NCMS] specifies how the following modes should be reset at m2 or
N   m30. The descriptions are not collected in one place, so this list
N   may be incomplete.
N
N   G52 offsetting coordinate zero points [NCMS, page 10]
N   G92 coordinate offset using tool position [NCMS, page 10]
N
N   The following should have reset values, but no description of reset
N   behavior could be found in [NCMS].
N   G17, G18, G19 selected plane [NCMS, pages 14, 20]
N   G90, G91 distance mode [NCMS, page 15]
N   G93, G94 feed mode [NCMS, pages 35 - 37]
N   M48, M49 overrides enabled, disabled [NCMS, pages 37 - 38]
N   M3, M4, M5 spindle turning [NCMS, page 7]
N
N   The following should be set to some value at machine start-up but
N   not automatically reset by any of the stopping codes.
N   1. G20, G21 length units [NCMS, page 15]. This is up to the installer.
N   2. motion_control_mode. This is set in rs274ngc_init but not reset here.
N   Might add it here.
N
N   The following resets have been added by calling the appropriate
N   canonical machining command and/or by resetting interpreter
N   settings. They occur on M2 or M30.
N
N   1. Axis offsets are set to zero (like g92.2) and      - SET_ORIGIN_OFFSETS
N   origin offsets are set to the default (like G54)
N   2. Selected plane is set to CANON_PLANE_XY (like G17) - SELECT_PLANE
N   3. Distance mode is set to MODE_ABSOLUTE (like G90)   - no canonical call
N   4. Feed mode is set to UNITS_PER_MINUTE (like G94)    - no canonical call
N   5. Feed and speed overrides are set to ON (like M48)  - ENABLE_FEED_OVERRIDE
N   - ENABLE_SPEED_OVERRIDE
N   6. Cutter compensation is turned off (like G40)       - no canonical call
N   7. The spindle is stopped (like M5)                   - STOP_SPINDLE_TURNING
N   8. The motion mode is set to G_1 (like G1)            - no canonical call
N   9. Coolant is turned off (like M9)                    - FLOOD_OFF & MIST_OFF
N
N   */
N
N    static int convert_stop(                      /* ARGUMENTS                                    */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_stop";
X        static char name[] = "convert_stop";
N        int index;
N        char * line;
N        int length;
N
N        if (block->m_modes[4] IS 0)
X        if (block->m_modes[4] == 0)
N        {
N            PROGRAM_STOP();
N        }
N        else if (block->m_modes[4] IS 60)
X        else if (block->m_modes[4] == 60)
N        {
N            PALLET_SHUTTLE();
N            PROGRAM_STOP();
N        }
N        else if (block->m_modes[4] IS 1)
X        else if (block->m_modes[4] == 1)
N        {
N            OPTIONAL_PROGRAM_STOP();
N        }
N        else if ((block->m_modes[4] IS 2) OR (block->m_modes[4] IS 30))
X        else if ((block->m_modes[4] == 2) || (block->m_modes[4] == 30))
N        {                                         /* reset stuff here */
N   /*1*/
N            settings->current_x SET_TO settings->current_x
X            settings->current_x = settings->current_x
N                + settings->origin_offset_x + settings->axis_offset_x;
N            settings->current_y SET_TO settings->current_y
X            settings->current_y = settings->current_y
N                + settings->origin_offset_y + settings->axis_offset_y;
N            settings->current_z SET_TO settings->current_z
X            settings->current_z = settings->current_z
N                + settings->origin_offset_z + settings->axis_offset_z;
N#ifdef AA
S   /*AA*/
S            settings->AA_current SET_TO settings->AA_current
N    #endif
N    #ifdef AA
S   /*AA*/
S                + settings->AA_origin_offset + settings->AA_axis_offset;
N#endif
N#ifdef BB
S   /*BB*/
S            settings->BB_current SET_TO settings->BB_current
N    #endif
N    #ifdef BB
S   /*BB*/
S                + settings->BB_origin_offset + settings->BB_axis_offset;
N#endif
N#ifdef CC
S   /*CC*/
S            settings->CC_current SET_TO settings->CC_current
N    #endif
N    #ifdef CC
S   /*CC*/
S                + settings->CC_origin_offset + settings->CC_axis_offset;
N#endif
N
N            settings->origin_index SET_TO 1;
X            settings->origin_index = 1;
N            settings->parameters[5220] SET_TO 1.0;
X            settings->parameters[5220] = 1.0;
N            settings->origin_offset_x SET_TO settings->parameters[5221];
X            settings->origin_offset_x = settings->parameters[5221];
N            settings->origin_offset_y SET_TO settings->parameters[5222];
X            settings->origin_offset_y = settings->parameters[5222];
N            settings->origin_offset_z SET_TO settings->parameters[5223];
X            settings->origin_offset_z = settings->parameters[5223];
N#ifdef AA
S   /*AA*/
S            settings->AA_origin_offset SET_TO settings->parameters[5224];
N#endif
N#ifdef BB
S   /*BB*/
S            settings->BB_origin_offset SET_TO settings->parameters[5225];
N#endif
N#ifdef CC
S   /*CC*/
S            settings->CC_origin_offset SET_TO settings->parameters[5226];
N#endif
N
N            settings->axis_offset_x SET_TO 0;
X            settings->axis_offset_x = 0;
N            settings->axis_offset_x SET_TO 0;
X            settings->axis_offset_x = 0;
N            settings->axis_offset_x SET_TO 0;
X            settings->axis_offset_x = 0;
N#ifdef AA
S            settings->AA_axis_offset SET_TO 0;    /*AA*/
N#endif
N#ifdef BB
S            settings->BB_axis_offset SET_TO 0;    /*BB*/
N#endif
N#ifdef CC
S            settings->CC_axis_offset SET_TO 0;    /*CC*/
N#endif
N
N            settings->current_x SET_TO settings->current_x -
X            settings->current_x = settings->current_x -
N                settings->origin_offset_x;
N            settings->current_y SET_TO settings->current_y -
X            settings->current_y = settings->current_y -
N                settings->origin_offset_y;
N            settings->current_z SET_TO settings->current_z -
X            settings->current_z = settings->current_z -
N                settings->origin_offset_z;
N#ifdef AA
S   /*AA*/
S            settings->AA_current SET_TO settings->AA_current -
N    #endif
N    #ifdef AA
S                settings->AA_origin_offset;       /*AA*/
N#endif
N#ifdef BB
S   /*BB*/
S            settings->BB_current SET_TO settings->BB_current -
N    #endif
N    #ifdef BB
S                settings->BB_origin_offset;       /*BB*/
N#endif
N#ifdef CC
S   /*CC*/
S            settings->CC_current SET_TO settings->CC_current -
N    #endif
N    #ifdef CC
S                settings->CC_origin_offset;       /*CC*/
N#endif
N
N            SET_ORIGIN_OFFSETS(settings->origin_offset_x,
N                settings->origin_offset_y,
N                settings->origin_offset_z
N    #ifdef AA
S                ,            settings->AA_origin_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,            settings->BB_origin_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,            settings->CC_origin_offset
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N
N            /*2*/ if (settings->plane ISNT CANON_PLANE_XY)
X              if (settings->plane != 1)
N            {
N                SELECT_PLANE(CANON_PLANE_XY);
X                SELECT_PLANE(1);
N                settings->plane SET_TO CANON_PLANE_XY;
X                settings->plane = 1;
N            }
N
N            /*3*/ settings->distance_mode SET_TO MODE_ABSOLUTE;
X              settings->distance_mode = MODE_ABSOLUTE;
N
N            /*4*/ settings->feed_mode SET_TO UNITS_PER_MINUTE;
X              settings->feed_mode = 0;
N
N            /*5*/ if (settings->feed_override ISNT ON)
X              if (settings->feed_override != 1)
N            {
N                ENABLE_FEED_OVERRIDE();
N                settings->feed_override SET_TO ON;
X                settings->feed_override = 1;
N            }
N            if (settings->speed_override ISNT ON)
X            if (settings->speed_override != 1)
N            {
N                ENABLE_SPEED_OVERRIDE();
N                settings->speed_override SET_TO ON;
X                settings->speed_override = 1;
N            }
N
N            /*6*/ settings->cutter_comp_side SET_TO OFF;
X              settings->cutter_comp_side = 0;
N            settings->program_x SET_TO UNKNOWN;
X            settings->program_x = 1e-20;
N
N            /*7*/ STOP_SPINDLE_TURNING();
N            settings->spindle_turning SET_TO CANON_STOPPED;
X            settings->spindle_turning = 1;
N
N            /*8*/ settings->motion_mode SET_TO G_1;
X              settings->motion_mode = 10;
N
N            /*9*/ if (settings->mist IS ON)
X              if (settings->mist == 1)
N            {
N                MIST_OFF();
N                settings->mist SET_TO OFF;
X                settings->mist = 0;
N            }
N            if (settings->flood IS ON)
X            if (settings->flood == 1)
N            {
N                FLOOD_OFF();
N                settings->flood SET_TO OFF;
X                settings->flood = 0;
N            }
N
N            if (block->m_modes[4] IS 30)
X            if (block->m_modes[4] == 30)
N                PALLET_SHUTTLE();
N            PROGRAM_END();
N            if (_setup.percent_flag IS ON)
X            if (_setup.percent_flag == 1)
N            {
N                CHK((_setup.file_pointer IS NULL), NCE_UNABLE_TO_OPEN_FILE);
X                if ((_setup . file_pointer == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 170; } else;
N                line SET_TO _setup.linetext;
X                line = _setup.linetext;
N                for(; ;)                          /* check for ending percent sign and comment if missing */
N                {
N                    if (fgets(line, RS274NGC_TEXT_SIZE, _setup.file_pointer) IS NULL)
X                    if (fgets(line, 256, _setup.file_pointer) == 0)
N                    {
N                        COMMENT
N                            ("interpreter: percent sign missing from end of file");
N                        break;
N                    }
N                    length SET_TO strlen(line);
X                    length = strlen(line);
N                    if (length IS (RS274NGC_TEXT_SIZE - 1))
X                    if (length == (256 - 1))
N                    {                             // line is too long. need to finish reading the line
N                        for(;fgetc(_setup.file_pointer) ISNT '\n';);
X                        for(;fgetc(_setup.file_pointer) != '\n';);
N                        continue;
N                    }
N                    for(index SET_TO (length -1); // index set on last char
X                    for(index = (length -1); 
N                        (index >= 0) AND (isspace(line[index]));
X                        (index >= 0) && (((* __rt_ctype_table())[line[index]] & 1));
N                        index--);
N                    if (line[index] IS '%')       // found line with % at end
X                    if (line[index] == '%')       
N                    {
N                        for(index--; (index >= 0)AND(isspace(line[index])); index--);
X                        for(index--; (index >= 0)&&(((* __rt_ctype_table())[line[index]] & 1)); index--);
N                        if (index IS -1)          // found line with only percent sign
X                        if (index == -1)          
N                            break;
N                    }
N                }
N            }
N            return RS274NGC_EXIT;
X            return 1;
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_M0_M1_M2_M30_M60);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 30; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_straight
N
N   Returned Value: int
N   If convert_straight_comp1 or convert_straight_comp2 is called
N   and returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. x, y, z, a, b, and c are all missing from the block:
N   NCE_ALL_AXES_MISSING_WITH_G0_OR_G1
N   2. The value of move is not G_0 or G_1:
N   NCE_BUG_CODE_NOT_G0_OR_G1
N   3. A straight feed (g1) move is called with feed rate set to 0:
N   NCE_CANNOT_DO_G1_WITH_ZERO_FEED_RATE
N   4. A straight feed (g1) move is called with inverse time feed in effect
N   but no f word (feed time) is provided:
N   NCE_F_WORD_MISSING_WITH_INVERSE_TIME_G1_MOVE
N   5. A move is called with G53 and cutter radius compensation on:
N   NCE_CANNOT_USE_G53_WITH_CUTTER_RADIUS_COMP
N
N   Side effects:
N   This executes a STRAIGHT_FEED command at cutting feed rate
N   (if move is G_1) or a STRAIGHT_TRAVERSE command (if move is G_0).
N   It also updates the setting of the position of the tool point to the
N   end point of the move. If cutter radius compensation is on, it may
N   also generate an arc before the straight move. Also, in INVERSE_TIME
N   feed mode, SET_FEED_RATE will be called the feed rate setting changed.
N
N   Called by: convert_motion.
N
N   The approach to operating in incremental distance mode (g91) is to
N   put the the absolute position values into the block before using the
N   block to generate a move.
N
N   In inverse time feed mode, a lower bound of 0.1 is placed on the feed
N   rate so that the feed rate is never set to zero. If the destination
N   point is the same as the current point, the feed rate would be
N   calculated as zero otherwise.
N
N   */
N
N    static int convert_straight(                  /* ARGUMENTS                                */
N    int move,                                     /* either G_0 or G_1                        */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        static char name[] SET_TO "convert_straight";
X        static char name[] = "convert_straight";
N        double end_x;
N        double end_y;
N        double end_z;
N#ifdef AA
S        double AA_end;                            /*AA*/
N#endif
N#ifdef BB
S        double BB_end;                            /*BB*/
N#endif
N#ifdef CC
S        double CC_end;                            /*CC*/
N#endif
N        int status;
N
N        if (move IS G_1)
X        if (move == 10)
N        {
N            if (settings->feed_mode IS UNITS_PER_MINUTE)
X            if (settings->feed_mode == 0)
N            {
N                CHK((settings->feed_rate IS 0.0),
N                    NCE_CANNOT_DO_G1_WITH_ZERO_FEED_RATE);
X                if ((settings->feed_rate == 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 41; } else;
N            }
N            else if (settings->feed_mode IS INVERSE_TIME)
X            else if (settings->feed_mode == 1)
N            {
N                CHK((block->f_number IS -1.0),
N                    NCE_F_WORD_MISSING_WITH_INVERSE_TIME_G1_MOVE);
X                if ((block->f_number == -1.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 79; } else;
N            }
N        }
N
N        settings->motion_mode SET_TO move;
X        settings->motion_mode = move;
N        find_ends(block, settings, &end_x, &end_y,
N            &end_z
N    #ifdef AA
S            , &AA_end
N    #endif
N
N    #ifdef BB
S            , &BB_end
N    #endif
N
N    #ifdef CC
S            , &CC_end
N    #endif
N            );
N   /* NOT "IS ON" */
N        if ((settings->cutter_comp_side ISNT OFF) AND
X        if ((settings->cutter_comp_side != 0) &&
N            (settings->cutter_comp_radius > 0.0)) /* radius always is >= 0 */
N        {
N            CHK((block->g_modes[0] IS G_53),
N                NCE_CANNOT_USE_G53_WITH_CUTTER_RADIUS_COMP);
X            if ((block->g_modes[0] == 530)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 62; } else;
N            if (settings->program_x IS UNKNOWN)
X            if (settings->program_x == 1e-20)
N            {
N                status SET_TO
X                status =
N                    convert_straight_comp1(move, block, settings, end_x, end_y,
N                    end_z
N    #ifdef AA
S                    , AA_end
N    #endif
N
N    #ifdef BB
S                    , BB_end
N    #endif
N
N    #ifdef CC
S                    , CC_end
N    #endif
N                    );
N                CHP(status);
X                if ((status = (status)) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            }
N            else
N            {
N                status SET_TO
X                status =
N                    convert_straight_comp2 (move, block, settings, end_x, end_y,
N                    end_z
N    #ifdef AA
S                    , AA_end
N    #endif
N
N    #ifdef BB
S                    , BB_end
N    #endif
N
N    #ifdef CC
S                    , CC_end
N    #endif
N                    );
N                CHP(status);
X                if ((status = (status)) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            }
N        }
N        else if (move IS G_0)
X        else if (move == 0)
N        {
N            STRAIGHT_TRAVERSE(end_x, end_y, end_z
N    #ifdef AA
S                ,           AA_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,  BB_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,  CC_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N            settings->current_x SET_TO end_x;
X            settings->current_x = end_x;
N            settings->current_y SET_TO end_y;
X            settings->current_y = end_y;
N        }
N        else if (move IS G_1)
X        else if (move == 10)
N        {
N            if (settings->feed_mode IS INVERSE_TIME)
X            if (settings->feed_mode == 1)
N                inverse_time_rate_straight
N                    (end_x, end_y, end_z
N        #ifdef AA
S                    , AA_end
N        #endif
N
N        #ifdef BB
S                    , BB_end
N        #endif
N
N        #ifdef CC
S                    , CC_end
N        #endif
N                    , block, settings);
N            STRAIGHT_FEED(end_x, end_y, end_z
N    #ifdef AA
S                ,           AA_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,  BB_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,  CC_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N            settings->current_x SET_TO end_x;
X            settings->current_x = end_x;
N            settings->current_y SET_TO end_y;
X            settings->current_y = end_y;
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G0_OR_G1);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 16; } else;
N
N        settings->current_z SET_TO end_z;
X        settings->current_z = end_z;
N#ifdef AA
S        settings->AA_current SET_TO AA_end;       /*AA*/
N#endif
N#ifdef BB
S        settings->BB_current SET_TO BB_end;       /*BB*/
N#endif
N#ifdef CC
S        settings->CC_current SET_TO CC_end;       /*CC*/
N#endif
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_straight_comp1
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The side is not RIGHT or LEFT:
N   NCE_BUG_SIDE_NOT_RIGHT_OR_LEFT
N   2. The destination tangent point is not more than a tool radius
N   away (indicating gouging): NCE_CUTTER_GOUGING_WITH_CUTTER_RADIUS_COMP
N   3. The value of move is not G_0 or G_1
N   NCE_BUG_CODE_NOT_G0_OR_G1
N
N   Side effects:
N   This executes a STRAIGHT_MOVE command at cutting feed rate
N   or a STRAIGHT_TRAVERSE command.
N   It also updates the setting of the position of the tool point
N   to the end point of the move and updates the programmed point.
N   If INVERSE_TIME feed rate mode is in effect, it resets the feed rate.
N
N   Called by: convert_straight.
N
N   This is called if cutter radius compensation is on and settings->program_x
N   is UNKNOWN, indicating that this is the first move after cutter radius
N   compensation is turned on.
N
N   The algorithm used here for determining the path is to draw a straight
N   line from the destination point which is tangent to a circle whose
N   center is at the current point and whose radius is the radius of the
N   cutter. The destination point of the cutter tip is then found as the
N   center of a circle of the same radius tangent to the tangent line at
N   the destination point.
N
N   */
N
N    static int convert_straight_comp1(            /* ARGUMENTS                       */
N    int move,                                     /* either G_0 or G_1                         */
N    block_pointer block,                          /* pointer to a block of RS274 instructions  */
N    setup_pointer settings,                       /* pointer to machine settings               */
N    double px,                                    /* X coordinate of end point                 */
N    double py,                                    /* Y coordinate of end point                 */
N    double end_z                                  /* Z coordinate of end point                 */
N#ifdef AA
S    , double AA_end                               /* A coordinate of end point           *//*AA*/
N#endif
N#ifdef BB
S    , double BB_end                               /* B coordinate of end point           *//*BB*/
N#endif
N#ifdef CC
S    , double CC_end                               /* C coordinate of end point           *//*CC*/
N#endif
N    )
N    {
N        static char name[] SET_TO "convert_straight_comp1";
X        static char name[] = "convert_straight_comp1";
N        double alpha;
N        double cx;                                /* first current point x then end point x */
N        double cy;                                /* first current point y then end point y */
N        double distance;
N        double radius;
N        int side;
N        double theta;
N
N        side SET_TO settings->cutter_comp_side;
X        side = settings->cutter_comp_side;
N        cx SET_TO settings->current_x;
X        cx = settings->current_x;
N        cy SET_TO settings->current_y;
X        cy = settings->current_y;
N
N   /* always will be positive */
N        radius SET_TO settings->cutter_comp_radius;
X        radius = settings->cutter_comp_radius;
N        distance SET_TO hypot((px - cx), (py -cy));
X        distance = hypot((px - cx), (py -cy));
N
N        CHK(((side ISNT LEFT) AND (side ISNT RIGHT)),NCE_BUG_SIDE_NOT_RIGHT_OR_LEFT);
X        if (((side != 2) && (side != 1))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 35; } else;
N        CHK((distance <= radius), NCE_CUTTER_GOUGING_WITH_CUTTER_RADIUS_COMP);
X        if ((distance <= radius)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 70; } else;
N
N        theta SET_TO acos(radius/distance);
X        theta = acos(radius/distance);
N        alpha SET_TO (side IS LEFT) ? (atan2((cy - py), (cx - px)) - theta) :
X        alpha = (side == 2) ? (atan2((cy - py), (cx - px)) - theta) :
N        (atan2((cy - py), (cx - px)) + theta);
N        cx SET_TO (px + (radius * cos(alpha)));   /* reset to end location */
X        cx = (px + (radius * cos(alpha)));    
N        cy SET_TO (py + (radius * sin(alpha)));
X        cy = (py + (radius * sin(alpha)));
N        if (move IS G_0)
X        if (move == 0)
N            STRAIGHT_TRAVERSE(cx, cy, end_z
N        #ifdef AA
S                ,             AA_end
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef BB
S                ,  BB_end
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef CC
S                ,  CC_end
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N                );
N        else if (move IS G_1)
X        else if (move == 10)
N        {
N            if (settings->feed_mode IS INVERSE_TIME)
X            if (settings->feed_mode == 1)
N                inverse_time_rate_straight
N                    (cx, cy, end_z
N        #ifdef AA
S                    , AA_end
N        #endif
N
N        #ifdef BB
S                    , BB_end
N        #endif
N
N        #ifdef CC
S                    , CC_end
N        #endif
N                    , block, settings);
N            STRAIGHT_FEED(cx, cy, end_z
N    #ifdef AA
S                ,           AA_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef BB
S                ,  BB_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N    #ifdef CC
S                ,  CC_end
N    #else
N    #ifdef ALL_AXES
S                , 0
N    #endif
N    #endif
N                );
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G0_OR_G1);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 16; } else;
N
N        settings->current_x SET_TO cx;
X        settings->current_x = cx;
N        settings->current_y SET_TO cy;
X        settings->current_y = cy;
N        settings->program_x SET_TO px;
X        settings->program_x = px;
N        settings->program_y SET_TO py;
X        settings->program_y = py;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_straight_comp2
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The compensation side is not RIGHT or LEFT:
N   NCE_BUG_SIDE_NOT_RIGHT_OR_LEFT
N   2. A concave corner is found:
N   NCE_CONCAVE_CORNER_WITH_CUTTER_RADIUS_COMP
N
N   Side effects:
N   This executes a STRAIGHT_FEED command at cutting feed rate
N   or a STRAIGHT_TRAVERSE command.
N   It also generates an ARC_FEED to go around a corner, if necessary.
N   It also updates the setting of the position of the tool point to
N   the end point of the move and updates the programmed point.
N   If INVERSE_TIME feed mode is in effect, it also calls SET_FEED_RATE
N   and resets the feed rate in the machine model.
N
N   Called by: convert_straight.
N
N   This is called if cutter radius compensation is on and
N   settings->program_x is not UNKNOWN, indicating that this is not the
N   first move after cutter radius compensation is turned on.
N
N   The algorithm used here is:
N   1. Determine the direction of the last motion. This is done by finding
N   the direction of the line from the last programmed point to the
N   current tool tip location. This line is a radius of the tool and is
N   perpendicular to the direction of motion since the cutter is tangent
N   to that direction.
N   2. Determine the direction of the programmed motion.
N   3. If there is a convex corner, insert an arc to go around the corner.
N   4. Find the destination point for the tool tip. The tool will be
N   tangent to the line from the last programmed point to the present
N   programmed point at the present programmed point.
N   5. Go in a straight line from the current tool tip location to the
N   destination tool tip location.
N
N   This uses an angle tolerance of TOLERANCE_CONCAVE_CORNER (0.01 radian)
N   to determine if:
N   1) an illegal concave corner exists (tool will not fit into corner),
N   2) no arc is required to go around the corner (i.e. the current line
N   is in the same direction as the end of the previous move), or
N   3) an arc is required to go around a convex corner and start off in
N   a new direction.
N
N   If a rotary axis is moved in this block and an extra arc is required
N   to go around a sharp corner, all the rotary axis motion occurs on the
N   arc.  An alternative might be to distribute the rotary axis motion
N   over the arc and the straight move in proportion to their lengths.
N
N   If the Z-axis is moved in this block and an extra arc is required to
N   go around a sharp corner, all the Z-axis motion occurs on the straight
N   line and none on the extra arc.  An alternative might be to distribute
N   the Z-axis motion over the extra arc and the straight line in
N   proportion to their lengths.
N
N   This handles inverse time feed rates by computing the length of the
N   compensated path.
N
N   This handles the case of there being no XY motion.
N
N   This handles G0 moves. Where an arc is inserted to round a corner in a
N   G1 move, no arc is inserted for a G0 move; a STRAIGHT_TRAVERSE is made
N   from the current point to the end point. The end point for a G0
N   move is the same as the end point for a G1 move, however.
N
N   */
N
N    static int convert_straight_comp2(            /* ARGUMENTS                       */
N    int move,                                     /* either G_0 or G_1                         */
N    block_pointer block,                          /* pointer to a block of RS274 instructions  */
N    setup_pointer settings,                       /* pointer to machine settings               */
N    double px,                                    /* X coordinate of programmed end point      */
N    double py,                                    /* Y coordinate of programmed end point      */
N    double end_z                                  /* Z coordinate of end point                 */
N#ifdef AA
S    , double AA_end                               /* A coordinate of end point           *//*AA*/
N#endif
N#ifdef BB
S    , double BB_end                               /* B coordinate of end point           *//*BB*/
N#endif
N#ifdef CC
S    , double CC_end                               /* C coordinate of end point           *//*CC*/
N#endif
N    )
N    {
N        static char name[] SET_TO "convert_straight_comp2";
X        static char name[] = "convert_straight_comp2";
N        double alpha;
N        double beta;
N        double end_x;                             /* x-coordinate of actual end point */
N        double end_y;                             /* y-coordinate of actual end point */
N        double gamma;
N        double mid_x;                             /* x-coordinate of end of added arc, if needed */
N        double mid_y;                             /* y-coordinate of end of added arc, if needed */
N        double radius;
N        int side;
N   /* radians, testing corners */
N        double small SET_TO TOLERANCE_CONCAVE_CORNER;
X        double small = 0.01;
N        double start_x, start_y;                  /* programmed beginning point */
N        double theta;
N
N        start_x SET_TO settings->program_x;
X        start_x = settings->program_x;
N        start_y SET_TO settings->program_y;
X        start_y = settings->program_y;
N        if ((py IS start_y) AND (px IS start_x))  /* no XY motion */
X        if ((py == start_y) && (px == start_x))   
N        {
N            end_x SET_TO settings->current_x;
X            end_x = settings->current_x;
N            end_y SET_TO settings->current_y;
X            end_y = settings->current_y;
N            if (move IS G_0)
X            if (move == 0)
N                STRAIGHT_TRAVERSE(end_x, end_y, end_z
N        #ifdef AA
S                    ,             AA_end
N        #else
N        #ifdef ALL_AXES
S                    , 0
N        #endif
N        #endif
N        #ifdef BB
S                    ,  BB_end
N        #else
N        #ifdef ALL_AXES
S                    , 0
N        #endif
N        #endif
N        #ifdef CC
S                    ,  CC_end
N        #else
N        #ifdef ALL_AXES
S                    , 0
N        #endif
N        #endif
N                    );
N            else if (move IS G_1)
X            else if (move == 10)
N            {
N                if (settings->feed_mode IS INVERSE_TIME)
X                if (settings->feed_mode == 1)
N                    inverse_time_rate_straight
N                        (end_x, end_y, end_z
N        #ifdef AA
S                        , AA_end
N        #endif
N
N        #ifdef BB
S                        , BB_end
N        #endif
N
N        #ifdef CC
S                        , CC_end
N        #endif
N                        , block, settings);
N                STRAIGHT_FEED(end_x, end_y, end_z
N    #ifdef AA
S                    ,           AA_end
N    #else
N    #ifdef ALL_AXES
S                    , 0
N    #endif
N    #endif
N    #ifdef BB
S                    ,  BB_end
N    #else
N    #ifdef ALL_AXES
S                    , 0
N    #endif
N    #endif
N    #ifdef CC
S                    ,  CC_end
N    #else
N    #ifdef ALL_AXES
S                    , 0
N    #endif
N    #endif
N                    );
N            }
N            else
N                ERM(NCE_BUG_CODE_NOT_G0_OR_G1);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 16; } else;
N        }
N        else
N        {
N            side SET_TO settings->cutter_comp_side;
X            side = settings->cutter_comp_side;
N   /* will always be positive */
N            radius SET_TO settings->cutter_comp_radius;
X            radius = settings->cutter_comp_radius;
N            theta SET_TO atan2(settings->current_y - start_y,
X            theta = atan2(settings->current_y - start_y,
N                settings->current_x - start_x);
N            alpha SET_TO atan2(py - start_y, px - start_x);
X            alpha = atan2(py - start_y, px - start_x);
N
N            if (side IS LEFT)
X            if (side == 2)
N            {
N                if (theta < alpha)
N                    theta SET_TO (theta + TWO_PI);
X                    theta = (theta + 6.2831853071795864);
N                beta SET_TO ((theta - alpha) - PI2);
X                beta = ((theta - alpha) - 1.5707963267948966);
N                gamma SET_TO PI2;
X                gamma = 1.5707963267948966;
N            }
N            else if (side IS RIGHT)
X            else if (side == 1)
N            {
N                if (alpha < theta)
N                    alpha SET_TO (alpha + TWO_PI);
X                    alpha = (alpha + 6.2831853071795864);
N                beta SET_TO ((alpha - theta) - PI2);
X                beta = ((alpha - theta) - 1.5707963267948966);
N                gamma SET_TO -PI2;
X                gamma = -1.5707963267948966;
N            }
N            else
N                ERM(NCE_BUG_SIDE_NOT_RIGHT_OR_LEFT);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 35; } else;
N            end_x SET_TO (px + (radius * cos(alpha + gamma)));
X            end_x = (px + (radius * cos(alpha + gamma)));
N            end_y SET_TO (py + (radius * sin(alpha + gamma)));
X            end_y = (py + (radius * sin(alpha + gamma)));
N            mid_x SET_TO (start_x + (radius * cos(alpha + gamma)));
X            mid_x = (start_x + (radius * cos(alpha + gamma)));
N            mid_y SET_TO (start_y + (radius * sin(alpha + gamma)));
X            mid_y = (start_y + (radius * sin(alpha + gamma)));
N
N            CHK(((beta < -small) OR (beta > (PI + small))),
N                NCE_CONCAVE_CORNER_WITH_CUTTER_RADIUS_COMP);
X            if (((beta < -small) || (beta > (3.1415926535897932 + small)))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 67; } else;
N            if (move IS G_0)
X            if (move == 0)
N                STRAIGHT_TRAVERSE(end_x, end_y, end_z
N        #ifdef AA
S                    ,             AA_end
N        #else
N        #ifdef ALL_AXES
S                    , 0
N        #endif
N        #endif
N        #ifdef BB
S                    ,  BB_end
N        #else
N        #ifdef ALL_AXES
S                    , 0
N        #endif
N        #endif
N        #ifdef CC
S                    ,  CC_end
N        #else
N        #ifdef ALL_AXES
S                    , 0
N        #endif
N        #endif
N                    );
N            else if (move IS G_1)
X            else if (move == 10)
N            {
N                if (beta > small)                 /* ARC NEEDED */
N                {
N                    if (settings->feed_mode IS INVERSE_TIME)
X                    if (settings->feed_mode == 1)
N                        inverse_time_rate_as(start_x, start_y, (side IS LEFT) ? -1 : 1,
X                        inverse_time_rate_as(start_x, start_y, (side == 2) ? -1 : 1,
N                        mid_x, mid_y, end_x, end_y,
N                        end_z
N    #ifdef AA
S                        , AA_end
N    #endif
N
N    #ifdef BB
S                        , BB_end
N    #endif
N
N    #ifdef CC
S                        , CC_end
N    #endif
N                        ,
N                        block, settings);
N                    ARC_FEED(mid_x,mid_y,start_x, start_y,((side IS LEFT) ? -1 : 1),
X                    ARC_FEED(mid_x,mid_y,start_x, start_y,((side == 2) ? -1 : 1),
N                        settings->current_z
N    #ifdef AA
S                        , AA_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N    #ifdef BB
S                        , BB_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N    #ifdef CC
S                        , CC_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N                        );
N                    STRAIGHT_FEED(end_x, end_y, end_z
N    #ifdef AA
S                        ,               AA_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N    #ifdef BB
S                        ,  BB_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N    #ifdef CC
S                        ,  CC_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N                        );
N                }
N                else
N                {
N                    if (settings->feed_mode IS INVERSE_TIME)
X                    if (settings->feed_mode == 1)
N                        inverse_time_rate_straight
N                            (end_x,end_y,end_z
N        #ifdef AA
S                            , AA_end
N        #endif
N
N        #ifdef BB
S                            , BB_end
N        #endif
N
N        #ifdef CC
S                            , CC_end
N        #endif
N                            , block, settings);
N                    STRAIGHT_FEED(end_x, end_y, end_z
N    #ifdef AA
S                        ,               AA_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N    #ifdef BB
S                        ,  BB_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N    #ifdef CC
S                        ,  CC_end
N    #else
N    #ifdef ALL_AXES
S                        , 0
N    #endif
N    #endif
N                        );
N                }
N            }
N            else
N                ERM(NCE_BUG_CODE_NOT_G0_OR_G1);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 16; } else;
N        }
N
N        settings->current_x SET_TO end_x;
X        settings->current_x = end_x;
N        settings->current_y SET_TO end_y;
X        settings->current_y = end_y;
N        settings->program_x SET_TO px;
X        settings->program_x = px;
N        settings->program_y SET_TO py;
X        settings->program_y = py;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_tool_change
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   This makes function calls to canonical machining functions, and sets
N   the machine model as described below.
N
N   Called by: convert_m
N
N   This function carries out an m6 command, which changes the tool in the
N   spindle. The only function call this makes is to the CHANGE_TOOL
N   function. The semantics of this function call is that when it is
N   completely carried out, the tool that was selected is in the spindle,
N   the tool that was in the spindle (if any) is returned to its changer
N   slot, the spindle will be stopped (but the spindle speed setting will
N   not have changed) and the x, y, z, a, b, and c positions will be the same
N   as they were before (although they may have moved around during the
N   change).
N
N   It would be nice to add more flexibility to this function by allowing
N   more changes to occur (position changes, for example) as a result of
N   the tool change. There are at least two ways of doing this:
N
N   1. Require that certain machine settings always have a given fixed
N   value after a tool change (which may be different from what the value
N   was before the change), and record the fixed values somewhere (in the
N   world model that is read at initialization, perhaps) so that this
N   function can retrieve them and reset any settings that have changed.
N   Fixed values could even be hard coded in this function.
N
N   2. Allow the executor of the CHANGE_TOOL function to change the state
N   of the world however it pleases, and have the interpreter read the
N   executor's world model after the CHANGE_TOOL function is carried out.
N   Implementing this would require a change in other parts of the EMC
N   system, since calls to the interpreter would then have to be
N   interleaved with execution of the function calls output by the
N   interpreter.
N
N   There may be other commands in the block that includes the tool change.
N   They will be executed in the order described in execute_block.
N
N   This implements the "Next tool in T word" approach to tool selection.
N   The tool is selected when the T word is read (and the carousel may
N   move at that time) but is changed when M6 is read.
N
N   Note that if a different tool is put into the spindle, the current_z
N   location setting may be incorrect for a time. It is assumed the
N   program will contain an appropriate USE_TOOL_LENGTH_OFFSET command
N   near the CHANGE_TOOL command, so that the incorrect setting is only
N   temporary.
N
N   In [NCMS, page 73, 74] there are three other legal approaches in addition
N   to this one.
N
N   */
N
N    static int convert_tool_change(               /* ARGUMENTS                   */
N    setup_pointer settings)                       /* pointer to machine settings */
N    {
N        static char name[] SET_TO "convert_tool_change";
X        static char name[] = "convert_tool_change";
N
N        CHANGE_TOOL(settings->selected_tool_slot);
N        settings->current_slot SET_TO settings->selected_tool_slot;
X        settings->current_slot = settings->selected_tool_slot;
N        settings->spindle_turning SET_TO CANON_STOPPED;
X        settings->spindle_turning = 1;
N
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 6993 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* convert_tool_length_offset
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The block has no offset index (h number): NCE_OFFSET_INDEX_MISSING
N   2. The g_code argument is not G_43 or G_49:
N   NCE_BUG_CODE_NOT_G43_OR_G49
N
N   Side effects:
N   A USE_TOOL_LENGTH_OFFSET function call is made. Current_z,
N   tool_length_offset, and length_offset_index are reset.
N
N   Called by: convert_g
N
N   This is called to execute g43 or g49.
N
N   The g49 RS274/NGC command translates into a USE_TOOL_LENGTH_OFFSET(0.0)
N   function call.
N
N   The g43 RS274/NGC command translates into a USE_TOOL_LENGTH_OFFSET(length)
N   function call, where length is the value of the entry in the tool length
N   offset table whose index is the H number in the block.
N
N   The H number in the block (if present) was checked for being a non-negative
N   integer when it was read, so that check does not need to be repeated.
N
N   */
N
N    static int convert_tool_length_offset(        /* ARGUMENTS                      */
N    int g_code,                                   /* g_code being executed (must be G_43 or G_49) */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "convert_tool_length_offset";
X        static char name[] = "convert_tool_length_offset";
N        int index;
N        double offset;
N
N        if (g_code IS G_49)
X        if (g_code == 490)
N        {
N            USE_TOOL_LENGTH_OFFSET(0.0);
N            settings->current_z SET_TO (settings->current_z +
X            settings->current_z = (settings->current_z +
N                settings->tool_length_offset);
N            settings->tool_length_offset SET_TO 0.0;
X            settings->tool_length_offset = 0.0;
N            settings->length_offset_index SET_TO 0;
X            settings->length_offset_index = 0;
N        }
N        else if (g_code IS G_43)
X        else if (g_code == 430)
N        {
N            index SET_TO block->h_number;
X            index = block->h_number;
N            CHK((index IS -1), NCE_OFFSET_INDEX_MISSING);
X            if ((index == -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 137; } else;
N            offset SET_TO settings->tool_table[index].length;
X            offset = settings->tool_table[index].length;
N            USE_TOOL_LENGTH_OFFSET(offset);
N            settings->current_z SET_TO
X            settings->current_z =
N                (settings->current_z + settings->tool_length_offset - offset);
N            settings->tool_length_offset SET_TO offset;
X            settings->tool_length_offset = offset;
N            settings->length_offset_index SET_TO index;
X            settings->length_offset_index = index;
N        }
N        else
N            ERM(NCE_BUG_CODE_NOT_G43_OR_G49);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 22; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* convert_tool_select
N
N   Returned Value: int
N   If the tool slot given in the block is larger than allowed,
N   this returns NCE_SELECTED_TOOL_SLOT_NUMBER_TOO_LARGE.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects: See below
N
N   Called by: execute_block
N
N   A select tool command is given, which causes the changer chain to move
N   so that the slot with the t_number given in the block is next to the
N   tool changer, ready for a tool change.  The
N   settings->selected_tool_slot is set to the given slot.
N
N   An alternative in this function is to select by tool id. This was used
N   in the K&T and VGER interpreters. It is easy to code.
N
N   A check that the t_number is not negative has already been made in read_t.
N   A zero t_number is allowed and means no tool should be selected.
N
N   */
N
N    static int convert_tool_select(               /* ARGUMENTS                                */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        static char name[] SET_TO "convert_tool_select";
X        static char name[] = "convert_tool_select";
N
N        CHK((block->t_number > settings->tool_max),
N            NCE_SELECTED_TOOL_SLOT_NUMBER_TOO_LARGE);
X        if ((block->t_number > settings->tool_max)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 155; } else;
N        SELECT_TOOL(block->t_number);
N        settings->selected_tool_slot SET_TO block->t_number;
X        settings->selected_tool_slot = block->t_number;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* cycle_feed
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   STRAIGHT_FEED is called.
N
N   Called by:
N   convert_cycle_g81
N   convert_cycle_g82
N   convert_cycle_g83
N   convert_cycle_g84
N   convert_cycle_g85
N   convert_cycle_g86
N   convert_cycle_g87
N   convert_cycle_g88
N   convert_cycle_g89
N
N   This writes a STRAIGHT_FEED command appropriate for a cycle move with
N   respect to the given plane. No rotary axis motion takes place.
N
N   */
N
N    static int cycle_feed(                        /* ARGUMENTS                  */
N    CANON_PLANE plane,                            /* currently selected plane   */
N    double end1,                                  /* first coordinate value     */
N    double end2,                                  /* second coordinate value    */
N    double end3)                                  /* third coordinate value     */
N    {
N        static char name[] SET_TO "cycle_feed";
X        static char name[] = "cycle_feed";
N
N        if (plane IS CANON_PLANE_XY)
X        if (plane == 1)
N            STRAIGHT_FEED(end1, end2, end3
N        #ifdef AA
S                ,         _setup.AA_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef BB
S                ,  _setup.BB_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef CC
S                ,  _setup.CC_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N                );
N        else if (plane IS CANON_PLANE_YZ)
X        else if (plane == 2)
N            STRAIGHT_FEED(end3, end1, end2
N            #ifdef AA
S                    ,         _setup.AA_current
N            #else
N            #ifdef ALL_AXES
S                    , 0
N            #endif
N            #endif
N            #ifdef BB
S                    ,  _setup.BB_current
N            #else
N            #ifdef ALL_AXES
S                    , 0
N            #endif
N            #endif
N            #ifdef CC
S                    ,  _setup.CC_current
N            #else
N            #ifdef ALL_AXES
S                    , 0
N            #endif
N            #endif
N                    );
N        else                                      /* if (plane IS CANON_PLANE_XZ) */
N            STRAIGHT_FEED(end2, end3, end1
N        #ifdef AA
S                ,         _setup.AA_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef BB
S                ,  _setup.BB_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef CC
S                ,  _setup.CC_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N                );
N
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 7136 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* cycle_traverse
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   STRAIGHT_TRAVERSE is called.
N
N   Called by:
N   convert_cycle
N   convert_cycle_g81
N   convert_cycle_g82
N   convert_cycle_g83
N   convert_cycle_g86
N   convert_cycle_g87
N   convert_cycle_xy (via CYCLE_MACRO)
N   convert_cycle_yz (via CYCLE_MACRO)
N   convert_cycle_zx (via CYCLE_MACRO)
N
N   This writes a STRAIGHT_TRAVERSE command appropriate for a cycle
N   move with respect to the given plane. No rotary axis motion takes place.
N
N   */
N
N    static int cycle_traverse(                    /* ARGUMENTS                 */
N    CANON_PLANE plane,                            /* currently selected plane  */
N    double end1,                                  /* first coordinate value    */
N    double end2,                                  /* second coordinate value   */
N    double end3)                                  /* third coordinate value    */
N    {
N        static char name[] SET_TO "cycle_traverse";
X        static char name[] = "cycle_traverse";
N        if (plane IS CANON_PLANE_XY)
X        if (plane == 1)
N            STRAIGHT_TRAVERSE(end1, end2, end3
N        #ifdef AA
S                ,             _setup.AA_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef BB
S                ,  _setup.BB_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef CC
S                ,  _setup.CC_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N                );
N        else if (plane IS CANON_PLANE_YZ)
X        else if (plane == 2)
N            STRAIGHT_TRAVERSE(end3, end1, end2
N            #ifdef AA
S                    ,             _setup.AA_current
N            #else
N            #ifdef ALL_AXES
S                    , 0
N            #endif
N            #endif
N            #ifdef BB
S                    ,  _setup.BB_current
N            #else
N            #ifdef ALL_AXES
S                    , 0
N            #endif
N            #endif
N            #ifdef CC
S                    ,  _setup.CC_current
N            #else
N            #ifdef ALL_AXES
S                    , 0
N            #endif
N            #endif
N                    );
N        else                                      /* if (plane IS CANON_PLANE_XZ) */
N            STRAIGHT_TRAVERSE(end2, end3, end1
N        #ifdef AA
S                ,             _setup.AA_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef BB
S                ,  _setup.BB_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N        #ifdef CC
S                ,  _setup.CC_current
N        #else
N        #ifdef ALL_AXES
S                , 0
N        #endif
N        #endif
N                );
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 7245 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* enhance_block
N
N   Returned Value:
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. A g80 is in the block, no modal group 0 code that uses axes
N   is in the block, and one or more axis values is given:
N   NCE_CANNOT_USE_AXIS_VALUES_WITH_G80
N   2. A g92 is in the block and no axis value is given:
N   NCE_ALL_AXES_MISSING_WITH_G92
N   3. One g-code from group 1 and one from group 0, both of which can use
N   axis values, are in the block:
N   NCE_CANNOT_USE_TWO_G_CODES_THAT_BOTH_USE_AXIS_VALUES
N   4. A g-code from group 1 which can use axis values is in the block,
N   but no axis value is given: NCE_ALL_AXES_MISSING_WITH_MOTION_CODE
N   5. Axis values are given, but there is neither a g-code in the block
N   nor an active previously given modal g-code that uses axis values:
N   NCE_CANNOT_USE_AXIS_VALUES_WITHOUT_A_G_CODE_THAT_USES_THEM
N
N   Side effects:
N   The value of motion_to_be in the block is set.
N
N   Called by: parse_line
N
N   If there is a g-code for motion in the block (in g_modes[1]),
N   set motion_to_be to that. Otherwise, if there is an axis value in the
N   block and no g-code to use it (any such would be from group 0 in
N   g_modes[0]), set motion_to_be to be the last motion saved (in
N   settings->motion mode).
N
N   This also make the checks described above.
N
N   */
N
N    static int enhance_block(                     /* ARGUMENTS                         */
N    block_pointer block,                          /* pointer to a block to be checked  */
N    setup_pointer settings)                       /* pointer to machine settings       */
N    {
N        static char name[] SET_TO "enhance_block";
X        static char name[] = "enhance_block";
N        int axis_flag;
N        int mode_zero_covets_axes;
N
N        axis_flag SET_TO ((block->x_flag IS ON) OR
X        axis_flag = ((block->x_flag == 1) ||
N            (block->y_flag IS ON) OR
X            (block->y_flag == 1) ||
N    #ifdef AA
S            (block->a_flag IS ON) OR              /*AA*/
N    #endif
N    #ifdef BB
S            (block->b_flag IS ON) OR              /*BB*/
N    #endif
N    #ifdef CC
S            (block->c_flag IS ON) OR              /*CC*/
N    #endif
N            (block->z_flag IS ON));
X            (block->z_flag == 1));
N        mode_zero_covets_axes SET_TO ((block->g_modes[0] IS G_10) OR
X        mode_zero_covets_axes = ((block->g_modes[0] == 100) ||
N            (block->g_modes[0] IS G_28) OR
X            (block->g_modes[0] == 280) ||
N            (block->g_modes[0] IS G_30) OR
X            (block->g_modes[0] == 300) ||
N            (block->g_modes[0] IS G_92));
X            (block->g_modes[0] == 920));
N
N        if (block->g_modes[1] ISNT -1)
X        if (block->g_modes[1] != -1)
N        {
N            if (block->g_modes[1] IS G_80)
X            if (block->g_modes[1] == 800)
N            {
N                CHK((axis_flag AND (NOT mode_zero_covets_axes)),
N                    NCE_CANNOT_USE_AXIS_VALUES_WITH_G80);
X                if ((axis_flag && (! mode_zero_covets_axes))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 56; } else;
N                CHK(((NOT axis_flag) AND (block->g_modes[0] IS G_92)),
N                    NCE_ALL_AXES_MISSING_WITH_G92);
X                if (((! axis_flag) && (block->g_modes[0] == 920))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 5; } else;
N            }
N            else
N            {
N                CHK(mode_zero_covets_axes,
N                    NCE_CANNOT_USE_TWO_G_CODES_THAT_BOTH_USE_AXIS_VALUES);
X                if (mode_zero_covets_axes) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 63; } else;
N                CHK((NOT axis_flag), NCE_ALL_AXES_MISSING_WITH_MOTION_CODE);
X                if ((! axis_flag)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 6; } else;
N            }
N            block->motion_to_be SET_TO block->g_modes[1];
X            block->motion_to_be = block->g_modes[1];
N        }
N        else if (mode_zero_covets_axes)
N        {                                         /* other 3 can get by without axes but not G92 */
N            CHK(((NOT axis_flag) AND (block->g_modes[0] IS G_92)),
N                NCE_ALL_AXES_MISSING_WITH_G92);
X            if (((! axis_flag) && (block->g_modes[0] == 920))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 5; } else;
N        }
N        else if (axis_flag)
N        {
N            CHK(((settings->motion_mode IS -1) OR (settings->motion_mode IS G_80)),
N                NCE_CANNOT_USE_AXIS_VALUES_WITHOUT_A_G_CODE_THAT_USES_THEM);
X            if (((settings->motion_mode == -1) || (settings->motion_mode == 800))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 57; } else;
N            block->motion_to_be SET_TO settings->motion_mode;
X            block->motion_to_be = settings->motion_mode;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* execute binary
N
N   Returned value: int
N   If execute_binary1 or execute_binary2 returns an error code, this
N   returns that code.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects: The value of left is set to the result of applying
N   the operation to left and right.
N
N   Called by: read_real_expression
N
N   This just calls either execute_binary1 or execute_binary2.
N
N   */
N
N    static int execute_binary(
N    double * left,
N    int operation,
N    double * right)
N    {
N        static char name[] SET_TO "execute_binary";
X        static char name[] = "execute_binary";
N        int status;
N
N        if (operation < AND2)
X        if (operation < 5)
N            CHP(execute_binary1(left, operation, right));
X            if ((status = (execute_binary1(left, operation, right))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        else
N            CHP(execute_binary2(left, operation, right));
X            if ((status = (execute_binary2(left, operation, right))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* execute_binary1
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. operation is unknown: NCE_BUG_UNKNOWN_OPERATION
N   2. An attempt is made to divide by zero: NCE_ATTEMPT_TO_DIVIDE_BY_ZERO
N   3. An attempt is made to raise a negative number to a non-integer power:
N   NCE_ATTEMPT_TO_RAISE_NEGATIVE_TO_NON_INTEGER_POWER
N
N   Side effects:
N   The result from performing the operation is put into what left points at.
N
N   Called by: read_real_expression.
N
N   This executes the operations: DIVIDED_BY, MODULO, POWER, TIMES.
N
N   */
N
N    static int execute_binary1(                   /* ARGUMENTS                       */
N    double * left,                                /* pointer to the left operand     */
N    int operation,                                /* integer code for the operation  */
N    double * right)                               /* pointer to the right operand    */
N    {
N        static char name[] SET_TO "execute_binary1";
X        static char name[] = "execute_binary1";
N        switch (operation)
N        {
N            case DIVIDED_BY:
X            case 1:
N                CHK((*right IS 0.0), NCE_ATTEMPT_TO_DIVIDE_BY_ZERO);
X                if ((*right == 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 10; } else;
N                *left SET_TO (*left / *right);
X                *left = (*left / *right);
N                break;
N            case MODULO:                          /* always calculates a positive answer */
X            case 2:                           
N                *left SET_TO fmod(*left, *right);
X                *left = fmod(*left, *right);
N                if (*left < 0.0)
N                {
N                    *left SET_TO (*left + fabs(*right));
X                    *left = (*left + fabs(*right));
N                }
N                break;
N            case POWER:
X            case 3:
N                CHK(((*left < 0.0) AND (floor(*right) ISNT *right)),
N                    NCE_ATTEMPT_TO_RAISE_NEGATIVE_TO_NON_INTEGER_POWER);
X                if (((*left < 0.0) && (floor(*right) != *right))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 11; } else;
N                *left SET_TO pow(*left, *right);
X                *left = pow(*left, *right);
N                break;
N            case TIMES:
X            case 4:
N                *left SET_TO (*left * *right);
X                *left = (*left * *right);
N                break;
N            default:
N                ERM(NCE_BUG_UNKNOWN_OPERATION);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 37; } else;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* execute_binary2
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. operation is unknown: NCE_BUG_UNKNOWN_OPERATION
N
N   Side effects:
N   The result from performing the operation is put into what left points at.
N
N   Called by: read_real_expression.
N
N   This executes the operations: AND2, EXCLUSIVE_OR, MINUS,
N   NON_EXCLUSIVE_OR, PLUS. The RS274/NGC manual [NCMS] does not say what
N   the calculated value of the three logical operations should be. This
N   function calculates either 1.0 (meaning true) or 0.0 (meaning false).
N   Any non-zero input value is taken as meaning true, and only 0.0 means
N   false.
N
N   */
N
N    static int execute_binary2(                   /* ARGUMENTS                       */
N    double * left,                                /* pointer to the left operand     */
N    int operation,                                /* integer code for the operation  */
N    double * right)                               /* pointer to the right operand    */
N    {
N        static char name[] SET_TO "execute_binary2";
X        static char name[] = "execute_binary2";
N        switch (operation)
N        {
N            case AND2:
X            case 5:
N                *left SET_TO ((*left IS 0.0) OR (*right IS 0.0)) ? 0.0 : 1.0;
X                *left = ((*left == 0.0) || (*right == 0.0)) ? 0.0 : 1.0;
N                break;
N            case EXCLUSIVE_OR:
X            case 6:
N                *left SET_TO (((*left IS 0.0) AND (*right ISNT 0.0)) OR
X                *left = (((*left == 0.0) && (*right != 0.0)) ||
N                    ((*left ISNT 0.0) AND (*right IS 0.0))) ? 1.0 : 0.0;
X                    ((*left != 0.0) && (*right == 0.0))) ? 1.0 : 0.0;
N                break;
N            case MINUS:
X            case 7:
N                *left SET_TO (*left - *right);
X                *left = (*left - *right);
N                break;
N            case NON_EXCLUSIVE_OR:
X            case 8:
N                *left SET_TO ((*left ISNT 0.0) OR (*right ISNT 0.0)) ? 1.0 : 0.0;
X                *left = ((*left != 0.0) || (*right != 0.0)) ? 1.0 : 0.0;
N                break;
N            case PLUS:
X            case 9:
N                *left SET_TO (*left + *right);
X                *left = (*left + *right);
N                break;
N            default:
N                ERM(NCE_BUG_UNKNOWN_OPERATION);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 37; } else;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* execute_block
N
N   Returned Value: int
N   If convert_stop returns RS274NGC_EXIT, this returns RS274NGC_EXIT.
N   If any of the following functions is called and returns an error code,
N   this returns that code.
N   convert_comment
N   convert_feed_mode
N   convert_feed_rate
N   convert_g
N   convert_m
N   convert_speed
N   convert_stop
N   convert_tool_select
N   Otherwise, if the probe_flag in the settings is ON, this returns
N   RS274NGC_EXECUTE_FINISH.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   One block of RS274/NGC instructions is executed.
N
N   Called by:
N   rs274ngc_execute
N
N   This converts a block to zero to many actions. The order of execution
N   of items in a block is critical to safe and effective machine operation,
N   but is not specified clearly in the RS274/NGC documentation.
N
N   Actions are executed in the following order:
N   1. any comment.
N   2. a feed mode setting (g93, g94)
N   3. a feed rate (f) setting if in units_per_minute feed mode.
N   4. a spindle speed (s) setting.
N   5. a tool selection (t).
N   6. "m" commands as described in convert_m (includes tool change).
N   7. any g_codes (except g93, g94) as described in convert_g.
N   8. stopping commands (m0, m1, m2, m30, or m60).
N
N   In inverse time feed mode, the explicit and implicit g code executions
N   include feed rate setting with g1, g2, and g3. Also in inverse time
N   feed mode, attempting a canned cycle cycle (g81 to g89) or setting a
N   feed rate with g0 is illegal and will be detected and result in an
N   error message.
N
N   */
N
N    static int execute_block(                     /* ARGUMENTS                                    */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        static char name[] SET_TO "execute_block";
X        static char name[] = "execute_block";
N        int status;
N
N        if (block->comment[0] ISNT 0)
X        if (block->comment[0] != 0)
N        {
N            CHP(convert_comment(block->comment));
X            if ((status = (convert_comment(block->comment))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->g_modes[5] ISNT -1)
X        if (block->g_modes[5] != -1)
N        {
N            CHP(convert_feed_mode(block->g_modes[5], settings));
X            if ((status = (convert_feed_mode(block->g_modes[5], settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->f_number > -1.0)
N        {
N   /* handle elsewhere */
N            if (settings->feed_mode IS INVERSE_TIME);
X            if (settings->feed_mode == 1);
N            else
N            {
N                CHP(convert_feed_rate(block, settings));
X                if ((status = (convert_feed_rate(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            }
N        }
N        if (block->s_number > -1.0)
N        {
N            CHP(convert_speed(block, settings));
X            if ((status = (convert_speed(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        if (block->t_number ISNT -1)
X        if (block->t_number != -1)
N        {
N            CHP(convert_tool_select(block, settings));
X            if ((status = (convert_tool_select(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        CHP(convert_m(block, settings));
X        if ((status = (convert_m(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHP(convert_g(block, settings));
X        if ((status = (convert_g(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        if (block->m_modes[4] ISNT -1)            /* converts m0, m1, m2, m30, or m60 */
X        if (block->m_modes[4] != -1)             
N        {
N            status SET_TO convert_stop(block, settings);
X            status = convert_stop(block, settings);
N            if (status IS RS274NGC_EXIT)
X            if (status == 1)
N                return RS274NGC_EXIT;
X                return 1;
N            else if (status ISNT RS274NGC_OK)
X            else if (status != 0)
N                ERP(status);
X                if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else return status;
N        }
N        return ((settings->probe_flag IS ON) ? RS274NGC_EXECUTE_FINISH: RS274NGC_OK);
X        return ((settings->probe_flag == 1) ? 2: 0);
N    }
N
N   /****************************************************************************/
N
N   /* execute_unary
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. the operation is unknown: NCE_BUG_UNKNOWN_OPERATION
N   2. the argument to acos is not between minus and plus one:
N   NCE_ARGUMENT_TO_ACOS_OUT_RANGE
N   3. the argument to asin is not between minus and plus one:
N   NCE_ARGUMENT_TO_ASIN_OUT_RANGE
N   4. the argument to the natural logarithm is not positive:
N   NCE_ZERO_OR_NEGATIVE_ARGUMENT_TO_LN
N   5. the argument to square root is negative:
N   NCE_NEGATIVE_ARGUMENT_TO_SQRT
N
N   Side effects:
N   The result from performing the operation on the value in double_ptr
N   is put into what double_ptr points at.
N
N   Called by: read_unary.
N
N   This executes the operations: ABS, ACOS, ASIN, COS, EXP, FIX, FUP, LN
N   ROUND, SIN, SQRT, TAN
N
N   All angle measures in the input or output are in degrees.
N
N   */
N
N    static int execute_unary(                     /* ARGUMENTS                       */
N    double * double_ptr,                          /* pointer to the operand          */
N    int operation)                                /* integer code for the operation  */
N    {
N        static char name[] SET_TO "execute_unary";
X        static char name[] = "execute_unary";
N        switch (operation)
N        {
N            case ABS:
X            case 1:
N                if (*double_ptr < 0.0)
N                    *double_ptr SET_TO (-1.0 * *double_ptr);
X                    *double_ptr = (-1.0 * *double_ptr);
N                break;
N            case ACOS:
X            case 2:
N                CHK(((*double_ptr < -1.0) OR (*double_ptr > 1.0)),
N                    NCE_ARGUMENT_TO_ACOS_OUT_OF_RANGE);
X                if (((*double_ptr < -1.0) || (*double_ptr > 1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 8; } else;
N                *double_ptr SET_TO acos(*double_ptr);
X                *double_ptr = acos(*double_ptr);
N                *double_ptr SET_TO ((*double_ptr * 180.0)/ PI);
X                *double_ptr = ((*double_ptr * 180.0)/ 3.1415926535897932);
N                break;
N            case ASIN:
X            case 3:
N                CHK(((*double_ptr < -1.0) OR (*double_ptr > 1.0)),
N                    NCE_ARGUMENT_TO_ASIN_OUT_OF_RANGE);
X                if (((*double_ptr < -1.0) || (*double_ptr > 1.0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 9; } else;
N                *double_ptr SET_TO asin(*double_ptr);
X                *double_ptr = asin(*double_ptr);
N                *double_ptr SET_TO ((*double_ptr * 180.0)/ PI);
X                *double_ptr = ((*double_ptr * 180.0)/ 3.1415926535897932);
N                break;
N            case COS:
X            case 5:
N                *double_ptr SET_TO cos((*double_ptr * PI)/180.0);
X                *double_ptr = cos((*double_ptr * 3.1415926535897932)/180.0);
N                break;
N            case EXP:
X            case 6:
N                *double_ptr SET_TO exp(*double_ptr);
X                *double_ptr = exp(*double_ptr);
N                break;
N            case FIX:
X            case 7:
N                *double_ptr SET_TO floor(*double_ptr);
X                *double_ptr = floor(*double_ptr);
N                break;
N            case FUP:
X            case 8:
N                *double_ptr SET_TO ceil(*double_ptr);
X                *double_ptr = ceil(*double_ptr);
N                break;
N            case LN:
X            case 9:
N                CHK((*double_ptr <= 0.0), NCE_ZERO_OR_NEGATIVE_ARGUMENT_TO_LN);
X                if ((*double_ptr <= 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 196; } else;
N                *double_ptr SET_TO log(*double_ptr);
X                *double_ptr = log(*double_ptr);
N                break;
N            case ROUND:
X            case 10:
N                *double_ptr SET_TO (double)
X                *double_ptr = (double)
N                    ((int) (*double_ptr + ((*double_ptr < 0.0) ? -0.5 : 0.5)));
N                break;
N            case SIN:
X            case 11:
N                *double_ptr SET_TO sin((*double_ptr * PI)/180.0);
X                *double_ptr = sin((*double_ptr * 3.1415926535897932)/180.0);
N                break;
N            case SQRT:
X            case 12:
N                CHK((*double_ptr < 0.0), NCE_NEGATIVE_ARGUMENT_TO_SQRT);
X                if ((*double_ptr < 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 121; } else;
N                *double_ptr SET_TO sqrt(*double_ptr);
X                *double_ptr = sqrt(*double_ptr);
N                break;
N            case TAN:
X            case 13:
N                *double_ptr SET_TO tan((*double_ptr * PI)/180.0);
X                *double_ptr = tan((*double_ptr * 3.1415926535897932)/180.0);
N                break;
N            default:
N                ERM(NCE_BUG_UNKNOWN_OPERATION);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 37; } else;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* find_arc_length
N
N   Returned Value: double (length of path between start and end points)
N
N   Side effects: none
N
N   Called by:
N   inverse_time_rate_arc
N   inverse_time_rate_arc2
N   inverse_time_rate_as
N
N   This calculates the length of the path that will be made relative to
N   the XYZ axes for a motion in which the X,Y,Z, motion is a circular or
N   helical arc with its axis parallel to the Z-axis. If tool length
N   compensation is on, this is the path of the tool tip; if off, the
N   length of the path of the spindle tip. Any rotary axis motion is
N   ignored.
N
N   If the arc is helical, it is coincident with the hypotenuse of a right
N   triangle wrapped around a cylinder. If the triangle is unwrapped, its
N   base is [the radius of the cylinder times the number of radians in the
N   helix] and its height is [z2 - z1], and the path length can be found
N   by the Pythagorean theorem.
N
N   This is written as though it is only for arcs whose axis is parallel to
N   the Z-axis, but it will serve also for arcs whose axis is parallel
N   to the X-axis or Y-axis, with suitable permutation of the arguments.
N
N   This works correctly when turn is zero (find_turn returns 0 in that
N   case).
N
N   */
N
N    static double find_arc_length(                /* ARGUMENTS                          */
N    double x1,                                    /* X-coordinate of start point        */
N    double y1,                                    /* Y-coordinate of start point        */
N    double z1,                                    /* Z-coordinate of start point        */
N    double center_x,                              /* X-coordinate of arc center         */
N    double center_y,                              /* Y-coordinate of arc center         */
N    int turn,                                     /* no. of full or partial circles CCW */
N    double x2,                                    /* X-coordinate of end point          */
N    double y2,                                    /* Y-coordinate of end point          */
N    double z2)                                    /* Z-coordinate of end point          */
N    {
N        double radius;
N        double theta;                             /* amount of turn of arc in radians */
N
N        radius SET_TO hypot((center_x - x1), (center_y - y1));
X        radius = hypot((center_x - x1), (center_y - y1));
N        theta SET_TO find_turn(x1, y1, center_x, center_y, turn, x2, y2);
X        theta = find_turn(x1, y1, center_x, center_y, turn, x2, y2);
N        if (z2 IS z1)
X        if (z2 == z1)
N            return (radius * fabs(theta));
N        else
N            return hypot((radius * theta), (z2 - z1));
N    }
N
N   /****************************************************************************/
N
N   /* find_ends
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The values of px, py, pz, aa_p, bb_p, and cc_p are set
N
N   Called by:
N   convert_arc
N   convert_home
N   convert_probe
N   convert_straight
N
N   This finds the coordinates of a point, "end", in the currently
N   active coordinate system, and sets the values of the pointers to the
N   coordinates (which are the arguments to the function).
N
N   In all cases, if no value for the coodinate is given in the block, the
N   current value for the coordinate is used. When cutter radius
N   compensation is on, this function is called before compensation
N   calculations are performed, so the current value of the programmed
N   point is used, not the current value of the actual current_point.
N
N   There are three cases for when the coordinate is included in the block:
N
N   1. G_53 is active. This means to interpret the coordinates as machine
N   coordinates. That is accomplished by adding the two offsets to the
N   coordinate given in the block.
N
N   2. Absolute coordinate mode is in effect. The coordinate in the block
N   is used.
N
N   3. Incremental coordinate mode is in effect. The coordinate in the
N   block plus either (i) the programmed current position - when cutter
N   radius compensation is in progress, or (2) the actual current position.
N
N   */
N
N    static int find_ends(                         /* ARGUMENTS                                    */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings,                       /* pointer to machine settings                  */
N    double * px,                                  /* pointer to end_x                             */
N    double * py,                                  /* pointer to end_y                             */
N    double * pz                                   /* pointer to end_z                             */
N#ifdef AA
S    , double * AA_p                               /* pointer to end_a                       *//*AA*/
N#endif
N#ifdef BB
S    , double * BB_p                               /* pointer to end_b                       *//*BB*/
N#endif
N#ifdef CC
S    , double * CC_p                               /* pointer to end_c                       *//*CC*/
N#endif
N    )
N    {
N        int mode;
N        int middle;
N        int comp;
N
N        mode SET_TO settings->distance_mode;
X        mode = settings->distance_mode;
N        middle SET_TO (settings->program_x ISNT UNKNOWN);
X        middle = (settings->program_x != 1e-20);
N        comp SET_TO (settings->cutter_comp_side ISNT OFF);
X        comp = (settings->cutter_comp_side != 0);
N
N        if (block->g_modes[0] IS G_53)            /* distance mode is absolute in this case */
X        if (block->g_modes[0] == 530)             
N        {
N#ifdef DEBUG_EMC
N            COMMENT("interpreter: offsets temporarily suspended");
N#endif
N            *px SET_TO (block->x_flag IS ON) ? (block->x_number -
X            *px = (block->x_flag == 1) ? (block->x_number -
N                (settings->origin_offset_x + settings->axis_offset_x)) :
N            settings->current_x;
N            *py SET_TO (block->y_flag IS ON) ? (block->y_number -
X            *py = (block->y_flag == 1) ? (block->y_number -
N                (settings->origin_offset_y + settings->axis_offset_y)) :
N            settings->current_y;
N            *pz SET_TO (block->z_flag IS ON) ? (block->z_number -
X            *pz = (block->z_flag == 1) ? (block->z_number -
N                (settings->tool_length_offset + settings->origin_offset_z
N                + settings->axis_offset_z)) : settings->current_z;
N#ifdef AA
S   /*AA*/
S            *AA_p SET_TO (block->a_flag IS ON) ? (block->a_number -
N    #endif
N    #ifdef AA
S   /*AA*/
S                (settings->AA_origin_offset + settings->AA_axis_offset)) :
N#endif
N#ifdef AA
S            settings->AA_current;                 /*AA*/
N#endif
N#ifdef BB
S   /*BB*/
S            *BB_p SET_TO (block->b_flag IS ON) ? (block->b_number -
N    #endif
N    #ifdef BB
S   /*BB*/
S                (settings->BB_origin_offset + settings->BB_axis_offset)) :
N#endif
N#ifdef BB
S            settings->BB_current;                 /*BB*/
N#endif
N#ifdef CC
S   /*CC*/
S            *CC_p SET_TO (block->c_flag IS ON) ? (block->c_number -
N    #endif
N    #ifdef CC
S   /*CC*/
S                (settings->tool_length_offset + settings->CC_origin_offset
N    #endif
N    #ifdef CC
S   /*CC*/
S                + settings->CC_axis_offset)) : settings->CC_current;
N#endif
N        }
N        else if (mode IS MODE_ABSOLUTE)
X        else if (mode == MODE_ABSOLUTE)
N        {
N            *px SET_TO (block->x_flag IS ON) ? block->x_number     :
X            *px = (block->x_flag == 1) ? block->x_number     :
N            (comp AND middle)     ? settings->program_x :
X            (comp && middle)     ? settings->program_x :
N            settings->current_x ;
N
N            *py SET_TO (block->y_flag IS ON) ? block->y_number     :
X            *py = (block->y_flag == 1) ? block->y_number     :
N            (comp AND middle)     ? settings->program_y :
X            (comp && middle)     ? settings->program_y :
N            settings->current_y ;
N
N            *pz SET_TO (block->z_flag IS ON) ? block->z_number     :
X            *pz = (block->z_flag == 1) ? block->z_number     :
N            settings->current_z ;
N#ifdef AA
S   /*AA*/
S            *AA_p SET_TO (block->a_flag IS ON) ? block->a_number     :
N#endif
N#ifdef AA
S            settings->AA_current ;                /*AA*/
N#endif
N#ifdef BB
S   /*BB*/
S            *BB_p SET_TO (block->b_flag IS ON) ? block->b_number     :
N#endif
N#ifdef BB
S            settings->BB_current ;                /*BB*/
N#endif
N#ifdef CC
S   /*CC*/
S            *CC_p SET_TO (block->c_flag IS ON) ? block->c_number     :
N#endif
N#ifdef CC
S            settings->CC_current ;                /*CC*/
N#endif
N        }
N        else                                      /* mode is MODE_INCREMENTAL */
N        {
N            *px SET_TO (block->x_flag IS ON)
X            *px = (block->x_flag == 1)
N                ? ((comp AND middle) ? (block->x_number + settings->program_x)
X                ? ((comp && middle) ? (block->x_number + settings->program_x)
N                : (block->x_number + settings->current_x))
N                : ((comp AND middle) ? settings->program_x
X                : ((comp && middle) ? settings->program_x
N                : settings->current_x);
N
N            *py SET_TO (block->y_flag IS ON)
X            *py = (block->y_flag == 1)
N                ? ((comp AND middle) ? (block->y_number + settings->program_y)
X                ? ((comp && middle) ? (block->y_number + settings->program_y)
N                : (block->y_number + settings->current_y))
N                : ((comp AND middle) ? settings->program_y
X                : ((comp && middle) ? settings->program_y
N                : settings->current_y);
N
N            *pz SET_TO (block->z_flag IS ON) ?
X            *pz = (block->z_flag == 1) ?
N                (settings->current_z + block->z_number) : settings->current_z;
N#ifdef AA
S            *AA_p SET_TO (block->a_flag IS ON) ?  /*AA*/
N    #endif
N    #ifdef AA
S   /*AA*/
S                (settings->AA_current + block->a_number) : settings->AA_current;
N#endif
N#ifdef BB
S            *BB_p SET_TO (block->b_flag IS ON) ?  /*BB*/
N    #endif
N    #ifdef BB
S   /*BB*/
S                (settings->BB_current + block->b_number) : settings->BB_current;
N#endif
N#ifdef CC
S            *CC_p SET_TO (block->c_flag IS ON) ?  /*CC*/
N    #endif
N    #ifdef CC
S   /*CC*/
S                (settings->CC_current + block->c_number) : settings->CC_current;
N#endif
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* find_relative
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The values of x2, y2, z2, aa_2, bb_2, and cc_2 are set.
N   (NOTE: aa_2 etc. are written with lower case letters in this
N   documentation because upper case would confuse the pre-preprocessor.)
N
N   Called by:
N   convert_home
N
N   This finds the coordinates in the current system, under the current
N   tool length offset, of a point (x1, y1, z1, aa_1, bb_1, cc_1) whose absolute
N   coordinates are known.
N
N   Don't confuse this with the inverse operation.
N
N   */
N
N    static int find_relative(                     /* ARGUMENTS                   */
N    double x1,                                    /* absolute x position         */
N    double y1,                                    /* absolute y position         */
N    double z1,                                    /* absolute z position         */
N#ifdef AA
S    double AA_1,             /* absolute a position         */ /*AA*/
N#endif
N#ifdef BB
S    double BB_1,             /* absolute b position         */ /*BB*/
N#endif
N#ifdef CC
S    double CC_1,             /* absolute c position         */ /*CC*/
N#endif
N    double * x2,                                  /* pointer to relative x       */
N    double * y2,                                  /* pointer to relative y       */
N    double * z2,                                  /* pointer to relative z       */
N#ifdef AA
S    double * AA_2,           /* pointer to relative a       */ /*AA*/
N#endif
N#ifdef BB
S    double * BB_2,           /* pointer to relative b       */ /*BB*/
N#endif
N#ifdef CC
S    double * CC_2,           /* pointer to relative c       */ /*CC*/
N#endif
N    setup_pointer settings)                       /* pointer to machine settings */
N    {
N        *x2 SET_TO (x1 - (settings->origin_offset_x + settings->axis_offset_x));
X        *x2 = (x1 - (settings->origin_offset_x + settings->axis_offset_x));
N        *y2 SET_TO (y1 - (settings->origin_offset_y + settings->axis_offset_y));
X        *y2 = (y1 - (settings->origin_offset_y + settings->axis_offset_y));
N        *z2 SET_TO (z1 - (settings->tool_length_offset +
X        *z2 = (z1 - (settings->tool_length_offset +
N            settings->origin_offset_z + settings->axis_offset_z));
N#ifdef AA
S   /*AA*/
S        *AA_2 SET_TO (AA_1 - (settings->AA_origin_offset +
N    #endif
N    #ifdef AA
S            settings->AA_axis_offset));           /*AA*/
N#endif
N#ifdef BB
S   /*BB*/
S        *BB_2 SET_TO (BB_1 - (settings->BB_origin_offset +
N    #endif
N    #ifdef BB
S            settings->BB_axis_offset));           /*BB*/
N#endif
N#ifdef CC
S   /*CC*/
S        *CC_2 SET_TO (CC_1 - (settings->CC_origin_offset +
N    #endif
N    #ifdef CC
S            settings->CC_axis_offset));           /*CC*/
N#endif
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* find_straight_length
N
N   Returned Value: double (length of path between start and end points)
N
N   Side effects: none
N
N   Called by:
N   inverse_time_rate_straight
N   inverse_time_rate_as
N
N   This calculates a number to use in feed rate calculations when inverse
N   time feed mode is used, for a motion in which X,Y,Z,A,B, and C each change
N   linearly or not at all from their initial value to their end value.
N
N   This is used when the feed_reference mode is CANON_XYZ, which is
N   always in rs274NGC.
N
N   If any of the X, Y, or Z axes move or the A-axis, B-axis, and C-axis
N   do not move, this is the length of the path relative to the XYZ axes
N   from the first point to the second, and any rotary axis motion is
N   ignored. The length is the simple Euclidean distance.
N
N   The formula for the Euclidean distance "length" of a move involving
N   only the A, B and C axes is based on a conversation with Jim Frohardt at
N   Boeing, who says that the Fanuc controller on their 5-axis machine
N   interprets the feed rate this way. Note that if only one rotary axis
N   moves, this formula returns the absolute value of that axis move,
N   which is what is desired.
N
N   */
N
N    static double find_straight_length(           /* ARGUMENTS   */
N    double x2,                                    /* X-coordinate of end point    */
N    double y2,                                    /* Y-coordinate of end point    */
N    double z2,                                    /* Z-coordinate of end point    */
N#ifdef AA
S    double AA_2,      /* A-coordinate of end point    */ /*AA*/
N#endif
N#ifdef BB
S    double BB_2,      /* B-coordinate of end point    */ /*BB*/
N#endif
N#ifdef CC
S    double CC_2,      /* C-coordinate of end point    */ /*CC*/
N#endif
N    double x1,                                    /* X-coordinate of start point  */
N    double y1,                                    /* Y-coordinate of start point  */
N    double z1                                     /* Z-coordinate of start point  */
N#ifdef AA
S    , double AA_1     /* A-coordinate of start point  */ /*AA*/
N#endif
N#ifdef BB
S    , double BB_1     /* B-coordinate of start point  */ /*BB*/
N#endif
N#ifdef CC
S    , double CC_1     /* C-coordinate of start point  */ /*CC*/
N#endif
N    )
N    {
N        if ((x1 ISNT x2) OR (y1 ISNT y2) OR (z1 ISNT z2) OR
X        if ((x1 != x2) || (y1 != y2) || (z1 != z2) ||
N            (1
N    #ifdef AA
S            AND (AA_2 IS AA_1)                    /*AA*/
N    #endif
N    #ifdef BB
S            AND (BB_2 IS BB_1)                    /*BB*/
N    #endif
N    #ifdef CC
S            AND (CC_2 IS CC_1)                    /*CC*/
N    #endif
N            ))                                    /* straight line */
N            return sqrt(pow((x2 - x1),2) + pow((y2 - y1),2) + pow((z2 - z1),2));
N        else
N            return sqrt(0 +
N        #ifdef AA
S                pow((AA_2 - AA_1), 2) +           /*AA*/
N        #endif
N        #ifdef BB
S                pow((BB_2 - BB_1), 2) +           /*BB*/
N        #endif
N        #ifdef CC
S                pow((CC_2 - CC_1), 2) +           /*CC*/
N        #endif
N                0);
N    }
N
N   /****************************************************************************/
N
N   /* find_turn
N
N   Returned Value: double (angle in radians between two radii of a circle)
N
N   Side effects: none
N
N   Called by: find_arc_length
N
N   All angles are in radians.
N
N   */
N
N    static double find_turn(                      /* ARGUMENTS                          */
N    double x1,                                    /* X-coordinate of start point        */
N    double y1,                                    /* Y-coordinate of start point        */
N    double center_x,                              /* X-coordinate of arc center         */
N    double center_y,                              /* Y-coordinate of arc center         */
N    int turn,                                     /* no. of full or partial circles CCW */
N    double x2,                                    /* X-coordinate of end point          */
N    double y2)                                    /* Y-coordinate of end point          */
N    {
N        double alpha;                             /* angle of first radius                      */
N        double beta;                              /* angle of second radius                     */
N        double theta;                             /* amount of turn of arc CCW - negative if CW */
N
N        if (turn IS 0)
X        if (turn == 0)
N            return 0.0;
N        alpha SET_TO atan2((y1 - center_y), (x1 - center_x));
X        alpha = atan2((y1 - center_y), (x1 - center_x));
N        beta SET_TO atan2((y2 - center_y), (x2 - center_x));
X        beta = atan2((y2 - center_y), (x2 - center_x));
N        if (turn > 0)
N        {
N            if (beta <= alpha)
N                beta SET_TO (beta + TWO_PI);
X                beta = (beta + 6.2831853071795864);
N            theta SET_TO ((beta - alpha) + ((turn - 1) * TWO_PI));
X            theta = ((beta - alpha) + ((turn - 1) * 6.2831853071795864));
N        }
N        else                                      /* turn < 0 */
N        {
N            if (alpha <= beta)
N                alpha SET_TO (alpha + TWO_PI);
X                alpha = (alpha + 6.2831853071795864);
N            theta SET_TO ((beta - alpha) + ((turn + 1) * TWO_PI));
X            theta = ((beta - alpha) + ((turn + 1) * 6.2831853071795864));
N        }
N        return (theta);
N    }
N
N   /****************************************************************************/
N
N   /* init_block
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   Values in the block are reset as described below.
N
N   Called by: parse_line
N
N   This system reuses the same block over and over, rather than building
N   a new one for each line of NC code. The block is re-initialized before
N   each new line of NC code is read.
N
N   The block contains many slots for values which may or may not be present
N   on a line of NC code. For some of these slots, there is a flag which
N   is turned on (at the time time value of the slot is read) if the item
N   is present.  For slots whose values are to be read which do not have a
N   flag, there is always some excluded range of values. Setting the
N   initial value of these slot to some number in the excluded range
N   serves to show that a value for that slot has not been read.
N
N   The rules for the indicators for slots whose values may be read are:
N   1. If the value may be an arbitrary real number (which is always stored
N   internally as a double), a flag is needed to indicate if a value has
N   been read. All such flags are initialized to OFF.
N   Note that the value itself is not initialized; there is no point in it.
N   2. If the value must be a non-negative real number (which is always stored
N   internally as a double), a value of -1.0 indicates the item is not present.
N   3. If the value must be an unsigned integer (which is always stored
N   internally as an int), a value of -1 indicates the item is not present.
N   (RS274/NGC does not use any negative integers.)
N   4. If the value is a character string (only the comment slot is one), the
N   first character is set to 0 (NULL).
N
N   */
N
N    static int init_block(                        /* ARGUMENTS                                     */
N    block_pointer block)                          /* pointer to a block to be initialized or reset */
N    {
N        int n;
N#ifdef AA
S        block->a_flag SET_TO OFF;                 /*AA*/
N#endif
N#ifdef BB
S        block->b_flag SET_TO OFF;                 /*BB*/
N#endif
N#ifdef CC
S        block->c_flag SET_TO OFF;                 /*CC*/
N#endif
N        block->comment[0] SET_TO 0;
X        block->comment[0] = 0;
N        block->d_number SET_TO -1;
X        block->d_number = -1;
N        block->f_number SET_TO -1.0;
X        block->f_number = -1.0;
N        for (n SET_TO 0; n < 14; n++)
X        for (n = 0; n < 14; n++)
N        {
N            block->g_modes[n] SET_TO -1;
X            block->g_modes[n] = -1;
N        }
N        block->h_number SET_TO -1;
X        block->h_number = -1;
N        block->i_flag SET_TO OFF;
X        block->i_flag = 0;
N        block->j_flag SET_TO OFF;
X        block->j_flag = 0;
N        block->k_flag SET_TO OFF;
X        block->k_flag = 0;
N        block->l_number SET_TO -1;
X        block->l_number = -1;
N        block->line_number SET_TO -1;
X        block->line_number = -1;
N        block->motion_to_be SET_TO -1;
X        block->motion_to_be = -1;
N        block->m_count SET_TO 0;
X        block->m_count = 0;
N        for (n SET_TO 0; n < 10; n++)
X        for (n = 0; n < 10; n++)
N        {
N            block->m_modes[n] SET_TO -1;
X            block->m_modes[n] = -1;
N        }
N        block->p_number SET_TO -1.0;
X        block->p_number = -1.0;
N        block->q_number SET_TO -1.0;
X        block->q_number = -1.0;
N        block->r_flag SET_TO OFF;
X        block->r_flag = 0;
N        block->s_number SET_TO -1.0;
X        block->s_number = -1.0;
N        block->t_number SET_TO -1;
X        block->t_number = -1;
N        block->x_flag SET_TO OFF;
X        block->x_flag = 0;
N        block->y_flag SET_TO OFF;
X        block->y_flag = 0;
N        block->z_flag SET_TO OFF;
X        block->z_flag = 0;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* inverse_time_rate_arc
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects: a call is made to SET_FEED_RATE and _setup.feed_rate is set.
N
N   Called by:
N   convert_arc2
N   convert_arc_comp1
N   convert_arc_comp2
N
N   This finds the feed rate needed by an inverse time move. The move
N   consists of an a single arc. Most of the work here is in finding the
N   length of the arc.
N
N   */
N
N    static int inverse_time_rate_arc(             /* ARGUMENTS                       */
N    double x1,                                    /* x coord of start point of arc            */
N    double y1,                                    /* y coord of start point of arc            */
N    double z1,                                    /* z coord of start point of arc            */
N    double cx,                                    /* x coord of center of arc                 */
N    double cy,                                    /* y coord of center of arc                 */
N    int turn,                                     /* turn of arc                              */
N    double x2,                                    /* x coord of end point of arc              */
N    double y2,                                    /* y coord of end point of arc              */
N    double z2,                                    /* z coord of end point of arc              */
N    block_pointer block,                          /* pointer to a block of RS274 instructions */
N    setup_pointer settings)                       /* pointer to machine settings              */
N    {
N        double length;
N        double rate;
N
N        length SET_TO find_arc_length (x1, y1, z1, cx, cy, turn, x2, y2, z2);
X        length = find_arc_length (x1, y1, z1, cx, cy, turn, x2, y2, z2);
N        rate SET_TO MAX(0.1, (length * block->f_number));
X        rate = ((0.1) > ((length * block->f_number)) ? (0.1) : ((length * block->f_number)));
N        SET_FEED_RATE (rate);
N        settings->feed_rate SET_TO rate;
X        settings->feed_rate = rate;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* inverse_time_rate_arc2
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects: a call is made to SET_FEED_RATE and _setup.feed_rate is set.
N
N   Called by: convert_arc_comp2
N
N   This finds the feed rate needed by an inverse time move in
N   convert_arc_comp2. The move consists of an extra arc and a main
N   arc. Most of the work here is in finding the lengths of the two arcs.
N
N   All rotary motion is assumed to occur on the extra arc, as done by
N   convert_arc_comp2.
N
N   All z motion is assumed to occur on the main arc, as done by
N   convert_arc_comp2.
N
N   */
N
N    static int inverse_time_rate_arc2(            /* ARGUMENTS */
N    double start_x,                               /* x coord of last program point, extra arc center x */
N    double start_y,                               /* y coord of last program point, extra arc center y */
N    int turn1,                                    /* turn of extra arc                                 */
N    double mid_x,                                 /* x coord of end point of extra arc                 */
N    double mid_y,                                 /* y coord of end point of extra arc                 */
N    double cx,                                    /* x coord of center of main arc                     */
N    double cy,                                    /* y coord of center of main arc                     */
N    int turn2,                                    /* turn of main arc                                  */
N    double end_x,                                 /* x coord of end point of main arc                  */
N    double end_y,                                 /* y coord of end point of main arc                  */
N    double end_z,                                 /* z coord of end point of main arc                  */
N    block_pointer block,                          /* pointer to a block of RS274 instructions          */
N    setup_pointer settings)                       /* pointer to machine settings                       */
N    {
N        double length;
N        double rate;
N
N        length SET_TO (find_arc_length (settings->current_x, settings->current_y,
X        length = (find_arc_length (settings->current_x, settings->current_y,
N            settings->current_z, start_x, start_y,
N            turn1, mid_x, mid_y, settings->current_z) +
N            find_arc_length(mid_x, mid_y, settings->current_z,
N            cx, cy, turn2, end_x, end_y, end_z));
N        rate SET_TO MAX(0.1, (length * block->f_number));
X        rate = ((0.1) > ((length * block->f_number)) ? (0.1) : ((length * block->f_number)));
N        SET_FEED_RATE (rate);
N        settings->feed_rate SET_TO rate;
X        settings->feed_rate = rate;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* inverse_time_rate_as
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects: a call is made to SET_FEED_RATE and _setup.feed_rate is set.
N
N   Called by: convert_straight_comp2
N
N   This finds the feed rate needed by an inverse time move in
N   convert_straight_comp2. The move consists of an extra arc and a straight
N   line. Most of the work here is in finding the lengths of the arc and
N   the line.
N
N   All rotary motion is assumed to occur on the arc, as done by
N   convert_straight_comp2.
N
N   All z motion is assumed to occur on the line, as done by
N   convert_straight_comp2.
N
N   */
N
N    static int inverse_time_rate_as(              /* ARGUMENTS */
N    double start_x,                               /* x coord of last program point, extra arc center x */
N    double start_y,                               /* y coord of last program point, extra arc center y */
N    int turn,                                     /* turn of extra arc                                 */
N    double mid_x,                                 /* x coord of end point of extra arc                 */
N    double mid_y,                                 /* y coord of end point of extra arc                 */
N    double end_x,                                 /* x coord of end point of straight line             */
N    double end_y,                                 /* y coord of end point of straight line             */
N    double end_z,                                 /* z coord of end point of straight line             */
N#ifdef AA
S    double AA_end,                                /* A coord of end point of straight line       *//*AA*/
N#endif
N#ifdef BB
S    double BB_end,                                /* B coord of end point of straight line       *//*BB*/
N#endif
N#ifdef CC
S    double CC_end,                                /* C coord of end point of straight line       *//*CC*/
N#endif
N    block_pointer block,                          /* pointer to a block of RS274 instructions          */
N    setup_pointer settings)                       /* pointer to machine settings                       */
N    {
N        double length;
N        double rate;
N
N        length SET_TO (find_arc_length (settings->current_x, settings->current_y,
X        length = (find_arc_length (settings->current_x, settings->current_y,
N            settings->current_z, start_x, start_y,
N            turn, mid_x, mid_y, settings->current_z) +
N            find_straight_length(end_x, end_y,
N            end_z
N    #ifdef AA
S            , AA_end
N    #endif
N
N    #ifdef BB
S            , BB_end
N    #endif
N
N    #ifdef CC
S            , CC_end
N    #endif
N            , mid_x, mid_y,
N            settings->current_z
N    #ifdef AA
S            , AA_end
N    #endif
N
N    #ifdef BB
S            , BB_end
N    #endif
N
N    #ifdef CC
S            , CC_end
N    #endif
N            ));
N        rate SET_TO MAX(0.1, (length * block->f_number));
X        rate = ((0.1) > ((length * block->f_number)) ? (0.1) : ((length * block->f_number)));
N        SET_FEED_RATE (rate);
N        settings->feed_rate SET_TO rate;
X        settings->feed_rate = rate;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* inverse_time_rate_straight
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects: a call is made to SET_FEED_RATE and _setup.feed_rate is set.
N
N   Called by:
N   convert_straight
N   convert_straight_comp1
N   convert_straight_comp2
N
N   This finds the feed rate needed by an inverse time straight move. Most
N   of the work here is in finding the length of the line.
N
N   */
N
N    static int inverse_time_rate_straight(        /* ARGUMENTS                    */
N    double end_x,                                 /* x coordinate of end point of straight line */
N    double end_y,                                 /* y coordinate of end point of straight line */
N    double end_z,                                 /* z coordinate of end point of straight line */
N#ifdef AA
S    double AA_end,                                /* A coordinate of end point of straight line *//*AA*/
N#endif
N#ifdef BB
S    double BB_end,                                /* B coordinate of end point of straight line *//*BB*/
N#endif
N#ifdef CC
S    double CC_end,                                /* C coordinate of end point of straight line *//*CC*/
N#endif
N    block_pointer block,                          /* pointer to a block of RS274 instructions   */
N    setup_pointer settings)                       /* pointer to machine settings                */
N    {
N        static char name[] SET_TO "inverse_time_rate_straight";
X        static char name[] = "inverse_time_rate_straight";
N        double length;
N        double rate;
N
N        length SET_TO find_straight_length
X        length = find_straight_length
N            (end_x, end_y, end_z
N    #ifdef AA
S            , AA_end
N    #endif
N
N    #ifdef BB
S            , BB_end
N    #endif
N
N    #ifdef CC
S            , CC_end
N    #endif
N            , settings->current_x,
N            settings->current_y, settings->current_z
N
N    #ifdef AA
S            , settings->AA_current
N    #endif
N
N    #ifdef BB
S            , settings->BB_current
N    #endif
N
N    #ifdef CC
S            , settings->CC_current
N    #endif
N            );
N        rate SET_TO MAX(0.1, (length * block->f_number));
X        rate = ((0.1) > ((length * block->f_number)) ? (0.1) : ((length * block->f_number)));
N        SET_FEED_RATE (rate);
N        settings->feed_rate SET_TO rate;
X        settings->feed_rate = rate;
N
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 8486 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N
N   /* parse_line
N
N   Returned Value: int
N   If any of the following functions returns an error code,
N   this returns that code.
N   init_block
N   read_items
N   enhance_block
N   check_items
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   One RS274 line is read into a block and the block is checked for
N   errors. System parameters may be reset.
N
N   Called by:  rs274ngc_read
N
N   */
N
N    static int parse_line(                        /* ARGUMENTS                            */
N    char * line,                                  /* array holding a line of RS274 code   */
N    block_pointer block,                          /* pointer to a block to be filled      */
N    setup_pointer settings)                       /* pointer to machine settings          */
N    {
N        static char name[] SET_TO "parse_line";
X        static char name[] = "parse_line";
N        int status;
N
N        CHP(init_block (block));
X        if ((status = (init_block (block))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHP(read_items(block, line, settings->parameters));
X        if ((status = (read_items(block, line, settings->parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHP(enhance_block(block, settings));
X        if ((status = (enhance_block(block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHP(check_items (block, settings));
X        if ((status = (check_items (block, settings))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* precedence
N
N   Returned Value: int
N   This returns an integer representing the precedence level of an_operator
N
N   Side Effects: None
N
N   Called by: read_real_expression
N
N   To add additional levels of operator precedence, edit this function.
N
N   */
N
N    static int precedence(                        /* ARGUMENTS  */
N    int an_operator)
N    {
N        if (an_operator IS RIGHT_BRACKET)
X        if (an_operator == 10)
N            return 1;
N        else if (an_operator IS POWER)
X        else if (an_operator == 3)
N            return 4;
N        else if (an_operator >= AND2)
X        else if (an_operator >= 5)
N            return 2;
N        else
N            return 3;
N    }
N
N   /****************************************************************************/
N
N   /* read_a
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not a:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. An a_coordinate has already been inserted in the block:
N   NCE_MULTIPLE_A_WORDS_ON_ONE_LINE.
N   3. A values are not allowed: NCE_CANNOT_USE_A_WORD.
N
N   Side effects:
N   counter is reset.
N   The a_flag in the block is turned on.
N   An a_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'a', indicating an a_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   The counter is then set to point to the character following.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   If the AA compiler flag is defined, the a_flag in the block is turned
N   on and the a_number in the block is set to the value read. If the
N   AA flag is not defined, (i) if the AXIS_ERROR flag is defined, that means
N   A values are not allowed, and an error value is returned, (ii) if the
N   AXIS_ERROR flag is not defined, nothing is done.
N
N   */
N
N    static int read_a(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_a";
X        static char name[] = "read_a";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'a'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'a')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N#ifdef AA
S   /*AA*/
S        CHK((block->a_flag ISNT OFF), NCE_MULTIPLE_A_WORDS_ON_ONE_LINE);
N#endif
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N#ifdef AA
S        block->a_flag SET_TO ON;
S        block->a_number SET_TO value;
N#else
N#ifdef AXIS_ERROR
S        ERM(NCE_CANNOT_USE_A_WORD);
N#endif                                    /* ifdef AXIS_ERROR */
N#endif                                    /* ifdef AA */
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_atan
N
N   Returned Value: int
N   If read_real_expression returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character to read is not a slash:
N   NCE_SLASH_MISSING_AFTER_FIRST_ATAN_ARGUMENT
N   2. The second character to read is not a left bracket:
N   NCE_LEFT_BRACKET_MISSING_AFTER_SLASH_WITH_ATAN
N
N   Side effects:
N   The computed value is put into what double_ptr points at.
N   The counter is reset to point to the first character after the
N   characters which make up the value.
N
N   Called by:
N   read_unary
N
N   When this function is called, the characters "atan" and the first
N   argument have already been read, and the value of the first argument
N   is stored in double_ptr.  This function attempts to read a slash and
N   the second argument to the atan function, starting at the index given
N   by the counter and then to compute the value of the atan operation
N   applied to the two arguments.  The computed value is inserted into
N   what double_ptr points at.
N
N   The computed value is in the range from -180 degrees to +180 degrees.
N   The range is not specified in the RS274/NGC manual [NCMS, page 51],
N   although using degrees (not radians) is specified.
N
N   */
N
N    static int read_atan(                         /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on line      */
N    double * double_ptr,                          /* pointer to double to be read                   */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_atan";
X        static char name[] = "read_atan";
N        double argument2;
N        int status;
N
N        CHK((line [*counter] ISNT '/'), NCE_SLASH_MISSING_AFTER_FIRST_ATAN_ARGUMENT);
X        if ((line [*counter] != '/')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 156; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((line[*counter] ISNT '['),
N            NCE_LEFT_BRACKET_MISSING_AFTER_SLASH_WITH_ATAN);
X        if ((line[*counter] != '[')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 96; } else;
N        CHP(read_real_expression (line, counter, &argument2, parameters));
X        if ((status = (read_real_expression (line, counter, &argument2, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N   /* value in radians */
N        *double_ptr SET_TO atan2(*double_ptr, argument2);
X        *double_ptr = atan2(*double_ptr, argument2);
N   /* convert to degrees */
N        *double_ptr SET_TO ((*double_ptr * 180.0)/PI);
X        *double_ptr = ((*double_ptr * 180.0)/3.1415926535897932);
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_b
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not b:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A b_coordinate has already been inserted in the block:
N   NCE_MULTIPLE_B_WORDS_ON_ONE_LINE.
N   3. B values are not allowed: NCE_CANNOT_USE_B_WORD
N
N   Side effects:
N   counter is reset.
N   The b_flag in the block is turned on.
N   A b_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'b', indicating a b_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   The counter is then set to point to the character following.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   If the BB compiler flag is defined, the b_flag in the block is turned
N   on and the b_number in the block is set to the value read. If the
N   BB flag is not defined, (i) if the AXIS_ERROR flag is defined, that means
N   B values are not allowed, and an error value is returned, (ii) if the
N   AXIS_ERROR flag is not defined, nothing is done.
N
N   */
N
N    static int read_b(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_b";
X        static char name[] = "read_b";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'b'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'b')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N#ifdef BB
S   /*BB*/
S        CHK((block->b_flag ISNT OFF), NCE_MULTIPLE_B_WORDS_ON_ONE_LINE);
N#endif
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N#ifdef BB
S        block->b_flag SET_TO ON;
S        block->b_number SET_TO value;
N#else
N#ifdef AXIS_ERROR
S        ERM(NCE_CANNOT_USE_B_WORD);
N#endif                                    /* ifdef AXIS_ERROR */
N#endif                                    /* ifdef BB */
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_c
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not c:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. An c_coordinate has already been inserted in the block:
N   NCE_MULTIPLE_C_WORDS_ON_ONE_LINE
N   3. C values are not allowed: NCE_CANNOT_USE_C_WORD
N
N   Side effects:
N   counter is reset.
N   The c_flag in the block is turned on.
N   A c_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'c', indicating an c_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   The counter is then set to point to the character following.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   If the CC compiler flag is defined, the c_flag in the block is turned
N   on and the c_number in the block is set to the value read. If the
N   CC flag is not defined, (i) if the AXIS_ERROR flag is defined, that means
N   C values are not allowed, and an error value is returned, (ii) if the
N   AXIS_ERROR flag is not defined, nothing is done.
N
N   */
N
N    static int read_c(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_c";
X        static char name[] = "read_c";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'c'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'c')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N#ifdef CC
S   /*CC*/
S        CHK((block->c_flag ISNT OFF), NCE_MULTIPLE_C_WORDS_ON_ONE_LINE);
N#endif
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N#ifdef CC
S        block->c_flag SET_TO ON;
S        block->c_number SET_TO value;
N#else
N#ifdef AXIS_ERROR
S        ERM(NCE_CANNOT_USE_C_WORD);
N#endif                                    /* ifdef AXIS_ERROR */
N#endif                                    /* ifdef CC */
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_comment
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not '(' ,
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N
N   Side effects:
N   The counter is reset to point to the character following the comment.
N   The comment string, without parentheses, is copied into the comment
N   area of the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character '(', indicating a comment is
N   beginning. The function reads characters of the comment, up to and
N   including the comment closer ')'.
N
N   It is expected that the format of a comment will have been checked (by
N   read_text or read_keyboard_line) and bad format comments will
N   have prevented the system from getting this far, so that this function
N   can assume a close parenthesis will be found when an open parenthesis
N   has been found, and that comments are not nested.
N
N   The "parameters" argument is not used in this function. That argument is
N   present only so that this will have the same argument list as the other
N   "read_XXX" functions called using a function pointer by read_one_item.
N
N   */
N
N    static int read_comment(                      /* ARGUMENTS                                     */
N    char * line,                                  /* string: line of RS274 code being processed    */
N    int * counter,                                /* pointer to a counter for position on the line */
N    block_pointer block,                          /* pointer to a block being filled from the line */
N    double * parameters)                          /* array of system parameters                    */
N    {
N        static char name[] SET_TO "read_comment";
X        static char name[] = "read_comment";
N        int n;
N
N        CHK((line[*counter] ISNT '('), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != '(')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        (*counter)++;
N        for (n SET_TO 0; line[*counter] ISNT ')' ; (*counter)++, n++)
X        for (n = 0; line[*counter] != ')' ; (*counter)++, n++)
N        {
N            block->comment[n] SET_TO line[*counter];
X            block->comment[n] = line[*counter];
N        }
N        block->comment[n] SET_TO 0;
X        block->comment[n] = 0;
N        (*counter)++;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_d
N
N   Returned Value: int
N   If read_integer_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not d:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A d_number has already been inserted in the block:
N   NCE_MULTIPLE_D_WORDS_ON_ONE_LINE
N   3. The d_number is negative: NCE_NEGATIVE_D_WORD_TOOL_RADIUS_INDEX_USED
N   4. The d_number is more than _setup.tool_max: NCE_TOOL_RADIUS_INDEX_TOO_BIG
N
N   Side effects:
N   counter is reset to the character following the tool number.
N   A d_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'd', indicating an index into a
N   table of tool diameters.  The function reads characters which give the
N   (integer) value of the index. The value may not be more than
N   _setup.tool_max and may not be negative, but it may be zero. The range
N   is checked here.
N
N   read_integer_value allows a minus sign, so a check for a negative value
N   is made here, and the parameters argument is also needed.
N
N   */
N
N    static int read_d(                            /* ARGUMENTS                                     */
N    char * line,                                  /* string: line of RS274 code being processed    */
N    int * counter,                                /* pointer to a counter for position on the line */
N    block_pointer block,                          /* pointer to a block being filled from the line */
N    double * parameters)                          /* array of system parameters                    */
N    {
N        static char name[] SET_TO "read_d";
X        static char name[] = "read_d";
N        int value;
N        int status;
N
N        CHK((line[*counter] ISNT 'd'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'd')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->d_number > -1), NCE_MULTIPLE_D_WORDS_ON_ONE_LINE);
X        if ((block->d_number > -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 105; } else;
N        CHP(read_integer_value(line, counter, &value, parameters));
X        if ((status = (read_integer_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value < 0), NCE_NEGATIVE_D_WORD_TOOL_RADIUS_INDEX_USED);
X        if ((value < 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 122; } else;
N        CHK((value > _setup.tool_max), NCE_TOOL_RADIUS_INDEX_TOO_BIG);
X        if ((value > _setup . tool_max)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 166; } else;
N        block->d_number SET_TO value;
X        block->d_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_f
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not f:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. An f_number has already been inserted in the block:
N   NCE_MULTIPLE_F_WORDS_ON_ONE_LINE
N   3. The f_number is negative: NCE_NEGATIVE_F_WORD_USED
N
N   Side effects:
N   counter is reset to point to the first character following the f_number.
N   The f_number is inserted in block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'f'. The function reads characters
N   which tell how to set the f_number, up to the start of the next item
N   or the end of the line. This information is inserted in the block.
N
N   The value may be a real number or something that evaluates to a real
N   number, so read_real_value is used to read it. Parameters may be
N   involved, so the parameters argument is required. The value is always
N   a feed rate.
N
N   */
N
N    static int read_f(                            /* ARGUMENTS                                     */
N    char * line,                                  /* string: line of RS274 code being processed    */
N    int * counter,                                /* pointer to a counter for position on the line */
N    block_pointer block,                          /* pointer to a block being filled from the line */
N    double * parameters)                          /* array of system parameters                    */
N    {
N        static char name[] SET_TO "read_f";
X        static char name[] = "read_f";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'f'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'f')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->f_number > -1.0), NCE_MULTIPLE_F_WORDS_ON_ONE_LINE);
X        if ((block->f_number > -1.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 106; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value < 0.0), NCE_NEGATIVE_F_WORD_USED);
X        if ((value < 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 123; } else;
N        block->f_number SET_TO value;
X        block->f_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_g
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not g:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. The value is negative: NCE_NEGATIVE_G_CODE_USED
N   3. The value differs from a number ending in an even tenth by more
N   than 0.0001: NCE_G_CODE_OUT_OF_RANGE
N   4. The value is greater than 99.9: NCE_G_CODE_OUT_OF_RANGE
N   5. The value is not the number of a valid g code: NCE_UNKNOWN_G_CODE_USED
N   6. Another g code from the same modal group has already been
N   inserted in the block: NCE_TWO_G_CODES_USED_FROM_SAME_MODAL_GROUP
N
N   Side effects:
N   counter is reset to the character following the end of the g_code.
N   A g code is inserted as the value of the appropriate mode in the
N   g_modes array in the block.
N   The g code counter in the block is increased by 1.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'g', indicating a g_code.  The
N   function reads characters which tell how to set the g_code.
N
N   The RS274/NGC manual [NCMS, page 51] allows g_codes to be represented
N   by expressions and provide [NCMS, 71 - 73] that a g_code must evaluate
N   to to a number of the form XX.X (59.1, for example). The manual does not
N   say how close an expression must come to one of the allowed values for
N   it to be legitimate. Is 59.099999 allowed to mean 59.1, for example?
N   In the interpreter, we adopt the convention that the evaluated number
N   for the g_code must be within 0.0001 of a value of the form XX.X
N
N   To simplify the handling of g_codes, we convert them to integers by
N   multiplying by 10 and rounding down or up if within 0.001 of an
N   integer. Other functions that deal with g_codes handle them
N   symbolically, however. The symbols are defined in rs274NGC.hh
N   where G_1 is 10, G_83 is 830, etc.
N
N   This allows any number of g_codes on one line, provided that no two
N   are in the same modal group.
N
N   */
N
N    static int read_g(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_g";
X        static char name[] = "read_g";
N        double value_read;
N        int value;
N        int mode;
N        int status;
N
N        CHK((line[*counter] ISNT 'g'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'g')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHP(read_real_value(line, counter, &value_read, parameters));
X        if ((status = (read_real_value(line, counter, &value_read, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        value_read SET_TO (10.0 * value_read);
X        value_read = (10.0 * value_read);
N        value SET_TO (int)floor(value_read);
X        value = (int)floor(value_read);
N
N        if ((value_read - value) > 0.999)
N            value SET_TO (int)ceil(value_read);
X            value = (int)ceil(value_read);
N        else if ((value_read - value) > 0.001)
N            ERM(NCE_G_CODE_OUT_OF_RANGE);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 84; } else;
N
N        CHK((value > 999), NCE_G_CODE_OUT_OF_RANGE);
X        if ((value > 999)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 84; } else;
N        CHK((value < 0), NCE_NEGATIVE_G_CODE_USED);
X        if ((value < 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 124; } else;
N        mode SET_TO _gees[value];
X        mode = _gees[value];
N        CHK((mode IS -1), NCE_UNKNOWN_G_CODE_USED);
X        if ((mode == -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 173; } else;
N        CHK((block->g_modes[mode] ISNT -1),
N            NCE_TWO_G_CODES_USED_FROM_SAME_MODAL_GROUP);
X        if ((block->g_modes[mode] != -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 168; } else;
N        block->g_modes[mode] SET_TO value;
X        block->g_modes[mode] = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_h
N
N   Returned Value: int
N   If read_integer_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not h:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. An h_number has already been inserted in the block:
N   NCE_MULTIPLE_H_WORDS_ON_ONE_LINE
N   3. The value is negative: NCE_NEGATIVE_H_WORD_TOOL_LENGTH_OFFSET_INDEX_USED
N   4. The value is greater than _setup.tool_max:
N   NCE_TOOL_LENGTH_OFFSET_INDEX_TOO_BIG
N
N   Side effects:
N   counter is reset to the character following the h_number.
N   An h_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'h', indicating a tool length
N   offset index.  The function reads characters which give the (integer)
N   value of the tool length offset index (not the actual distance of the
N   offset).
N
N   */
N
N    static int read_h(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_h";
X        static char name[] = "read_h";
N        int value;
N        int status;
N
N        CHK((line[*counter] ISNT 'h'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'h')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->h_number > -1), NCE_MULTIPLE_H_WORDS_ON_ONE_LINE);
X        if ((block->h_number > -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 107; } else;
N        CHP(read_integer_value(line, counter, &value, parameters));
X        if ((status = (read_integer_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value < 0), NCE_NEGATIVE_H_WORD_TOOL_LENGTH_OFFSET_INDEX_USED);
X        if ((value < 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 125; } else;
N        CHK((value > _setup.tool_max), NCE_TOOL_LENGTH_OFFSET_INDEX_TOO_BIG);
X        if ((value > _setup . tool_max)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 164; } else;
N        block->h_number SET_TO value;
X        block->h_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_i
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not i:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. An i_coordinate has already been inserted in the block:
N   NCE_MULTIPLE_I_WORDS_ON_ONE_LINE
N
N   Side effects:
N   counter is reset.
N   The i_flag in the block is turned on.
N   An i_coordinate setting is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'i', indicating a i_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   This information is inserted in the block. The counter is then set to
N   point to the character following.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   */
N
N    static int read_i(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274 code being processed     */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_i";
X        static char name[] = "read_i";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'i'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'i')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->i_flag ISNT OFF), NCE_MULTIPLE_I_WORDS_ON_ONE_LINE);
X        if ((block->i_flag != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 108; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        block->i_flag SET_TO ON;
X        block->i_flag = 1;
N        block->i_number SET_TO value;
X        block->i_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_integer_unsigned
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, RS274NGC_OK is returned.
N   1. The first character is not a digit: NCE_BAD_FORMAT_UNSIGNED_INTEGER
N   2. sscanf fails: NCE_SSCANF_FAILED
N
N   Side effects:
N   The number read from the line is put into what integer_ptr points at.
N
N   Called by: read_line_number
N
N   This reads an explicit unsigned (positive) integer from a string,
N   starting from the position given by *counter. It expects to find one
N   or more digits. Any character other than a digit terminates reading
N   the integer. Note that if the first character is a sign (+ or -),
N   an error will be reported (since a sign is not a digit).
N
N   */
N
N    static int read_integer_unsigned(             /* ARGUMENTS                       */
N    char * line,                                  /* string: line of RS274 code being processed    */
N    int * counter,                                /* pointer to a counter for position on the line */
N    int * integer_ptr)                            /* pointer to the value being read               */
N    {
N        static char name[] SET_TO "read_integer_unsigned";
X        static char name[] = "read_integer_unsigned";
N        int n;
N        char c;
N
N        for (n SET_TO *counter; ; n++)
X        for (n = *counter; ; n++)
N        {
N            c SET_TO line[n];
X            c = line[n];
N            if ((c < 48) OR (c > 57))
X            if ((c < 48) || (c > 57))
N                break;
N        }
N        CHK((n IS *counter), NCE_BAD_FORMAT_UNSIGNED_INTEGER);
X        if ((n == *counter)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 13; } else;
N        if (sscanf(line + *counter, "%d", integer_ptr) IS 0)
X        if (sscanf(line + *counter, "%d", integer_ptr) == 0)
N            ERM(NCE_SSCANF_FAILED);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 161; } else;
N        *counter SET_TO n;
X        *counter = n;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_integer_value
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The returned value is not close to an integer:
N   NCE_NON_INTEGER_VALUE_FOR_INTEGER
N
N   Side effects:
N   The number read from the line is put into what integer_ptr points at.
N
N   Called by:
N   read_d
N   read_l
N   read_h
N   read_m
N   read_parameter
N   read_parameter_setting
N   read_t
N
N   This reads an integer (positive, negative or zero) from a string,
N   starting from the position given by *counter. The value being
N   read may be written with a decimal point or it may be an expression
N   involving non-integers, as long as the result comes out within 0.0001
N   of an integer.
N
N   This proceeds by calling read_real_value and checking that it is
N   close to an integer, then returning the integer it is close to.
N
N   */
N
N    static int read_integer_value(                /* ARGUMENTS                                 */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    int * integer_ptr,                            /* pointer to the value being read                */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_integer_value";
X        static char name[] = "read_integer_value";
N        double float_value;
N        int status;
N
N        CHP(read_real_value(line, counter, &float_value, parameters));
X        if ((status = (read_real_value(line, counter, &float_value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        *integer_ptr SET_TO (int)floor(float_value);
X        *integer_ptr = (int)floor(float_value);
N        if ((float_value - *integer_ptr) > 0.9999)
N        {
N            *integer_ptr SET_TO (int)ceil(float_value);
X            *integer_ptr = (int)ceil(float_value);
N        }
N        else if ((float_value - *integer_ptr) > 0.0001)
N            ERM(NCE_NON_INTEGER_VALUE_FOR_INTEGER);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 135; } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_items
N
N   Returned Value: int
N   If read_line_number or read_one_item returns an error code,
N   this returns that code.
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   One line of RS274 code is read and data inserted into a block.
N   The counter which is passed around among the readers is initialized.
N   System parameters may be reset.
N
N   Called by: parse_line
N
N   */
N
N    static int read_items(                        /* ARGUMENTS                                      */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_items";
X        static char name[] = "read_items";
N        int counter;
N        int length;
N        int status;
N
N        length SET_TO strlen(line);
X        length = strlen(line);
N        counter SET_TO 0;
X        counter = 0;
N
N        if (line[counter] IS '/')                 /* skip the slash character if first */
X        if (line[counter] == '/')                  
N            counter++;
N        if (line[counter] IS 'n')
X        if (line[counter] == 'n')
N        {
N            CHP(read_line_number(line, &counter, block));
X            if ((status = (read_line_number(line, &counter, block))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        for ( ; counter < length; )
N        {
N            CHP(read_one_item (line, &counter, block, parameters));
X            if ((status = (read_one_item (line, &counter, block, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_j
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not j:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A j_coordinate has already been inserted in the block.
N   NCE_MULTIPLE_J_WORDS_ON_ONE_LINE
N
N   Side effects:
N   counter is reset.
N   The j_flag in the block is turned on.
N   A j_coordinate setting is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'j', indicating a j_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   This information is inserted in the block. The counter is then set to
N   point to the character following.
N
N   The value may be a real number or something that evaluates to a real
N   number, so read_real_value is used to read it. Parameters may be
N   involved.
N
N   */
N
N    static int read_j(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274 code being processed     */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_j";
X        static char name[] = "read_j";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'j'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'j')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->j_flag ISNT OFF), NCE_MULTIPLE_J_WORDS_ON_ONE_LINE);
X        if ((block->j_flag != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 109; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        block->j_flag SET_TO ON;
X        block->j_flag = 1;
N        block->j_number SET_TO value;
X        block->j_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_k
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not k:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A k_coordinate has already been inserted in the block:
N   NCE_MULTIPLE_K_WORDS_ON_ONE_LINE
N
N   Side effects:
N   counter is reset.
N   The k_flag in the block is turned on.
N   A k_coordinate setting is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'k', indicating a k_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   This information is inserted in the block. The counter is then set to
N   point to the character following.
N
N   The value may be a real number or something that evaluates to a real
N   number, so read_real_value is used to read it. Parameters may be
N   involved.
N
N   */
N
N    static int read_k(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274 code being processed     */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_k";
X        static char name[] = "read_k";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'k'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'k')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->k_flag ISNT OFF), NCE_MULTIPLE_K_WORDS_ON_ONE_LINE);
X        if ((block->k_flag != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 110; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        block->k_flag SET_TO ON;
X        block->k_flag = 1;
N        block->k_number SET_TO value;
X        block->k_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_l
N
N   Returned Value: int
N   If read_integer_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not l:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. An l_number has already been inserted in the block:
N   NCE_MULTIPLE_L_WORDS_ON_ONE_LINE
N   3. the l_number is negative: NCE_NEGATIVE_L_WORD_USED
N
N   Side effects:
N   counter is reset to the character following the l number.
N   An l code is inserted in the block as the value of l.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'l', indicating an L code.
N   The function reads characters which give the (integer) value of the
N   L code.
N
N   L codes are used for:
N   1. the number of times a canned cycle should be repeated.
N   2. a key with G10.
N
N   */
N
N    static int read_l(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_l";
X        static char name[] = "read_l";
N        int value;
N        int status;
N
N        CHK((line[*counter] ISNT 'l'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'l')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->l_number > -1), NCE_MULTIPLE_L_WORDS_ON_ONE_LINE);
X        if ((block->l_number > -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 111; } else;
N        CHP(read_integer_value(line, counter, &value, parameters));
X        if ((status = (read_integer_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value < 0), NCE_NEGATIVE_L_WORD_USED);
X        if ((value < 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 126; } else;
N        block->l_number SET_TO value;
X        block->l_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_line_number
N
N   Returned Value: int
N   If read_integer_unsigned returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not n:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. The line number is too large (more than 99999):
N   NCE_LINE_NUMBER_GREATER_THAN_99999
N
N   Side effects:
N   counter is reset to the character following the line number.
N   A line number is inserted in the block.
N
N   Called by: read_items
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'n', indicating a line number.
N   The function reads characters which give the (integer) value of the
N   line number.
N
N   Note that extra initial zeros in a line number will not cause the
N   line number to be too large.
N
N   */
N
N    static int read_line_number(                  /* ARGUMENTS                               */
N    char * line,                                  /* string: line of RS274    code being processed  */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block)                          /* pointer to a block being filled from the line  */
N    {
N        static char name[] SET_TO "read_line_number";
X        static char name[] = "read_line_number";
N        int value;
N        int status;
N
N        CHK((line[*counter] ISNT 'n'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'n')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHP(read_integer_unsigned(line, counter, &value));
X        if ((status = (read_integer_unsigned(line, counter, &value))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value > 99999), NCE_LINE_NUMBER_GREATER_THAN_99999);
X        if ((value > 99999)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 98; } else;
N        block->line_number SET_TO value;
X        block->line_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_m
N
N   Returned Value:
N   If read_integer_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not m:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. The value is negative: NCE_NEGATIVE_M_CODE_USED
N   3. The value is greater than 99: NCE_M_CODE_GREATER_THAN_99
N   4. The m code is not known to the system: NCE_UNKNOWN_M_CODE_USED
N   5. Another m code in the same modal group has already been read:
N   NCE_TWO_M_CODES_USED_FROM_SAME_MODAL_GROUP
N
N   Side effects:
N   counter is reset to the character following the m number.
N   An m code is inserted as the value of the appropriate mode in the
N   m_modes array in the block.
N   The m code counter in the block is increased by 1.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'm', indicating an m code.
N   The function reads characters which give the (integer) value of the
N   m code.
N
N   read_integer_value allows a minus sign, so a check for a negative value
N   is needed here, and the parameters argument is also needed.
N
N   */
N
N    static int read_m(                            /* ARGUMENTS                                     */
N    char * line,                                  /* string: line of RS274 code being processed    */
N    int * counter,                                /* pointer to a counter for position on the line */
N    block_pointer block,                          /* pointer to a block being filled from the line */
N    double * parameters)                          /* array of system parameters                    */
N    {
N        static char name[] SET_TO "read_m";
X        static char name[] = "read_m";
N        int value;
N        int mode;
N        int status;
N
N        CHK((line[*counter] ISNT 'm'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'm')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHP(read_integer_value(line, counter, &value, parameters));
X        if ((status = (read_integer_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value < 0), NCE_NEGATIVE_M_CODE_USED);
X        if ((value < 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 127; } else;
N        CHK((value > 99), NCE_M_CODE_GREATER_THAN_99);
X        if ((value > 99)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 100; } else;
N        mode SET_TO _ems[value];
X        mode = _ems[value];
N        CHK((mode IS -1), NCE_UNKNOWN_M_CODE_USED);
X        if ((mode == -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 174; } else;
N        CHK((block->m_modes[mode] ISNT -1),
N            NCE_TWO_M_CODES_USED_FROM_SAME_MODAL_GROUP);
X        if ((block->m_modes[mode] != -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 169; } else;
N        block->m_modes[mode] SET_TO value;
X        block->m_modes[mode] = value;
N        block->m_count++;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_one_item
N
N   Returned Value: int
N   If a reader function which is called returns an error code, that
N   error code is returned.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. the first character read is not a known character for starting a
N   word: NCE_BAD_CHARACTER_USED
N
N   Side effects:
N   This function reads one item from a line of RS274/NGC code and inserts
N   the information in a block. System parameters may be reset.
N
N   Called by: read_items.
N
N   When this function is called, the counter is set so that the position
N   being considered is the first position of a word. The character at
N   that position must be one known to the system.  In this version those
N   characters are: a,b,c,d,f,g,h,i,j,k,l,m,n,p,q,r,s,t,x,y,z,(,#.
N   However, read_items calls read_line_number directly if the first word
N   begins with n, so no read function is included in the "_readers" array
N   for the letter n. Thus, if an n word is encountered in the middle of
N   a line, this function reports NCE_BAD_CHARACTER_USED.
N
N   The function looks for a letter or special character and calls a
N   selected function according to what the letter or character is.  The
N   selected function will be responsible to consider all the characters
N   that comprise the remainder of the item, and reset the pointer so that
N   it points to the next character after the end of the item (which may be
N   the end of the line or the first character of another item).
N
N   After an item is read, the counter is set at the index of the
N   next unread character. The item data is stored in the block.
N
N   It is expected that the format of a comment will have been checked;
N   this is being done by close_and_downcase. Bad format comments will
N   have prevented the system from getting this far, so that this function
N   can assume a close parenthesis will be found when an open parenthesis
N   has been found, and that comments are not nested.
N
N   */
N
N    static int read_one_item(                     /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_one_item";
X        static char name[] = "read_one_item";
N        int status;
N        read_function_pointer function_pointer;
N        char letter;
N
N        letter SET_TO line[*counter];             /* check if in array range */
X        letter = line[*counter];              
W "rs274ngc_pre.c" 9649 9 pointless comparison of unsigned integer with zero
N        CHK(((letter < 0) OR (letter > 'z')), NCE_BAD_CHARACTER_USED);
X        if (((letter < 0) || (letter > 'z'))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 12; } else;
N        function_pointer SET_TO _readers[letter];
X        function_pointer = _readers[letter];
N        CHK((function_pointer IS 0), NCE_BAD_CHARACTER_USED);
X        if ((function_pointer == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 12; } else;
N        CHP(function_pointer(line, counter, block, parameters));
X        if ((status = (function_pointer(line, counter, block, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_operation
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The operation is unknown:
N   NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_A
N   NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_M
N   NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_O
N   NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_X
N   NCE_UNKNOWN_OPERATION
N   2. The line ends without closing the expression: NCE_UNCLOSED_EXPRESSION
N
N   Side effects:
N   An integer representing the operation is put into what operation points
N   at.  The counter is reset to point to the first character after the
N   operation.
N
N   Called by: read_real_expression
N
N   This expects to be reading a binary operation (+, -, /, *, **, and,
N   mod, or, xor) or a right bracket (]). If one of these is found, the
N   value of operation is set to the symbolic value for that operation.
N   If not, an error is reported as described above.
N
N   */
N
N    static int read_operation(                    /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    int * operation)                              /* pointer to operation to be read                */
N    {
N        static char name[] SET_TO "read_operation";
X        static char name[] = "read_operation";
N        char c;
N
N        c SET_TO line[*counter];
X        c = line[*counter];
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        switch(c)
N        {
N            case '+':
N                *operation SET_TO PLUS;
X                *operation = 9;
N                break;
N            case '-':
N                *operation SET_TO MINUS;
X                *operation = 7;
N                break;
N            case '/':
N                *operation SET_TO DIVIDED_BY;
X                *operation = 1;
N                break;
N            case '*':
N                if(line[*counter] IS '*')
X                if(line[*counter] == '*')
N                {
N                    *operation SET_TO POWER;
X                    *operation = 3;
N                    *counter SET_TO (*counter + 1);
X                    *counter = (*counter + 1);
N                }
N                else
N                    *operation SET_TO TIMES;
X                    *operation = 4;
N                break;
N            case ']':
N                *operation SET_TO RIGHT_BRACKET;
X                *operation = 10;
N                break;
N            case 'a':
N                if((line[*counter] IS 'n') AND (line[(*counter)+1] IS 'd'))
X                if((line[*counter] == 'n') && (line[(*counter)+1] == 'd'))
N                {
N                    *operation SET_TO AND2;
X                    *operation = 5;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else
N                    ERM(NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_A);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 176; } else;
N                break;
N            case 'm':
N                if((line[*counter] IS 'o') AND (line[(*counter)+1] IS 'd'))
X                if((line[*counter] == 'o') && (line[(*counter)+1] == 'd'))
N                {
N                    *operation SET_TO MODULO;
X                    *operation = 2;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else
N                    ERM(NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_M);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 177; } else;
N                break;
N            case 'o':
N                if(line[*counter] IS 'r')
X                if(line[*counter] == 'r')
N                {
N                    *operation SET_TO NON_EXCLUSIVE_OR;
X                    *operation = 8;
N                    *counter SET_TO (*counter + 1);
X                    *counter = (*counter + 1);
N                }
N                else
N                    ERM(NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_O);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 178; } else;
N                break;
N            case 'x':
N                if((line[*counter] IS 'o') AND (line[(*counter)+1] IS 'r'))
X                if((line[*counter] == 'o') && (line[(*counter)+1] == 'r'))
N                {
N                    *operation SET_TO EXCLUSIVE_OR;
X                    *operation = 6;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else
N                    ERM(NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_X);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 179; } else;
N                break;
N            case 0:
N                ERM(NCE_UNCLOSED_EXPRESSION);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 172; } else;
N            default:
N                ERM(NCE_UNKNOWN_OPERATION);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 175; } else;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_operation_unary
N
N   Returned Value: int
N   If the operation is not a known unary operation, this returns one of
N   the following error codes:
N   NCE_UNKNOWN_WORD_STARTING_WITH_A
N   NCE_UNKNOWN_WORD_STARTING_WITH_C
N   NCE_UNKNOWN_WORD_STARTING_WITH_E
N   NCE_UNKNOWN_WORD_STARTING_WITH_F
N   NCE_UNKNOWN_WORD_STARTING_WITH_L
N   NCE_UNKNOWN_WORD_STARTING_WITH_R
N   NCE_UNKNOWN_WORD_STARTING_WITH_S
N   NCE_UNKNOWN_WORD_STARTING_WITH_T
N   NCE_UNKNOWN_WORD_WHERE_UNARY_OPERATION_COULD_BE
N   Otherwise, this returns RS274NGC_OK.
N
N   Side effects:
N   An integer code for the name of the operation read from the
N   line is put into what operation points at.
N   The counter is reset to point to the first character after the
N   characters which make up the operation name.
N
N   Called by:
N   read_unary
N
N   This attempts to read the name of a unary operation out of the line,
N   starting at the index given by the counter. Known operations are:
N   abs, acos, asin, atan, cos, exp, fix, fup, ln, round, sin, sqrt, tan.
N
N   */
N
N    static int read_operation_unary(              /* ARGUMENTS                               */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    int * operation)                              /* pointer to operation to be read                */
N    {
N        static char name[] SET_TO "read_operation_unary";
X        static char name[] = "read_operation_unary";
N        char c;
N
N        c SET_TO line[*counter];
X        c = line[*counter];
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        switch (c)
N        {
N            case 'a':
N                if((line[*counter] IS 'b') AND (line[(*counter)+1] IS 's'))
X                if((line[*counter] == 'b') && (line[(*counter)+1] == 's'))
N                {
N                    *operation SET_TO ABS;
X                    *operation = 1;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else if(strncmp((line + *counter), "cos", 3) IS 0)
X                else if(strncmp((line + *counter), "cos", 3) == 0)
N                {
N                    *operation SET_TO ACOS;
X                    *operation = 2;
N                    *counter SET_TO (*counter + 3);
X                    *counter = (*counter + 3);
N                }
N                else if(strncmp((line + *counter), "sin", 3) IS 0)
X                else if(strncmp((line + *counter), "sin", 3) == 0)
N                {
N                    *operation SET_TO ASIN;
X                    *operation = 3;
N                    *counter SET_TO (*counter + 3);
X                    *counter = (*counter + 3);
N                }
N                else if(strncmp((line + *counter), "tan", 3) IS 0)
X                else if(strncmp((line + *counter), "tan", 3) == 0)
N                {
N                    *operation SET_TO ATAN;
X                    *operation = 4;
N                    *counter SET_TO (*counter + 3);
X                    *counter = (*counter + 3);
N                }
N                else
N                    ERM(NCE_UNKNOWN_WORD_STARTING_WITH_A);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 180; } else;
N                break;
N            case 'c':
N                if((line[*counter] IS 'o') AND (line[(*counter)+1] IS 's'))
X                if((line[*counter] == 'o') && (line[(*counter)+1] == 's'))
N                {
N                    *operation SET_TO COS;
X                    *operation = 5;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else
N                    ERM(NCE_UNKNOWN_WORD_STARTING_WITH_C);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 181; } else;
N                break;
N            case 'e':
N                if((line[*counter] IS 'x') AND (line[(*counter)+1] IS 'p'))
X                if((line[*counter] == 'x') && (line[(*counter)+1] == 'p'))
N                {
N                    *operation SET_TO EXP;
X                    *operation = 6;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else
N                    ERM(NCE_UNKNOWN_WORD_STARTING_WITH_E);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 182; } else;
N                break;
N            case 'f':
N                if((line[*counter] IS 'i') AND (line[(*counter)+1] IS 'x'))
X                if((line[*counter] == 'i') && (line[(*counter)+1] == 'x'))
N                {
N                    *operation SET_TO FIX;
X                    *operation = 7;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else if((line[*counter] IS 'u') AND (line[(*counter)+1] IS 'p'))
X                else if((line[*counter] == 'u') && (line[(*counter)+1] == 'p'))
N                {
N                    *operation SET_TO FUP;
X                    *operation = 8;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else
N                    ERM(NCE_UNKNOWN_WORD_STARTING_WITH_F);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 183; } else;
N                break;
N            case 'l':
N                if(line[*counter] IS 'n')
X                if(line[*counter] == 'n')
N                {
N                    *operation SET_TO LN;
X                    *operation = 9;
N                    *counter SET_TO (*counter + 1);
X                    *counter = (*counter + 1);
N                }
N                else
N                    ERM(NCE_UNKNOWN_WORD_STARTING_WITH_L);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 184; } else;
N                break;
N            case 'r':
N                if(strncmp((line + *counter), "ound", 4) IS 0)
X                if(strncmp((line + *counter), "ound", 4) == 0)
N                {
N                    *operation SET_TO ROUND;
X                    *operation = 10;
N                    *counter SET_TO (*counter + 4);
X                    *counter = (*counter + 4);
N                }
N                else
N                    ERM(NCE_UNKNOWN_WORD_STARTING_WITH_R);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 185; } else;
N                break;
N            case 's':
N                if((line[*counter] IS 'i') AND (line[(*counter)+1] IS 'n'))
X                if((line[*counter] == 'i') && (line[(*counter)+1] == 'n'))
N                {
N                    *operation SET_TO SIN;
X                    *operation = 11;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else if(strncmp((line + *counter), "qrt", 3) IS 0)
X                else if(strncmp((line + *counter), "qrt", 3) == 0)
N                {
N                    *operation SET_TO SQRT;
X                    *operation = 12;
N                    *counter SET_TO (*counter + 3);
X                    *counter = (*counter + 3);
N                }
N                else
N                    ERM(NCE_UNKNOWN_WORD_STARTING_WITH_S);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 186; } else;
N                break;
N            case 't':
N                if((line[*counter] IS 'a') AND (line[(*counter)+1] IS 'n'))
X                if((line[*counter] == 'a') && (line[(*counter)+1] == 'n'))
N                {
N                    *operation SET_TO TAN;
X                    *operation = 13;
N                    *counter SET_TO (*counter + 2);
X                    *counter = (*counter + 2);
N                }
N                else
N                    ERM(NCE_UNKNOWN_WORD_STARTING_WITH_T);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 187; } else;
N                break;
N            default:
N                ERM(NCE_UNKNOWN_WORD_WHERE_UNARY_OPERATION_COULD_BE);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 188; } else;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_p
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not p:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A p value has already been inserted in the block:
N   NCE_MULTIPLE_P_WORDS_ON_ONE_LINE
N   3. The p value is negative: NCE_NEGATIVE_P_WORD_USED
N
N   Side effects:
N   counter is reset to point to the first character following the p value.
N   The p value setting is inserted in block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'p', indicating a p value
N   setting. The function reads characters which tell how to set the p
N   value, up to the start of the next item or the end of the line. This
N   information is inserted in the block.
N
N   P codes are used for:
N   1. Dwell time in canned cycles g82, G86, G88, G89 [NCMS pages 98 - 100].
N   2. A key with G10 [NCMS, pages 9, 10].
N
N   */
N
N    static int read_p(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_p";
X        static char name[] = "read_p";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'p'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'p')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->p_number > -1.0), NCE_MULTIPLE_P_WORDS_ON_ONE_LINE);
X        if ((block->p_number > -1.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 112; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value < 0.0), NCE_NEGATIVE_P_WORD_USED);
X        if ((value < 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 129; } else;
N        block->p_number SET_TO value;
X        block->p_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_parameter
N
N   Returned Value: int
N   If read_integer_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, this returns RS274NGC_OK.
N   1. The first character read is not # :
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. The parameter number is out of bounds:
N   NCE_PARAMETER_NUMBER_OUT_OF_RANGE
N
N   Side effects:
N   The value of the given parameter is put into what double_ptr points at.
N   The counter is reset to point to the first character after the
N   characters which make up the value.
N
N   Called by:  read_real_value
N
N   This attempts to read the value of a parameter out of the line,
N   starting at the index given by the counter.
N
N   According to the RS274/NGC manual [NCMS, p. 62], the characters following
N   # may be any "parameter expression". Thus, the following are legal
N   and mean the same thing (the value of the parameter whose number is
N   stored in parameter 2):
N   ##2
N   #[#2]
N
N   Parameter setting is done in parallel, not sequentially. For example
N   if #1 is 5 before the line "#1=10 #2=#1" is read, then after the line
N   is is executed, #1 is 10 and #2 is 5. If parameter setting were done
N   sequentially, the value of #2 would be 10 after the line was executed.
N
N   */
N
N    static int read_parameter(                    /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    double * double_ptr,                          /* pointer to double to be read                   */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_parameter";
X        static char name[] = "read_parameter";
N        int index;
N        int status;
N
N        CHK((line[*counter] ISNT '#'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != '#')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHP(read_integer_value(line, counter, &index, parameters));
X        if ((status = (read_integer_value(line, counter, &index, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK(((index < 1) OR (index >= RS274NGC_MAX_PARAMETERS)),
N            NCE_PARAMETER_NUMBER_OUT_OF_RANGE);
X        if (((index < 1) || (index >= 5400))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 142; } else;
N        *double_ptr SET_TO parameters[index];
X        *double_ptr = parameters[index];
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_parameter_setting
N
N   Returned Value: int
N   If read_real_value or read_integer_value returns an error code,
N   this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not # :
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. The parameter index is out of range: PARAMETER_NUMBER_OUT_OF_RANGE
N   3. An equal sign does not follow the parameter expression:
N   NCE_EQUAL_SIGN_MISSING_IN_PARAMETER_SETTING
N
N   Side effects:
N   counter is reset to the character following the end of the parameter
N   setting. The parameter whose index follows "#" is set to the
N   real value following "=".
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character '#', indicating a parameter
N   setting when found by read_one_item.  The function reads characters
N   which tell how to set the parameter.
N
N   Any number of parameters may be set on a line. If parameters set early
N   on the line are used in expressions farther down the line, the
N   parameters have their old values, not their new values. This is
N   usually called setting parameters in parallel.
N
N   Parameter setting is not clearly described in [NCMS, pp. 51 - 62]: it is
N   not clear if more than one parameter setting per line is allowed (any
N   number is OK in this implementation). The characters immediately following
N   the "#" must constitute a "parameter expression", but it is not clear
N   what that is. Here we allow any expression as long as it evaluates to
N   an integer.
N
N   Parameters are handled in the interpreter by having a parameter table
N   and a parameter buffer as part of the machine settings. The parameter
N   table is passed to the reading functions which need it. The parameter
N   buffer is used directly by functions that need it. Reading functions
N   may set parameter values in the parameter buffer. Reading functions
N   may obtain parameter values; these come from parameter table.
N
N   The parameter buffer has three parts: (i) a counter for how many
N   parameters have been set while reading the current line (ii) an array
N   of the indexes of parameters that have been set while reading the
N   current line, and (iii) an array of the values for the parameters that
N   have been set while reading the current line; the nth value
N   corresponds to the nth index. Any given index will appear once in the
N   index number array for each time the parameter with that index is set
N   on a line. There is no point in setting the same parameter more than
N   one on a line because only the last setting of that parameter will
N   take effect.
N
N   The syntax recognized by this this function is # followed by an
N   integer expression (explicit integer or expression evaluating to an
N   integer) followed by = followed by a real value (number or
N   expression).
N
N   Note that # also starts a bunch of characters which represent a parameter
N   to be evaluated. That situation is handled by read_parameter.
N
N   */
N
N    static int read_parameter_setting(            /* ARGUMENTS                        */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_parameter_setting";
X        static char name[] = "read_parameter_setting";
N        int index;
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT '#'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != '#')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHP(read_integer_value(line, counter, &index, parameters));
X        if ((status = (read_integer_value(line, counter, &index, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK(((index < 1) OR (index >= RS274NGC_MAX_PARAMETERS)),
N            NCE_PARAMETER_NUMBER_OUT_OF_RANGE);
X        if (((index < 1) || (index >= 5400))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 142; } else;
N        CHK((line[*counter] ISNT '='), NCE_EQUAL_SIGN_MISSING_IN_PARAMETER_SETTING);
X        if ((line[*counter] != '=')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 77; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        _setup.parameter_numbers[_setup.parameter_occurrence] SET_TO index;
X        _setup.parameter_numbers[_setup.parameter_occurrence] = index;
N        _setup.parameter_values[_setup.parameter_occurrence] SET_TO value;
X        _setup.parameter_values[_setup.parameter_occurrence] = value;
N        _setup.parameter_occurrence++;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_q
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not q:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A q value has already been inserted in the block:
N   NCE_MULTIPLE_Q_WORDS_ON_ONE_LINE
N   3. The q value is negative or zero: NCE_NEGATIVE_OR_ZERO_Q_VALUE_USED
N
N   Side effects:
N   counter is reset to point to the first character following the q value.
N   The q value setting is inserted in block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'q', indicating a q value
N   setting. The function reads characters which tell how to set the q
N   value, up to the start of the next item or the end of the line. This
N   information is inserted in the block.
N
N   Q is used only in the G87 canned cycle [NCMS, page 98], where it must
N   be positive.
N
N   */
N
N    static int read_q(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_q";
X        static char name[] = "read_q";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'q'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'q')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->q_number > -1.0), NCE_MULTIPLE_Q_WORDS_ON_ONE_LINE);
X        if ((block->q_number > -1.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 113; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value <= 0.0), NCE_NEGATIVE_OR_ZERO_Q_VALUE_USED);
X        if ((value <= 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 128; } else;
N        block->q_number SET_TO value;
X        block->q_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_r
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not r:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. An r_number has already been inserted in the block:
N   NCE_MULTIPLE_R_WORDS_ON_ONE_LINE
N
N   Side effects:
N   counter is reset.
N   The r_flag in the block is turned on.
N   The r_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'r'. The function reads characters
N   which tell how to set the coordinate, up to the start of the next item
N   or the end of the line. This information is inserted in the block. The
N   counter is then set to point to the character following.
N
N   An r number indicates the clearance plane in canned cycles.
N   An r number may also be the radius of an arc.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   */
N
N    static int read_r(                            /* ARGUMENTS                                     */
N    char * line,                                  /* string: line of RS274 code being processed    */
N    int * counter,                                /* pointer to a counter for position on the line */
N    block_pointer block,                          /* pointer to a block being filled from the line */
N    double * parameters)                          /* array of system parameters                    */
N    {
N        static char name[] SET_TO "read_r";
X        static char name[] = "read_r";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'r'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'r')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->r_flag ISNT OFF), NCE_MULTIPLE_R_WORDS_ON_ONE_LINE);
X        if ((block->r_flag != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 114; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        block->r_flag SET_TO ON;
X        block->r_flag = 1;
N        block->r_number SET_TO value;
X        block->r_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_real_expression
N
N   Returned Value: int
N   If any of the following functions returns an error code,
N   this returns that code.
N   read_real_value
N   read_operation
N   execute_binary
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character is not [ :
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N
N   Side effects:
N   The number read from the line is put into what value_ptr points at.
N   The counter is reset to point to the first character after the real
N   expression.
N
N   Called by:
N   read_atan
N   read_real_value
N   read_unary
N
N   Example 1: [2 - 3 * 4 / 5] means [2 - [[3 * 4] / 5]] and equals -0.4.
N
N   Segmenting Expressions -
N
N   The RS274/NGC manual, section 3.5.1.1 [NCMS, page 50], provides for
N   using square brackets to segment expressions.
N
N   Binary Operations -
N
N   The RS274/NGC manual, section 3.5.1.1, discusses expression evaluation.
N   The manual provides for eight binary operations: the four basic
N   mathematical operations (addition, subtraction, multiplication,
N   division), three logical operations (non-exclusive OR, exclusive OR,
N   and AND2) and the modulus operation. The manual does not explicitly call
N   these "binary" operations, but implicitly recognizes that they are
N   binary. We have added the "power" operation of raising the number
N   on the left of the operation to the power on the right; this is
N   needed for many basic machining calculations.
N
N   There are two groups of binary operations given in the manual. If
N   operations are strung together as shown in Example 1, operations in
N   the first group are to be performed before operations in the second
N   group. If an expression contains more than one operation from the same
N   group (such as * and / in Example 1), the operation on the left is
N   performed first. The first group is: multiplication (*), division (/),
N   and modulus (MOD). The second group is: addition(+), subtraction (-),
N   logical non-exclusive OR (OR), logical exclusive OR (XOR), and logical
N   AND (AND2). We have added a third group with higher precedence than
N   the first group. The third group contains only the power (**)
N   operation.
N
N   The logical operations and modulus are apparently to be performed on
N   any real numbers, not just on integers or on some other data type.
N
N   Unary Operations -
N
N   The RS274/NGC manual, section 3.5.1.2, provides for fifteen unary
N   mathematical operations. Two of these, BIN and BCD, are apparently for
N   converting between decimal and hexadecimal number representation,
N   although the text is not clear. These have not been implemented, since
N   we are not using any hexadecimal numbers. The other thirteen unary
N   operations have been implemented: absolute_value, arc_cosine, arc_sine,
N   arc_tangent, cosine, e_raised_to, fix_down, fix_up, natural_log_of,
N   round, sine, square_root, tangent.
N
N   The manual section 3.5.1.2 [NCMS, page 51] requires the argument to
N   all unary operations (except atan) to be in square brackets.  Thus,
N   for example "sin[90]" is allowed in the interpreter, but "sin 90" is
N   not. The atan operation must be in the format "atan[..]/[..]".
N
N   Production Rule Definitions in Terms of Tokens -
N
N   The following is a production rule definition of what this RS274NGC
N   interpreter recognizes as valid combinations of symbols which form a
N   recognized real_value (the top of this production hierarchy).
N
N   The notion of "integer_value" is used in the interpreter. Below it is
N   defined as a synonym for real_value, but in fact a constraint is added
N   which cannot be readily written in a production language.  An
N   integer_value is a real_value which is very close to an integer.
N   Integer_values are needed for array and table indices and (when
N   divided by 10) for the values of M codes and G codes. All numbers
N   (including integers) are read as real numbers and stored as doubles.
N   If an integer_value is required in some situation, a test for being
N   close to an integer is applied to the number after it is read.
N
N   arc_tangent_combo = arc_tangent expression divided_by expression .
N
N   binary_operation1 = divided_by | modulo | power | times .
N
N   binary_operation2 = and | exclusive_or | minus |  non_exclusive_or | plus .
N
N   combo1 = real_value { binary_operation1 real_value } .
N
N   digit = zero | one | two | three | four | five | six | seven |eight | nine .
N
N   expression =
N   left_bracket
N   (unary_combo | (combo1 { binary_operation2 combo1 }))
N   right_bracket .
N
N   integer_value = real_value .
N
N   ordinary_unary_combo =  ordinary_unary_operation expression .
N
N   ordinary_unary_operation =
N   absolute_value | arc_cosine | arc_sine | cosine | e_raised_to |
N   fix_down | fix_up | natural_log_of | round | sine | square_root | tangent .
N
N   parameter_index = integer_value .
N
N   parameter_value = parameter_sign  parameter_index .
N
N   real_number =
N   [ plus | minus ]
N   (( digit { digit } decimal_point {digit}) | ( decimal_point digit {digit})).
N
N   real_value =
N   real_number | expression | parameter_value | unary_combo.
N
N   unary_combo = ordinary_unary_combo | arc_tangent_combo .
N
N   Production Tokens in Terms of Characters -
N
N   absolute_value   = 'abs'
N   and              = 'and'
N   arc_cosine       = 'acos'
N   arc_sine         = 'asin'
N   arc_tangent      = 'atan'
N   cosine           = 'cos'
N   decimal_point    = '.'
N   divided_by       = '/'
N   eight            = '8'
N   exclusive_or     = 'xor'
N   e_raised_to      = 'exp'
N   five             = '5'
N   fix_down         = 'fix'
N   fix_up           = 'fup'
N   four             = '4'
N   left_bracket     = '['
N   minus            = '-'
N   modulo           = 'mod'
N   natural_log_of   = 'ln'
N   nine             = '9'
N   non_exclusive_or = 'or'
N   one              = '1'
N   parameter_sign   = '#'
N   plus             = '+'
N   power            = '**'
N   right_bracket    = ']'
N   round            = 'round'
N   seven            = '7'
N   sine             = 'sin'
N   six              = '6'
N   square_root      = 'sqrt'
N   tangent          = 'tan'
N   three            = '3'
N   times            = '*'
N   two              = '2'
N   zero             = '0'
N
N   When this function is called, the counter should be set at a left
N   bracket. The function reads up to and including the right bracket
N   which closes the expression.
N
N   The basic form of an expression is: [v1 bop v2 bop ... vn], where the
N   vi are real_values and the bops are binary operations. The vi may be
N   numbers, parameters, expressions, or unary functions. Because some
N   bops are to be evaluated before others, for understanding the order of
N   evaluation, it is useful to rewrite the general form collecting any
N   subsequences of bops of the same precedence. For example, suppose the
N   expression is: [9+8*7/6+5-4*3**2+1]. It may be rewritten as:
N   [9+[8*7/6]+5-[4*[3**2]]+1] to show how it should be evaluated.
N
N   The manual provides that operations of the same precedence should be
N   processed left to right.
N
N   The first version of this function is commented out. It is suitable
N   for when there are only two precendence levels. It is an improvement
N   over the version used in interpreters before 2000, but not as general
N   as the second version given here.
N
N   The first version of this function reads the first value and the first
N   operation in the expression. Then it calls either read_rest_bop1 or
N   read_rest_bop2 according to whether the first operation is a bop1 or a
N   bop2.  Read_rest_bop1 resets the next_operation to either a right
N   bracket or a bop2. If it is reset to a bop2, read_rest_bop2 is called
N   when read_rest_bop1 returns.
N
N   */
N
N#ifdef UNDEFINED
S    static int read_real_expression(              /* ARGUMENTS                               */
S    char * line,                                  /* string: line of RS274/NGC code being processed */
S    int * counter,                                /* pointer to a counter for position on the line  */
S    double * value,                               /* pointer to double to be read                   */
S    double * parameters)                          /* array of system parameters                     */
S    {
S        static char name[] SET_TO "read_real_expression";
S        int next_operation;
S        int status;
S
S        CHK((line[*counter] ISNT '['), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
S        *counter SET_TO (*counter + 1);
S        CHP(read_real_value(line, counter, value, parameters));
S        CHP(read_operation(line, counter, &next_operation));
S        if (next_operation IS RIGHT_BRACKET);     /* nothing to do */
S        else if (next_operation < AND2)           /* next operation is a bop1, times-like */
S        {
S            CHP(read_rest_bop1(line, counter, value, &next_operation, parameters));
S            if (next_operation IS RIGHT_BRACKET); /* next_operation has been reset */
S            else                                  /* next_operation is now a bop2, plus-like */
S                CHP(read_rest_bop2(line, counter, value, next_operation, parameters));
S        }
S        else                                      /* next operation is a bop2, plus-like */
S            CHP(read_rest_bop2(line, counter, value, next_operation, parameters));
S        return RS274NGC_OK;
S    }
N#endif
N
N   /****************************************************************************/
N
N   /*
N
N   The following version is stack-based and fully general. It is the
N   classical stack-based version with left-to-right evaluation of
N   operations of the same precedence. Separate stacks are used for
N   operations and values, and the stacks are made with arrays
N   rather than lists, but those are implementation details. Pushing
N   and popping are implemented by increasing or decreasing the
N   stack index.
N
N   Additional levels of precedence may be defined easily by changing the
N   precedence function. The size of MAX_STACK should always be at least
N   as large as the number of precedence levels used. We are currently
N   using four precedence levels (for right-bracket, plus-like operations,
N   times-like operations, and power).
N
N   */
N
N#define MAX_STACK 5
N
N    static int read_real_expression(              /* ARGUMENTS                               */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    double * value,                               /* pointer to double to be computed               */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_real_expression";
X        static char name[] = "read_real_expression";
N        double values[MAX_STACK];
X        double values[5];
N        int operators[MAX_STACK];
X        int operators[5];
N        int stack_index;
N        int status;
N
N        CHK((line[*counter] ISNT '['), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != '[')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHP(read_real_value(line, counter, values, parameters));
X        if ((status = (read_real_value(line, counter, values, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHP(read_operation(line, counter, operators));
X        if ((status = (read_operation(line, counter, operators))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        stack_index SET_TO 1;
X        stack_index = 1;
N        for(; operators[0] ISNT RIGHT_BRACKET ;)
X        for(; operators[0] != 10 ;)
N        {
N            CHP(read_real_value(line, counter, values+stack_index, parameters));
X            if ((status = (read_real_value(line, counter, values+stack_index, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            CHP(read_operation(line, counter, operators+stack_index));
X            if ((status = (read_operation(line, counter, operators+stack_index))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            if (precedence(operators[stack_index]) >
N                precedence(operators[stack_index - 1]))
N                stack_index++;
N            else                                  /* precedence of latest operator is <= previous precedence */
N            {
N                for (;precedence(operators[stack_index]) <=
N                    precedence(operators[stack_index - 1]); )
N                {
N                    CHP(execute_binary((values + stack_index - 1),
N                        operators[stack_index -1],
N                        (values + stack_index)));
X                    if ((status = (execute_binary((values + stack_index - 1), operators[stack_index -1], (values + stack_index)))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N                    operators[stack_index - 1] SET_TO operators[stack_index];
X                    operators[stack_index - 1] = operators[stack_index];
N                    if ((stack_index > 1) AND
X                    if ((stack_index > 1) &&
N                        (precedence(operators[stack_index - 1]) <=
N                        precedence(operators[stack_index - 2])))
N                        stack_index--;
N                    else
N                        break;
N                }
N            }
N        }
N        *value SET_TO values[0];
X        *value = values[0];
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_real_number
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character is not "+", "-", "." or a digit:
N   NCE_BAD_NUMBER_FORMAT
N   2. No digits are found after the first character and before the
N   end of the line or the next character that cannot be part of a real:
N   NCE_NO_DIGITS_FOUND_WHERE_REAL_NUMBER_SHOULD_BE
N   3. sscanf fails: NCE_SSCANF_FAILED
N
N   Side effects:
N   The number read from the line is put into what double_ptr points at.
N   The counter is reset to point to the first character after the real.
N
N   Called by:  read_real_value
N
N   This attempts to read a number out of the line, starting at the index
N   given by the counter. It stops when the first character that cannot
N   be part of the number is found.
N
N   The first character may be a digit, "+", "-", or "."
N   Every following character must be a digit or "." up to anything
N   that is not a digit or "." (a second "." terminates reading).
N
N   This function is not called if the first character is NULL, so it is
N   not necessary to check that.
N
N   The temporary insertion of a NULL character on the line is to avoid
N   making a format string like "%3lf" which the LynxOS compiler cannot
N   handle.
N
N   */
N
N    static int read_real_number(                  /* ARGUMENTS                               */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    double * double_ptr)                          /* pointer to double to be read                   */
N    {
N        static char name[] SET_TO "read_real_number";
X        static char name[] = "read_real_number";
N        char c;                                   /* for character being processed    */
N        int flag_digit;                           /* set to ON if digit found         */
N        int flag_point;                           /* set to ON if decimal point found */
N        int n;                                    /* for indexing line                */
N
N        n SET_TO *counter;
X        n = *counter;
N        flag_point SET_TO OFF;
X        flag_point = 0;
N        flag_digit SET_TO OFF;
X        flag_digit = 0;
N
N   /* check first character */
N        c SET_TO line[n];
X        c = line[n];
N        if (c IS '+')
X        if (c == '+')
N        {
N            *counter SET_TO (*counter + 1);       /* skip plus sign */
X            *counter = (*counter + 1);        
N            n++;
N        }
N        else if (c IS '-')
X        else if (c == '-')
N        {
N            n++;
N        }
N        else if ((c ISNT '.') AND ((c < 48) OR (c > 57)))
X        else if ((c != '.') && ((c < 48) || (c > 57)))
N            ERM(NCE_BAD_NUMBER_FORMAT);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 14; } else;
N
N   /* check out rest of characters (must be digit or decimal point) */
N        for (; (c SET_TO line[n]) ISNT (char) NULL; n++)
X        for (; (c = line[n]) != (char) 0; n++)
N        {
N            if (( 47 < c) AND ( c < 58))
X            if (( 47 < c) && ( c < 58))
N            {
N                flag_digit SET_TO ON;
X                flag_digit = 1;
N            }
N            else if (c IS '.')
X            else if (c == '.')
N            {
N                if (flag_point IS OFF)
X                if (flag_point == 0)
N                {
N                    flag_point SET_TO ON;
X                    flag_point = 1;
N                }
N                else
N                    break;                        /* two decimal points, error appears on reading next item */
N            }
N            else
N                break;
N        }
N
N        CHK((flag_digit IS OFF), NCE_NO_DIGITS_FOUND_WHERE_REAL_NUMBER_SHOULD_BE);
X        if ((flag_digit == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 134; } else;
N        line[n] SET_TO (char) NULL;               /* temporary string termination for sscanf */
X        line[n] = (char) 0;                
N        if (sscanf(line + *counter, "%lf", double_ptr) IS 0)
X        if (sscanf(line + *counter, "%lf", double_ptr) == 0)
N        {
N            line[n] SET_TO c;
X            line[n] = c;
N            ERM(NCE_SSCANF_FAILED);
X            if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 161; } else;
N        }
N        else
N        {
N            line[n] SET_TO c;
X            line[n] = c;
N            *counter SET_TO n;
X            *counter = n;
N        }
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_real_value
N
N   Returned Value: int
N   If one of the following functions returns an error code,
N   this returns that code.
N   read_real_expression
N   read_parameter
N   read_unary
N   read_real_number
N   If no characters are found before the end of the line this
N   returns NCE_NO_CHARACTERS_FOUND_IN_READING_REAL_VALUE.
N   Otherwise, this returns RS274NGC_OK.
N
N   Side effects:
N   The value read from the line is put into what double_ptr points at.
N   The counter is reset to point to the first character after the
N   characters which make up the value.
N
N   Called by:
N   read_a
N   read_b
N   read_c
N   read_f
N   read_g
N   read_i
N   read_integer_value
N   read_j
N   read_k
N   read_p
N   read_parameter_setting
N   read_q
N   read_r
N   read_real_expression
N   read_s
N   read_x
N   read_y
N   read_z
N
N   This attempts to read a real value out of the line, starting at the
N   index given by the counter. The value may be a number, a parameter
N   value, a unary function, or an expression. It calls one of four
N   other readers, depending upon the first character.
N
N   */
N
N    static int read_real_value(                   /* ARGUMENTS                               */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    double * double_ptr,                          /* pointer to double to be read                   */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_real_value";
X        static char name[] = "read_real_value";
N        char c;
N        int status;
N
N        c SET_TO line[*counter];
X        c = line[*counter];
N        CHK((c IS 0), NCE_NO_CHARACTERS_FOUND_IN_READING_REAL_VALUE);
X        if ((c == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 133; } else;
N        if (c IS '[')
X        if (c == '[')
N            CHP(read_real_expression (line, counter, double_ptr, parameters));
X            if ((status = (read_real_expression (line, counter, double_ptr, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        else if (c IS '#')
X        else if (c == '#')
N            CHP(read_parameter(line, counter, double_ptr, parameters));
X            if ((status = (read_parameter(line, counter, double_ptr, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        else if ((c >= 'a') AND (c <= 'z'))
X        else if ((c >= 'a') && (c <= 'z'))
N            CHP(read_unary(line, counter, double_ptr, parameters));
X            if ((status = (read_unary(line, counter, double_ptr, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        else
N            CHP(read_real_number(line, counter, double_ptr));
X            if ((status = (read_real_number(line, counter, double_ptr))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_rest_bop1
N
N   Returned Value: int
N   If any of the following functions returns an error code,
N   this returns that code.
N   execute_binary1
N   read_real_value
N   read_operation
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   The value argument is set to the value of the expression.
N   The counter is reset to point to the first character after the real
N   expression.
N
N   Called by:
N   read_real_expression
N   read_rest_bop2
N
N   The value argument has a value in it when this is called. This repeatedly
N   gets the next_value and the next_operation, performs the last_operation
N   on the value and the next_value and resets the last_operation to the
N   next_operation. Observe that both the value and the last_operation
N   are passed back to the caller.
N
N   This is commented out since it is not used in the uncommented version
N   of read_real_expression. It has been tested.
N
N   */
N
N#ifdef UNDEFINED
S    static int read_rest_bop1(                    /* ARGUMENTS                                      */
S    char * line,                                  /* string: line of RS274/NGC code being processed */
S    int * counter,                                /* pointer to a counter for position on the line  */
S    double * value,                               /* pointer to double to be calculated             */
S    int * last_operation,                         /* last operation read, reset to next operation   */
S    double * parameters)                          /* array of system parameters                     */
S    {
S        static char name[] SET_TO "read_rest_bop1";
S        double next_value;
S        int next_operation;
S        int status;
S
S        for(; ; )
S        {
S            CHP(read_real_value(line, counter, &next_value, parameters));
S            CHP(read_operation(line, counter, &next_operation));
S            CHP(execute_binary1(value, *last_operation, &next_value));
S            *last_operation SET_TO next_operation;
S            if (next_operation >= AND2)           /* next op is a bop2 or right bracket */
S                break;
S        }
S        return RS274NGC_OK;
S    }
N#endif
N
N   /****************************************************************************/
N
N   /* read_rest_bop2
N
N   Returned Value: int
N   If any of the following functions returns an error code,
N   this returns that code.
N   execute_binary2
N   read_real_value
N   read_operation
N   read_rest_bop1
N   Otherwise, it returns RS274NGC_OK.
N
N   Side effects:
N   The value argument is set to the value of the expression.
N   The counter is reset to point to the first character after the real
N   expression.
N
N   Called by:  read_real_expression
N
N   The value argument has a value in it when this is called. This repeatedly
N   gets the next_value and the next_operation, performs the last_operation
N   on the value and the next_value and resets the last_operation to the
N   next_operation. If the next_operation is ever a bop1 read_rest_bop1 is
N   called to set the next_value.
N
N   This is commented out since it is not used in the uncommented version
N   of read_real_expression. It has been tested.
N
N   */
N
N#ifdef UNDEFINED
S    static int read_rest_bop2(                    /* ARGUMENTS                                      */
S    char * line,                                  /* string: line of RS274/NGC code being processed */
S    int * counter,                                /* pointer to a counter for position on the line  */
S    double * value,                               /* pointer to double to be calculated             */
S    int last_operation,                           /* last operation read                            */
S    double * parameters)                          /* array of system parameters                     */
S    {
S        static char name[] SET_TO "read_rest_bop2";
S        double next_value;
S        int next_operation;
S        int status;
S
S        for(; ; last_operation SET_TO next_operation)
S        {
S            CHP(read_real_value(line, counter, &next_value, parameters));
S            CHP(read_operation(line, counter, &next_operation));
S            if (next_operation < AND2)            /* next operation is a bop1 */
S            {
S                CHP(read_rest_bop1(line, counter, &next_value,
S                    &next_operation, parameters));
S            }
S            CHP(execute_binary2(value, last_operation, &next_value));
S            if (next_operation IS RIGHT_BRACKET)
S                break;
S        }
S        return RS274NGC_OK;
S    }
N#endif
N
N   /****************************************************************************/
N
N   /* read_s
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not s:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A spindle speed has already been inserted in the block:
N   NCE_MULTIPLE_S_WORDS_ON_ONE_LINE
N   3. The spindle speed is negative: NCE_NEGATIVE_SPINDLE_SPEED_USED
N
N   Side effects:
N   counter is reset to the character following the spindle speed.
N   A spindle speed setting is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 's', indicating a spindle speed
N   setting. The function reads characters which tell how to set the spindle
N   speed.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   */
N
N    static int read_s(                            /* ARGUMENTS                                     */
N    char * line,                                  /* string: line of RS274NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line */
N    block_pointer block,                          /* pointer to a block being filled from the line */
N    double * parameters)                          /* array of system parameters                    */
N    {
N        static char name[] SET_TO "read_s";
X        static char name[] = "read_s";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 's'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 's')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->s_number > -1.0), NCE_MULTIPLE_S_WORDS_ON_ONE_LINE);
X        if ((block->s_number > -1.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 115; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value < 0.0), NCE_NEGATIVE_SPINDLE_SPEED_USED);
X        if ((value < 0.0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 130; } else;
N        block->s_number SET_TO value;
X        block->s_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_t
N
N   Returned Value: int
N   If read_integer_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not t:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A t_number has already been inserted in the block:
N   NCE_MULTIPLE_T_WORDS_ON_ONE_LINE
N   3. The t_number is negative: NCE_NEGATIVE_TOOL_ID_USED
N
N   Side effects:
N   counter is reset to the character following the t_number.
N   A t_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 't', indicating a tool.
N   The function reads characters which give the (integer) value of the
N   tool code.
N
N   The value must be an integer or something that evaluates to a
N   real number, so read_integer_value is used to read it. Parameters
N   may be involved.
N
N   */
N
N    static int read_t(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_t";
X        static char name[] = "read_t";
N        int value;
N        int status;
N
N        CHK((line[*counter] ISNT 't'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 't')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->t_number > -1), NCE_MULTIPLE_T_WORDS_ON_ONE_LINE);
X        if ((block->t_number > -1)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 116; } else;
N        CHP(read_integer_value(line, counter, &value, parameters));
X        if ((status = (read_integer_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((value < 0), NCE_NEGATIVE_TOOL_ID_USED);
X        if ((value < 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 131; } else;
N        block->t_number SET_TO value;
X        block->t_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_text
N
N   Returned Value: int
N   If close_and_downcase returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, this returns:
N   a. RS274NGC_ENDFILE if the percent_flag is ON and the only
N   non-white character on the line is %,
N   b. RS274NGC_EXECUTE_FINISH if the first character of the
N   close_and_downcased line is a slash, and
N   c. RS274NGC_OK otherwise.
N   1. The end of the file is found and the percent_flag is ON:
N   NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN
N   2. The end of the file is found and the percent_flag is OFF:
N   NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN_OR_PROGRAM_END
N   3. The command argument is not null and is too long or the command
N   argument is null and the line read from the file is too long:
N   NCE_COMMAND_TOO_LONG
N
N   Side effects: See below
N
N   Called by:  rs274ngc_read
N
N   This reads a line of RS274 code from a command string or a file into
N   the line array. If the command string is not null, the file is ignored.
N
N   If the end of file is reached, an error is returned as described
N   above. The end of the file should not be reached because (a) if the
N   file started with a percent line, it must end with a percent line, and
N   no more reading of the file should occur after that, and (b) if the
N   file did not start with a percent line, it must have a program ending
N   command (M2 or M30) in it, and no more reading of the file should
N   occur after that.
N
N   All blank space at the end of a line read from a file is removed and
N   replaced here with NULL characters.
N
N   This then calls close_and_downcase to downcase and remove tabs and
N   spaces from everything on the line that is not part of a comment. Any
N   comment is left as is.
N
N   The length is set to zero if any of the following occur:
N   1. The line now starts with a slash, but the second character is NULL.
N   2. The first character is NULL.
N   Otherwise, length is set to the length of the line.
N
N   An input line is blank if the first character is NULL or it consists
N   entirely of tabs and spaces and, possibly, a newline before the first
N   NULL.
N
N   Block delete is discussed in [NCMS, page 3] but the discussion makes
N   no sense. Block delete is handled by having this function return
N   RS274NGC_EXECUTE_FINISH if the first character of the
N   close_and_downcased line is a slash. When the caller sees this,
N   the caller is expected not to call rs274ngc_execute if the switch
N   is on, but rather call rs274ngc_read again to overwrite and ignore
N   what is read here.
N
N   The value of the length argument is set to the number of characters on
N   the reduced line.
N
N   */
N
N    static int read_text(                         /* ARGUMENTS                                   */
N    const char * command,                         /* a string which may have input text, or null */
N    FILE * inport,                                /* a file pointer for an input file, or null   */
N    char * raw_line,                              /* array to write raw input line into          */
N    char * line,                                  /* array for input line to be processed in     */
N    int * length)                                 /* a pointer to an integer to be set           */
N    {
N        static char name[] SET_TO "read_text";
X        static char name[] = "read_text";
N        int status;                               /* used in CHP */
N        int index;
N
N        if (command IS NULL)
X        if (command == 0)
N        {
N            if(fgets(raw_line, RS274NGC_TEXT_SIZE, inport) IS NULL)
X            if(fgets(raw_line, 256, inport) == 0)
N            {
N                if (_setup.percent_flag IS ON)
X                if (_setup.percent_flag == 1)
N                    ERM(NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 80; } else;
N                else
N                    ERM(NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN_OR_PROGRAM_END);
X                    if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 81; } else;
N            }
N            if (strlen(raw_line) IS (RS274NGC_TEXT_SIZE - 1))
X            if (strlen(raw_line) == (256 - 1))
N            {                                     // line is too long. need to finish reading the line to recover
N                for(;fgetc(inport) ISNT '\n';)    // could also look for EOF
X                for(;fgetc(inport) != '\n';)    
N                {
N                }
N                ERM(NCE_COMMAND_TOO_LONG);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 66; } else;
N            }
N   // index set on last char
N            for(index SET_TO (strlen(raw_line) -1);
X            for(index = (strlen(raw_line) -1);
N                (index >= 0) AND (isspace(raw_line[index]));
X                (index >= 0) && (((* __rt_ctype_table())[raw_line[index]] & 1));
N                index--)
N            {                                     // remove space at end of raw_line, especially CR & LF
N                raw_line[index] SET_TO 0;
X                raw_line[index] = 0;
N            }
N            strcpy(line, raw_line);
N            CHP(close_and_downcase(line));
X            if ((status = (close_and_downcase(line))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            if ((line[0] IS '%') AND (line[1] IS 0) AND (_setup.percent_flag IS ON))
X            if ((line[0] == '%') && (line[1] == 0) && (_setup.percent_flag == 1))
N                return RS274NGC_ENDFILE;
X                return 3;
N        }
N        else
N        {
N            CHK((strlen(command) >= RS274NGC_TEXT_SIZE), NCE_COMMAND_TOO_LONG);
X            if ((strlen(command) >= 256)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 66; } else;
N            strcpy(raw_line, command);
N            strcpy(line, command);
N            CHP(close_and_downcase(line));
X            if ((status = (close_and_downcase(line))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        }
N        _setup.sequence_number++;
N        _setup.parameter_occurrence SET_TO 0;     /* initialize parameter buffer */
X        _setup.parameter_occurrence = 0;      
N        if ((line[0] IS 0) OR ((line[0] IS '/') AND (line[1] IS 0)))
X        if ((line[0] == 0) || ((line[0] == '/') && (line[1] == 0)))
N            *length SET_TO 0;
X            *length = 0;
N        else
N            *length SET_TO strlen(line);
X            *length = strlen(line);
N
N        return ((line[0] IS '/')? RS274NGC_EXECUTE_FINISH : RS274NGC_OK);
X        return ((line[0] == '/')? 2 : 0);
N    }
N
N   /****************************************************************************/
N
N   /* read_unary
N
N   Returned Value: int
N   If any of the following functions returns an error code,
N   this returns that code.
N   execute_unary
N   read_atan
N   read_operation_unary
N   read_real_expression
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. the name of the unary operation is not followed by a left bracket:
N   NCE_LEFT_BRACKET_MISSING_AFTER_UNARY_OPERATION_NAME
N
N   Side effects:
N   The value read from the line is put into what double_ptr points at.
N   The counter is reset to point to the first character after the
N   characters which make up the value.
N
N   Called by:  read_real_value
N
N   This attempts to read the value of a unary operation out of the line,
N   starting at the index given by the counter. The atan operation is
N   handled specially because it is followed by two arguments.
N
N   */
N
N    static int read_unary(                        /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274/NGC code being processed */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    double * double_ptr,                          /* pointer to double to be read                   */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_unary";
X        static char name[] = "read_unary";
N        int operation;
N        int status;
N
N        CHP(read_operation_unary (line, counter, &operation));
X        if ((status = (read_operation_unary (line, counter, &operation))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        CHK((line[*counter] ISNT '['),
N            NCE_LEFT_BRACKET_MISSING_AFTER_UNARY_OPERATION_NAME);
X        if ((line[*counter] != '[')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 97; } else;
N        CHP(read_real_expression (line, counter, double_ptr, parameters));
X        if ((status = (read_real_expression (line, counter, double_ptr, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N
N        if (operation IS ATAN)
X        if (operation == 4)
N            CHP(read_atan(line, counter, double_ptr, parameters));
X            if ((status = (read_atan(line, counter, double_ptr, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        else
N            CHP(execute_unary(double_ptr, operation));
X            if ((status = (execute_unary(double_ptr, operation))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_x
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not x:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A x_coordinate has already been inserted in the block:
N   NCE_MULTIPLE_X_WORDS_ON_ONE_LINE
N
N   Side effects:
N   counter is reset.
N   The x_flag in the block is turned on.
N   An x_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'x', indicating a x_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   This information is inserted in the block. The counter is then set to
N   point to the character following.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   */
N
N    static int read_x(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274 code being processed     */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_x";
X        static char name[] = "read_x";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'x'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'x')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->x_flag ISNT OFF), NCE_MULTIPLE_X_WORDS_ON_ONE_LINE);
X        if ((block->x_flag != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 117; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        block->x_flag SET_TO ON;
X        block->x_flag = 1;
N        block->x_number SET_TO value;
X        block->x_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_y
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not y:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A y_coordinate has already been inserted in the block:
N   NCE_MULTIPLE_Y_WORDS_ON_ONE_LINE
N
N   Side effects:
N   counter is reset.
N   The y_flag in the block is turned on.
N   A y_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'y', indicating a y_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   This information is inserted in the block. The counter is then set to
N   point to the character following.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   */
N
N    static int read_y(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274 code being processed     */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_y";
X        static char name[] = "read_y";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'y'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'y')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->y_flag ISNT OFF), NCE_MULTIPLE_Y_WORDS_ON_ONE_LINE);
X        if ((block->y_flag != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 118; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        block->y_flag SET_TO ON;
X        block->y_flag = 1;
N        block->y_number SET_TO value;
X        block->y_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* read_z
N
N   Returned Value: int
N   If read_real_value returns an error code, this returns that code.
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, it returns RS274NGC_OK.
N   1. The first character read is not z:
N   NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED
N   2. A z_coordinate has already been inserted in the block:
N   NCE_MULTIPLE_Z_WORDS_ON_ONE_LINE
N
N   Side effects:
N   counter is reset.
N   The z_flag in the block is turned on.
N   A z_number is inserted in the block.
N
N   Called by: read_one_item
N
N   When this function is called, counter is pointing at an item on the
N   line that starts with the character 'z', indicating a z_coordinate
N   setting. The function reads characters which tell how to set the
N   coordinate, up to the start of the next item or the end of the line.
N   This information is inserted in the block. The counter is then set to
N   point to the character following.
N
N   The value may be a real number or something that evaluates to a
N   real number, so read_real_value is used to read it. Parameters
N   may be involved.
N
N   */
N
N    static int read_z(                            /* ARGUMENTS                                      */
N    char * line,                                  /* string: line of RS274 code being processed     */
N    int * counter,                                /* pointer to a counter for position on the line  */
N    block_pointer block,                          /* pointer to a block being filled from the line  */
N    double * parameters)                          /* array of system parameters                     */
N    {
N        static char name[] SET_TO "read_z";
X        static char name[] = "read_z";
N        double value;
N        int status;
N
N        CHK((line[*counter] ISNT 'z'), NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED);
X        if ((line[*counter] != 'z')) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 32; } else;
N        *counter SET_TO (*counter + 1);
X        *counter = (*counter + 1);
N        CHK((block->z_flag ISNT OFF), NCE_MULTIPLE_Z_WORDS_ON_ONE_LINE);
X        if ((block->z_flag != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 119; } else;
N        CHP(read_real_value(line, counter, &value, parameters));
X        if ((status = (read_real_value(line, counter, &value, parameters))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        block->z_flag SET_TO ON;
X        block->z_flag = 1;
N        block->z_number SET_TO value;
X        block->z_number = value;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* set_probe_data
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The current position is set.
N   System parameters for probe position are set.
N
N   Called by:  rs274ngc_read
N
N   */
N
N    static int set_probe_data(                    /* ARGUMENTS                   */
N    setup_pointer settings)                       /* pointer to machine settings */
N    {
N        static char name[] SET_TO "set_probe_data";
X        static char name[] = "set_probe_data";
N
N        settings->current_x SET_TO GET_EXTERNAL_POSITION_X();
X        settings->current_x = GET_EXTERNAL_POSITION_X();
N        settings->current_y SET_TO GET_EXTERNAL_POSITION_Y();
X        settings->current_y = GET_EXTERNAL_POSITION_Y();
N        settings->current_z SET_TO GET_EXTERNAL_POSITION_Z();
X        settings->current_z = GET_EXTERNAL_POSITION_Z();
N#ifdef AA
S   /*AA*/
S        settings->AA_current SET_TO GET_EXTERNAL_POSITION_A();
N#endif
N#ifdef BB
S   /*BB*/
S        settings->BB_current SET_TO GET_EXTERNAL_POSITION_B();
N#endif
N#ifdef CC
S   /*CC*/
S        settings->CC_current SET_TO GET_EXTERNAL_POSITION_C();
N#endif
N        settings->parameters[5061] SET_TO GET_EXTERNAL_PROBE_POSITION_X();
X        settings->parameters[5061] = GET_EXTERNAL_PROBE_POSITION_X();
N        settings->parameters[5062] SET_TO GET_EXTERNAL_PROBE_POSITION_Y();
X        settings->parameters[5062] = GET_EXTERNAL_PROBE_POSITION_Y();
N        settings->parameters[5063] SET_TO GET_EXTERNAL_PROBE_POSITION_Z();
X        settings->parameters[5063] = GET_EXTERNAL_PROBE_POSITION_Z();
N#ifdef AA
S   /*AA*/
S        settings->parameters[5064] SET_TO GET_EXTERNAL_PROBE_POSITION_A();
N#endif
N#ifdef BB
S   /*BB*/
S        settings->parameters[5065] SET_TO GET_EXTERNAL_PROBE_POSITION_B();
N#endif
N#ifdef CC
S   /*CC*/
S        settings->parameters[5066] SET_TO GET_EXTERNAL_PROBE_POSITION_C();
N#endif
N        settings->parameters[5067] SET_TO GET_EXTERNAL_PROBE_VALUE();
X        settings->parameters[5067] = GET_EXTERNAL_PROBE_VALUE();
N        return RS274NGC_OK;
X        return 0;
W "rs274ngc_pre.c" 11242 21 variable "name" was declared but never referenced
N    }
N
N   /****************************************************************************/
N   /* write_g_codes
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The active_g_codes in the settings are updated.
N
N   Called by:
N   rs274ngc_execute
N   rs274ngc_init
N
N   The block may be NULL.
N
N   This writes active g_codes into the settings->active_g_codes array by
N   examining the interpreter settings. The array of actives is composed
N   of ints, so (to handle codes like 59.1) all g_codes are reported as
N   ints ten times the actual value. For example, 59.1 is reported as 591.
N
N   The correspondence between modal groups and array indexes is as follows
N   (no apparent logic to it).
N
N   The group 0 entry is taken from the block (if there is one), since its
N   codes are not modal.
N
N   group 0  - gez[2]  g4, g10, g28, g30, g53, g92 g92.1, g92.2, g92.3 - misc
N   group 1  - gez[1]  g0, g1, g2, g3, g38.2, g80, g81, g82, g83, g84, g85,
N   g86, g87, g88, g89 - motion
N   group 2  - gez[3]  g17, g18, g19 - plane selection
N   group 3  - gez[6]  g90, g91 - distance mode
N   group 4  - no such group
N   group 5  - gez[7]  g93, g94 - feed rate mode
N   group 6  - gez[5]  g20, g21 - units
N   group 7  - gez[4]  g40, g41, g42 - cutter radius compensation
N   group 8  - gez[9]  g43, g49 - tool length offse
N   group 9  - no such group
N   group 10 - gez[10] g98, g99 - return mode in canned cycles
N   group 11 - no such group
N   group 12 - gez[8]  g54, g55, g56, g57, g58, g59, g59.1, g59.2, g59.3
N   - coordinate system
N   group 13 - gez[11] g61, g61.1, g64 - control mode
N
N   */
N
N    static int write_g_codes(                     /* ARGUMENTS                                    */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        int * gez;
N
N        gez SET_TO settings->active_g_codes;
X        gez = settings->active_g_codes;
N        gez[0] SET_TO settings->sequence_number;
X        gez[0] = settings->sequence_number;
N        gez[1] SET_TO settings->motion_mode;
X        gez[1] = settings->motion_mode;
N        gez[2] SET_TO ((block IS NULL) ? -1 : block->g_modes[0]);
X        gez[2] = ((block == 0) ? -1 : block->g_modes[0]);
N        gez[3] SET_TO
X        gez[3] =
N            (settings->plane IS CANON_PLANE_XY) ? G_17 :
X            (settings->plane == 1) ? 170 :
N        (settings->plane IS CANON_PLANE_XZ) ? G_18 : G_19;
X        (settings->plane == 3) ? 180 : 190;
N        gez[4] SET_TO
X        gez[4] =
N            (settings->cutter_comp_side IS RIGHT) ? G_42 :
X            (settings->cutter_comp_side == 1) ? 420 :
N        (settings->cutter_comp_side IS LEFT) ? G_41 : G_40;
X        (settings->cutter_comp_side == 2) ? 410 : 400;
N        gez[5] SET_TO
X        gez[5] =
N            (settings->length_units IS CANON_UNITS_INCHES) ? G_20 : G_21;
X            (settings->length_units == 1) ? 200 : 210;
N        gez[6] SET_TO
X        gez[6] =
N            (settings->distance_mode IS MODE_ABSOLUTE) ? G_90 : G_91;
X            (settings->distance_mode == MODE_ABSOLUTE) ? 900 : 910;
N        gez[7] SET_TO
X        gez[7] =
N            (settings->feed_mode IS INVERSE_TIME) ? G_93 : G_94;
X            (settings->feed_mode == 1) ? 930 : 940;
N        gez[8] SET_TO
X        gez[8] =
N            (settings->origin_index < 7) ? (530 + (10 * settings->origin_index)) :
N        (584 + settings->origin_index);
N        gez[9] SET_TO
X        gez[9] =
N            (settings->tool_length_offset IS 0.0) ? G_49 : G_43;
X            (settings->tool_length_offset == 0.0) ? 490 : 430;
N        gez[10] SET_TO
X        gez[10] =
N            (settings->retract_mode IS OLD_Z) ? G_98 : G_99;
X            (settings->retract_mode == OLD_Z) ? 980 : 990;
N        gez[11] SET_TO
X        gez[11] =
N            (settings->control_mode IS CANON_CONTINUOUS) ? G_64 :
X            (settings->control_mode == 3) ? 640 :
N        (settings->control_mode IS CANON_EXACT_PATH) ? G_61 : G_61_1;
X        (settings->control_mode == 2) ? 610 : 611;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* write_m_codes
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The settings->active_m_codes are updated.
N
N   Called by:
N   rs274ngc_execute
N   rs274ngc_init
N
N   This is testing only the feed override to see if overrides is on.
N   Might add check of speed override.
N
N   */
N
N    static int write_m_codes(                     /* ARGUMENTS                                    */
N    block_pointer block,                          /* pointer to a block of RS274/NGC instructions */
N    setup_pointer settings)                       /* pointer to machine settings                  */
N    {
N        int * emz;
N
N        emz SET_TO settings->active_m_codes;
X        emz = settings->active_m_codes;
N        emz[0] SET_TO settings->sequence_number;  /* 0 seq number  */
X        emz[0] = settings->sequence_number;   
N        emz[1] SET_TO
X        emz[1] =
N            (block IS NULL) ? -1 : block->m_modes[4];/* 1 stopping    */
X            (block == 0) ? -1 : block->m_modes[4]; 
N        emz[2] SET_TO
X        emz[2] =
N   /* 2 spindle     */
N            (settings->spindle_turning IS CANON_STOPPED) ? 5 :
X            (settings->spindle_turning == 1) ? 5 :
N        (settings->spindle_turning IS CANON_CLOCKWISE) ? 3 : 4;
X        (settings->spindle_turning == 2) ? 3 : 4;
N        emz[3] SET_TO                             /* 3 tool change */
X        emz[3] =                              
N            (block IS NULL) ? -1 : block->m_modes[6];
X            (block == 0) ? -1 : block->m_modes[6];
N        emz[4] SET_TO                             /* 4 mist        */
X        emz[4] =                              
N            (settings->mist IS ON) ? 7 :
X            (settings->mist == 1) ? 7 :
N        (settings->flood IS ON) ? -1 : 9;
X        (settings->flood == 1) ? -1 : 9;
N        emz[5] SET_TO                             /* 5 flood       */
X        emz[5] =                              
N            (settings->flood IS ON) ? 8 : -1;
X            (settings->flood == 1) ? 8 : -1;
N        emz[6] SET_TO                             /* 6 overrides   */
X        emz[6] =                              
N            (settings->feed_override IS ON) ? 48 : 49;
X            (settings->feed_override == 1) ? 48 : 49;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N
N   /* write_settings
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side effects:
N   The settings->active_settings array of doubles is updated with the
N   sequence number, feed, and speed settings.
N
N   Called by:
N   rs274ngc_execute
N   rs274ngc_init
N
N   */
N
N    static int write_settings(                    /* ARGUMENTS                   */
N    setup_pointer settings)                       /* pointer to machine settings */
N    {
N        double * vals;
N
N        vals SET_TO settings->active_settings;
X        vals = settings->active_settings;
N        vals[0] SET_TO settings->sequence_number; /* 0 sequence number */
X        vals[0] = settings->sequence_number;  
N        vals[1] SET_TO settings->feed_rate;       /* 1 feed rate       */
X        vals[1] = settings->feed_rate;        
N        vals[2] SET_TO settings->speed;           /* 2 spindle speed   */
X        vals[2] = settings->speed;            
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /****************************************************************************/
N   /****************************************************************************/
N
N   /*
N
N   The functions in this section of this file are functions for
N   external programs to call to tell the rs274ngc interpreter
N   what to do. They are declared in rs274ngc.hh.
N
N   */
N
N   /***********************************************************************/
N
N   /* rs274ngc_close
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side Effects:
N   The NC-code file is closed if open.
N   The _setup world model is reset.
N
N   Called By: external programs
N
N   */
N
N    int rs274ngc_close()
N    {
N        if (_setup.file_pointer ISNT NULL)
X        if (_setup.file_pointer != 0)
N        {
N            fclose(_setup.file_pointer);
N            _setup.file_pointer SET_TO NULL;
X            _setup.file_pointer = 0;
N        }
N        rs274ngc_reset();
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_execute
N
N   Returned Value: int)
N   If execute_block returns RS274NGC_EXIT, this returns that.
N   If execute_block returns RS274NGC_EXECUTE_FINISH, this returns that.
N   If execute_block returns an error code, this returns that code.
N   Otherwise, this returns RS274NGC_OK.
N
N   Side Effects:
N   Calls to canonical machining commands are made.
N   The interpreter variables are changed.
N   At the end of the program, the file is closed.
N   If using a file, the active G codes and M codes are updated.
N
N   Called By: external programs
N
N   This executes a previously parsed block.
N
N   */
N
N    int rs274ngc_execute()                        /* NO ARGUMENTS */
N    {
N        static char name[] SET_TO "rs274ngc_execute";
X        static char name[] = "rs274ngc_execute";
N        int status;
N        int n;
N
N        for (n SET_TO 0; n < _setup.parameter_occurrence; n++)
X        for (n = 0; n < _setup.parameter_occurrence; n++)
N        {                                         // copy parameter settings from parameter buffer into parameter table
N            _setup.parameters[_setup.parameter_numbers[n]]
N                SET_TO _setup.parameter_values[n];
X                = _setup.parameter_values[n];
N        }
N        if (_setup.line_length ISNT 0)            /* line not blank */
X        if (_setup.line_length != 0)             
N        {
N            status SET_TO execute_block (&(_setup.block1), &_setup);
X            status = execute_block (&(_setup.block1), &_setup);
N            write_g_codes(&(_setup.block1), &_setup);
N            write_m_codes(&(_setup.block1), &_setup);
N            write_settings(&_setup);
N            if ((status ISNT RS274NGC_OK) AND
X            if ((status != 0) &&
N                (status ISNT RS274NGC_EXECUTE_FINISH) AND
X                (status != 2) &&
N                (status ISNT RS274NGC_EXIT))
X                (status != 1))
N                ERP(status);
X                if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else return status;
N        }
N        else                                      /* blank line is OK */
N            status SET_TO RS274NGC_OK;
X            status = 0;
N        return status;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_exit
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side Effects: See below
N
N   Called By: external programs
N
N   The system parameters are saved to a file and some parts of the world
N   model are reset. If GET_EXTERNAL_PARAMETER_FILE_NAME provides a
N   non-empty file name, that name is used for the file that is
N   written. Otherwise, the default parameter file name is used.
N
N   */
N
N    int rs274ngc_exit()                           /* NO ARGUMENTS */
N    {
N        char file_name[RS274NGC_TEXT_SIZE];
X        char file_name[256];
N
N        GET_EXTERNAL_PARAMETER_FILE_NAME(file_name, (RS274NGC_TEXT_SIZE - 1));
X        GET_EXTERNAL_PARAMETER_FILE_NAME(file_name, (256 - 1));
N        rs274ngc_save_parameters
N            (((file_name[0] IS 0) ? RS274NGC_PARAMETER_FILE_NAME_DEFAULT : file_name),
X            (((file_name[0] == 0) ? "rs274ngc.var" : file_name),
N            _setup.parameters);
N        rs274ngc_reset();
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274_ngc_init
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, this returns RS274NGC_OK.
N   1. rs274ngc_restore_parameters returns an error code.
N   2. Parameter 5220, the work coordinate system index, is not in the range
N   1 to 9: NCE_COORDINATE_SYSTEM_INDEX_PARAMETER_5220_OUT_OF_RANGE
N
N   Side Effects:
N   Many values in the _setup structure are reset.
N   A USE_LENGTH_UNITS canonical command call is made.
N   A SET_FEED_REFERENCE canonical command call is made.
N   A SET_ORIGIN_OFFSETS canonical command call is made.
N   An INIT_CANON call is made.
N
N   Called By: external programs
N
N   Currently we are running only in CANON_XYZ feed_reference mode.  There
N   is no command regarding feed_reference in the rs274 language (we
N   should try to get one added). The initialization routine, therefore,
N   always calls SET_FEED_REFERENCE(CANON_XYZ).
N
N   */
N
N    int rs274ngc_init()                           /* NO ARGUMENTS */
N    {
N        static char name[] SET_TO "rs274ngc_init";
X        static char name[] = "rs274ngc_init";
N        int k;                                    // starting index in parameters of origin offsets
N        int status;
N        char filename[RS274NGC_TEXT_SIZE];
X        char filename[256];
N        double * pars;                            // short name for _setup.parameters
N
N        INIT_CANON();
N        _setup.length_units SET_TO GET_EXTERNAL_LENGTH_UNIT_TYPE();
X        _setup.length_units = GET_EXTERNAL_LENGTH_UNIT_TYPE();
N        USE_LENGTH_UNITS(_setup.length_units);
N        GET_EXTERNAL_PARAMETER_FILE_NAME(filename, RS274NGC_TEXT_SIZE);
X        GET_EXTERNAL_PARAMETER_FILE_NAME(filename, 256);
N        if (filename[0] IS 0)
X        if (filename[0] == 0)
N            strcpy(filename, RS274NGC_PARAMETER_FILE_NAME_DEFAULT);
X            strcpy(filename, "rs274ngc.var");
N        CHP(rs274ngc_restore_parameters(filename));
X        if ((status = (rs274ngc_restore_parameters(filename))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N        pars SET_TO _setup.parameters;
X        pars = _setup.parameters;
N        _setup.origin_index SET_TO (int)(pars[5220] + 0.0001);
X        _setup.origin_index = (int)(pars[5220] + 0.0001);
N        CHK(((_setup.origin_index < 1) OR (_setup.origin_index > 9)),
N            NCE_COORDINATE_SYSTEM_INDEX_PARAMETER_5220_OUT_OF_RANGE);
X        if (((_setup . origin_index < 1) || (_setup . origin_index > 9))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 68; } else;
N        k SET_TO (5200 + (_setup.origin_index * 20));
X        k = (5200 + (_setup.origin_index * 20));
N        SET_ORIGIN_OFFSETS((pars[k + 1] + pars[5211]),
N            (pars[k + 2] + pars[5212]),
N            (pars[k + 3] + pars[5213])
N    #ifdef AA
S            ,            (pars[k + 4] + pars[5214])
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef BB
S            ,            (pars[k + 5] + pars[5215])
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N    #ifdef CC
S            ,            (pars[k + 6] + pars[5216])
N    #else
N    #ifdef ALL_AXES
S            , 0
N    #endif
N    #endif
N            );
N        SET_FEED_REFERENCE(CANON_XYZ);
X        SET_FEED_REFERENCE(2);
N#ifdef AA
S        _setup.AA_axis_offset SET_TO pars[5214];  /*AA*/
N#endif
N   //_setup.Aa_current set in rs274ngc_synch
N#ifdef AA
S   /*AA*/
S        _setup.AA_origin_offset SET_TO pars[k + 4];
N#endif
N   //_setup.active_g_codes initialized below
N   //_setup.active_m_codes initialized below
N   //_setup.active_settings initialized below
N        _setup.axis_offset_x SET_TO pars[5211];
X        _setup.axis_offset_x = pars[5211];
N        _setup.axis_offset_y SET_TO pars[5212];
X        _setup.axis_offset_y = pars[5212];
N        _setup.axis_offset_z SET_TO pars[5213];
X        _setup.axis_offset_z = pars[5213];
N#ifdef BB
S        _setup.BB_axis_offset SET_TO pars[5215];  /*BB*/
N#endif
N   //_setup.Bb_current set in rs274ngc_synch
N#ifdef BB
S   /*BB*/
S        _setup.BB_origin_offset SET_TO pars[k + 5];
N#endif
N   //_setup.block1 does not need initialization
N        _setup.blocktext[0] SET_TO 0;
X        _setup.blocktext[0] = 0;
N#ifdef CC
S        _setup.CC_axis_offset SET_TO pars[5216];  /*CC*/
N#endif
N   //_setup.Cc_current set in rs274ngc_synch
N#ifdef CC
S   /*CC*/
S        _setup.CC_origin_offset SET_TO pars[k + 6];
N#endif
N   //_setup.current_slot set in rs274ngc_synch
N   //_setup.current_x set in rs274ngc_synch
N   //_setup.current_y set in rs274ngc_synch
N   //_setup.current_z set in rs274ngc_synch
N        _setup.cutter_comp_side SET_TO OFF;
X        _setup.cutter_comp_side = 0;
N   //_setup.cycle values do not need initialization
N        _setup.distance_mode SET_TO MODE_ABSOLUTE;
X        _setup.distance_mode = MODE_ABSOLUTE;
N        _setup.feed_mode SET_TO UNITS_PER_MINUTE;
X        _setup.feed_mode = 0;
N        _setup.feed_override SET_TO ON;
X        _setup.feed_override = 1;
N   //_setup.feed_rate set in rs274ngc_synch
N        _setup.filename[0] SET_TO 0;
X        _setup.filename[0] = 0;
N        _setup.file_pointer SET_TO NULL;
X        _setup.file_pointer = 0;
N   //_setup.flood set in rs274ngc_synch
N        _setup.length_offset_index SET_TO 1;
X        _setup.length_offset_index = 1;
N   //_setup.length_units set in rs274ngc_synch
N        _setup.line_length SET_TO 0;
X        _setup.line_length = 0;
N        _setup.linetext[0] SET_TO 0;
X        _setup.linetext[0] = 0;
N   //_setup.mist set in rs274ngc_synch
N        _setup.motion_mode SET_TO G_80;
X        _setup.motion_mode = 800;
N   //_setup.origin_index set above
N        _setup.origin_offset_x SET_TO pars[k + 1];
X        _setup.origin_offset_x = pars[k + 1];
N        _setup.origin_offset_y SET_TO pars[k + 2];
X        _setup.origin_offset_y = pars[k + 2];
N        _setup.origin_offset_z SET_TO pars[k + 3];
X        _setup.origin_offset_z = pars[k + 3];
N   //_setup.parameters set above
N   //_setup.parameter_occurrence does not need initialization
N   //_setup.parameter_numbers does not need initialization
N   //_setup.parameter_values does not need initialization
N   //_setup.percent_flag does not need initialization
N   //_setup.plane set in rs274ngc_synch
N        _setup.probe_flag SET_TO OFF;
X        _setup.probe_flag = 0;
N        _setup.program_x SET_TO UNKNOWN;          /* for cutter comp */
X        _setup.program_x = 1e-20;           
N        _setup.program_y SET_TO UNKNOWN;          /* for cutter comp */
X        _setup.program_y = 1e-20;           
N   //_setup.retract_mode does not need initialization
N   //_setup.selected_tool_slot set in rs274ngc_synch
N        _setup.sequence_number SET_TO 0;          /*DOES THIS NEED TO BE AT TOP? */
X        _setup.sequence_number = 0;           
N   //_setup.speed set in rs274ngc_synch
N        _setup.speed_feed_mode SET_TO CANON_INDEPENDENT;
X        _setup.speed_feed_mode = 2;
N        _setup.speed_override SET_TO ON;
X        _setup.speed_override = 1;
N   //_setup.spindle_turning set in rs274ngc_synch
N   //_setup.stack does not need initialization
N   //_setup.stack_index does not need initialization
N        _setup.tool_length_offset SET_TO 0.0;
X        _setup.tool_length_offset = 0.0;
N   //_setup.tool_max set in rs274ngc_synch
N   //_setup.tool_table set in rs274ngc_synch
N        _setup.tool_table_index SET_TO 1;
X        _setup.tool_table_index = 1;
N   //_setup.traverse_rate set in rs274ngc_synch
N
N        write_g_codes((block_pointer)NULL, &_setup);
X        write_g_codes((block_pointer)0, &_setup);
N        write_m_codes((block_pointer)NULL, &_setup);
X        write_m_codes((block_pointer)0, &_setup);
N        write_settings(&_setup);
N
N   // Synch rest of settings to external world
N        rs274ngc_synch();
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_load_tool_table
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, this returns RS274NGC_OK.
N   1. _setup.tool_max is larger than CANON_TOOL_MAX: NCE_TOOL_MAX_TOO_LARGE
N
N   Side Effects:
N   _setup.tool_table[] is modified.
N
N   Called By:
N   rs274ngc_synch
N   external programs
N
N   This function calls the canonical interface function GET_EXTERNAL_TOOL_TABLE
N   to load the whole tool table into the _setup.
N
N   The CANON_TOOL_MAX is an upper limit for this software. The
N   _setup.tool_max is intended to be set for a particular machine.
N
N   */
N
N    int rs274ngc_load_tool_table()                /* NO ARGUMENTS */
N    {
N//        static char name[] SET_TO "rs274ngc_load_tool_table";
N//        int n;
N//
N//        CHK((_setup.tool_max > CANON_TOOL_MAX), NCE_TOOL_MAX_TOO_LARGE);
N//        for (n SET_TO 0; n <= _setup.tool_max; n++)
N//        {
N//            _setup.tool_table[n] SET_TO GET_EXTERNAL_TOOL_TABLE(n);
N//        }
N//        for(; n <= CANON_TOOL_MAX; n++)
N//        {
N//            _setup.tool_table[n].id SET_TO 0;
N//            _setup.tool_table[n].length SET_TO 0;
N//            _setup.tool_table[n].diameter SET_TO 0;
N//        }
N		_setup.tool_table[0].id SET_TO 0;
X		_setup.tool_table[0].id = 0;
N		_setup.tool_table[0].length SET_TO 0;
X		_setup.tool_table[0].length = 0;
N		_setup.tool_table[0].diameter SET_TO 0;
X		_setup.tool_table[0].diameter = 0;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_open
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise it returns RS274NGC_OK.
N   1. A file is already open: NCE_A_FILE_IS_ALREADY_OPEN
N   2. The name of the file is too long: NCE_FILE_NAME_TOO_LONG
N   3. The file cannot be opened: NCE_UNABLE_TO_OPEN_FILE
N
N   Side Effects: See below
N
N   Called By: external programs
N
N   The file is opened for reading and _setup.file_pointer is set.
N   The file name is copied into _setup.filename.
N   The _setup.sequence_number, is set to zero.
N   rs274ngc_reset() is called, changing several more _setup attributes.
N
N   The manual [NCMS, page 3] discusses the use of the "%" character at the
N   beginning of a "tape". It is not clear whether it is intended that
N   every NC-code file should begin with that character.
N
N   In the following, "uses percents" means the first non-blank line
N   of the file must consist of nothing but the percent sign, with optional
N   leading and trailing white space, and there must be a second line
N   of the same sort later on in the file. If a file uses percents,
N   execution stops at the second percent line. Any lines after the
N   second percent line are ignored.
N
N   In this interpreter (recalling that M2 and M30 always ends execution):
N   1. If execution of a file is ended by M2 or M30 (not necessarily on
N   the last line of the file), then it is optional that the file
N   uses percents.
N   2. If execution of a file is not ended by M2 or M30, then it is
N   required that the file uses percents.
N
N   If the file being opened uses percents, this function turns on the
N   _setup.percent flag, reads any initial blank lines, and reads the
N   first line with the "%". If not, after reading enough to determine
N   that, this function puts the file pointer back at the beginning of the
N   file.
N
N   */
N
N    int rs274ngc_open(                            /* ARGUMENTS                                     */
N    const char * filename)                        /* string: the name of the input NC-program file */
N    {
N        static char name[] SET_TO "rs274ngc_open";
X        static char name[] = "rs274ngc_open";
N        char * line;
N        int index;
N        int length;
N
N        CHK((_setup.file_pointer ISNT NULL), NCE_A_FILE_IS_ALREADY_OPEN);
X        if ((_setup . file_pointer != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 4; } else;
N        CHK((strlen(filename) > (RS274NGC_TEXT_SIZE - 1)), NCE_FILE_NAME_TOO_LONG);
X        if ((strlen(filename) > (256 - 1))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 82; } else;
N        _setup.file_pointer SET_TO fopen(filename, "r");
X        _setup.file_pointer = fopen(filename, "r");
N        CHK((_setup.file_pointer IS NULL), NCE_UNABLE_TO_OPEN_FILE);
X        if ((_setup . file_pointer == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 170; } else;
N        line SET_TO _setup.linetext;
X        line = _setup.linetext;
N        for(index SET_TO -1; index IS -1;)        /* skip blank lines */
X        for(index = -1; index == -1;)         
N        {
N            CHK((fgets(line, RS274NGC_TEXT_SIZE, _setup.file_pointer) IS NULL),
N                NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN);
X            if ((fgets(line, 256, _setup . file_pointer) == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 80; } else;
N            length SET_TO strlen(line);
X            length = strlen(line);
N            if (length IS (RS274NGC_TEXT_SIZE - 1))
X            if (length == (256 - 1))
N            {                                     // line is too long. need to finish reading the line to recover
N   // could look for EOF
N                for(;fgetc(_setup.file_pointer) ISNT '\n';);
X                for(;fgetc(_setup.file_pointer) != '\n';);
N                ERM(NCE_COMMAND_TOO_LONG);
X                if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 66; } else;
N            }
N            for(index SET_TO (length -1);         // index set on last char
X            for(index = (length -1);         
N                (index >= 0) AND (isspace(line[index]));
X                (index >= 0) && (((* __rt_ctype_table())[line[index]] & 1));
N                index--);
N        }
N        if(line[index] IS '%')
X        if(line[index] == '%')
N        {
N            for(index--; (index >= 0) AND (isspace(line[index])); index--);
X            for(index--; (index >= 0) && (((* __rt_ctype_table())[line[index]] & 1)); index--);
N            if (index IS -1)
X            if (index == -1)
N                _setup.percent_flag SET_TO ON;
X                _setup.percent_flag = 1;
N            else
N            {
N                fseek(_setup.file_pointer, 0, SEEK_SET);
X                fseek(_setup.file_pointer, 0, 0);
N                _setup.percent_flag SET_TO OFF;
X                _setup.percent_flag = 0;
N            }
N        }
N        else
N        {
N            fseek(_setup.file_pointer, 0, SEEK_SET);
X            fseek(_setup.file_pointer, 0, 0);
N            _setup.percent_flag SET_TO OFF;
X            _setup.percent_flag = 0;
N        }
N        strcpy(_setup.filename, filename);
N        _setup.sequence_number SET_TO 0;
X        _setup.sequence_number = 0;
N        rs274ngc_reset();
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_read
N
N   Returned Value: int
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise, this returns:
N   a. RS274NGC_ENDFILE if the only non-white character on the line is %,
N   b. RS274NGC_EXECUTE_FINISH if the first character of the
N   close_and_downcased line is a slash, and
N   c. RS274NGC_OK otherwise.
N   1. The command and_setup.file_pointer are both NULL: NCE_FILE_NOT_OPEN
N   2. The probe_flag is ON but the HME command queue is not empty:
N   NCE_QUEUE_IS_NOT_EMPTY_AFTER_PROBING
N   3. If read_text (which gets a line of NC code from file) or parse_line
N   (which parses the line) returns an error code, this returns that code.
N
N   Side Effects:
N   _setup.sequence_number is incremented.
N   The _setup.block1 is filled with data.
N
N   Called By: external programs
N
N   This reads a line of NC-code from the command string or, (if the
N   command string is NULL) from the currently open file. The
N   _setup.line_length will be set by read_text. This will be zero if the
N   line is blank or consists of nothing but a slash. If the length is not
N   zero, this parses the line into the _setup.block1.
N
N   */
N
N    int rs274ngc_read(                            /* ARGUMENTS                       */
N    const char * command)                         /* may be NULL or a string to read */
N    {
N        static char name[] SET_TO "rs274ngc_read";
X        static char name[] = "rs274ngc_read";
N        int status;
N        int read_status;
N
N        if (_setup.probe_flag IS ON)
X        if (_setup.probe_flag == 1)
N        {
N            CHK((GET_EXTERNAL_QUEUE_EMPTY() IS 0),
N                NCE_QUEUE_IS_NOT_EMPTY_AFTER_PROBING);
X            if ((GET_EXTERNAL_QUEUE_EMPTY() == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 145; } else;
N            set_probe_data(&_setup);
N            _setup.probe_flag SET_TO OFF;
X            _setup.probe_flag = 0;
N        }
N        CHK(((command IS NULL) AND (_setup.file_pointer IS NULL)),
N            NCE_FILE_NOT_OPEN);
X        if (((command == 0) && (_setup . file_pointer == 0))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 83; } else;
N        read_status SET_TO read_text(command, _setup.file_pointer, _setup.linetext,
X        read_status = read_text(command, _setup.file_pointer, _setup.linetext,
N            _setup.blocktext, &_setup.line_length);
N        if ((read_status IS RS274NGC_EXECUTE_FINISH) OR
X        if ((read_status == 2) ||
N            (read_status IS RS274NGC_OK))
X            (read_status == 0))
N        {
N            if (_setup.line_length ISNT 0)
X            if (_setup.line_length != 0)
N            {
N                CHP(parse_line(_setup.blocktext, &(_setup.block1), &_setup));
X                if ((status = (parse_line(_setup . blocktext, &(_setup . block1), &_setup))) != 0) { if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return status; } else {return status;} } else;
N            }
N        }
N        else if (read_status IS RS274NGC_ENDFILE);
X        else if (read_status == 3);
N        else
N            ERP(read_status);
X            if (_setup . stack_index < 49) { strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return read_status; } else return read_status;
N        return read_status;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_reset
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side Effects: See below
N
N   Called By:
N   external programs
N   rs274ngc_close
N   rs274ngc_exit
N   rs274ngc_open
N
N   This function resets the parts of the _setup model having to do with
N   reading and interpreting one line. It does not affect the parts of the
N   model dealing with a file being open; rs274ngc_open and rs274ngc_close
N   do that.
N
N   There is a hierarchy of resetting the interpreter. Each of the following
N   calls does everything the ones above it do.
N
N   rs274ngc_reset()
N   rs274ngc_close()
N   rs274ngc_init()
N
N   In addition, rs274ngc_synch and rs274ngc_restore_parameters (both of
N   which are called by rs274ngc_init) change the model.
N
N   */
N
N    int rs274ngc_reset()
N    {
N        _setup.linetext[0] SET_TO 0;
X        _setup.linetext[0] = 0;
N        _setup.blocktext[0] SET_TO 0;
X        _setup.blocktext[0] = 0;
N        _setup.line_length SET_TO 0;
X        _setup.line_length = 0;
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_restore_parameters
N
N   Returned Value:
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise it returns RS274NGC_OK.
N   1. The parameter file cannot be opened for reading: NCE_UNABLE_TO_OPEN_FILE
N   2. A parameter index is out of range: NCE_PARAMETER_NUMBER_OUT_OF_RANGE
N   3. A required parameter is missing from the file:
N   NCE_REQUIRED_PARAMETER_MISSING
N   4. The parameter file is not in increasing order:
N   NCE_PARAMETER_FILE_OUT_OF_ORDER
N
N   Side Effects: See below
N
N   Called By:
N   external programs
N   rs274ngc_init
N
N   This function restores the parameters from a file, modifying the
N   parameters array. Usually parameters is _setup.parameters. The file
N   contains lines of the form:
N
N   <variable number> <value>
N
N   e.g.,
N
N   5161 10.456
N
N   The variable numbers must be in increasing order, and certain
N   parameters must be included, as given in the _required_parameters
N   array. These are the axis offsets, the origin index (5220), and nine
N   sets of origin offsets. Any parameter not given a value in the file
N   has its value set to zero.
N
N   */
N    int rs274ngc_restore_parameters(              /* ARGUMENTS                        */
N    const char * filename)                        /* name of parameter file to read   */
N    {
N//        static char name[] SET_TO "rs274ngc_restore_parameters";
N//        FILE * infile;
N//        char line[256];
N//        int variable;
N//        double value;
N//        int required;                             // number of next required parameter
N//        int index;                                // index into _required_parameters
N        double * pars;                            // short name for _setup.parameters
N        int k;
N//
N//   // open original for reading
N//        infile SET_TO fopen(filename, "r");
N//        CHK((infile IS NULL), NCE_UNABLE_TO_OPEN_FILE);
N//
N        pars SET_TO _setup.parameters;
X        pars = _setup.parameters;
N//        k SET_TO 0;
N//        index SET_TO 0;
N//        required SET_TO _required_parameters[index++];
N//        while (feof(infile) IS 0)
N//        {
N//            if (fgets(line, 256, infile) IS NULL)
N//            {
N//                break;
N//            }
N//
N//   // try for a variable-value match in the file
N//            if (sscanf(line, "%d %lf", &variable, &value) IS 2)
N//            {
N//                CHK(((variable <= 0) OR (variable >= RS274NGC_MAX_PARAMETERS)),
N//                    NCE_PARAMETER_NUMBER_OUT_OF_RANGE);
N//                for (; k < RS274NGC_MAX_PARAMETERS; k++)
N//                {
N//                    if (k > variable)
N//                        ERM(NCE_PARAMETER_FILE_OUT_OF_ORDER);
N//                    else if (k IS variable)
N//                    {
N//                        pars[k] SET_TO value;
N//                        if (k IS required)
N//                            required SET_TO _required_parameters[index++];
N//                        k++;
N//                        break;
N//                    }
N//                    else                          // if (k < variable)
N//                    {
N//                        if (k IS required)
N//                            ERM(NCE_REQUIRED_PARAMETER_MISSING);
N//                        else
N//                            pars[k] SET_TO 0;
N//                    }
N//                }
N//            }
N//        }
N//        fclose(infile);
N//        CHK((required ISNT RS274NGC_MAX_PARAMETERS), NCE_REQUIRED_PARAMETER_MISSING);
N        for (; k < RS274NGC_MAX_PARAMETERS; k++)
X        for (; k < 5400; k++)
N        {
N            pars[k] SET_TO 0;
X            pars[k] = 0;
N        }
N		pars[5220]=1.0;
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_save_parameters
N
N   Returned Value:
N   If any of the following errors occur, this returns the error code shown.
N   Otherwise it returns RS274NGC_OK.
N   1. The existing file cannot be renamed:  NCE_CANNOT_CREATE_BACKUP_FILE
N   2. The renamed file cannot be opened to read: NCE_CANNOT_OPEN_BACKUP_FILE
N   3. The new file cannot be opened to write: NCE_CANNOT_OPEN_VARIABLE_FILE
N   4. A parameter index is out of range: NCE_PARAMETER_NUMBER_OUT_OF_RANGE
N   5. The renamed file is out of order: NCE_PARAMETER_FILE_OUT_OF_ORDER
N
N   Side Effects: See below
N
N   Called By:
N   external programs
N   rs274ngc_exit
N
N   A file containing variable-value assignments is updated. The old
N   version of the file is saved under a different name.  For each
N   variable-value pair in the old file, a line is written in the new file
N   giving the current value of the variable.  File lines have the form:
N
N   <variable number> <value>
N
N   e.g.,
N
N   5161 10.456
N
N   If a required parameter is missing from the input file, this does not
N   complain, but does write it in the output file.
N
N   */
N    int rs274ngc_save_parameters(                 /* ARGUMENTS             */
N    const char * filename,                        /* name of file to write */
N    const double parameters[])                    /* parameters to save    */
N    {
N        static char name[] SET_TO "rs274ngc_save_parameters";
X        static char name[] = "rs274ngc_save_parameters";
N        FILE * infile;
N        FILE * outfile;
N        char line[256];
N        int variable;
N        double value;
N        int required;                             // number of next required parameter
N        int index;                                // index into _required_parameters
N        int k;
N
N   // rename as .bak
N        strcpy(line, filename);
N        strcat(line, RS274NGC_PARAMETER_FILE_BACKUP_SUFFIX);
X        strcat(line, ".bak");
N        CHK((rename(filename, line) ISNT 0), NCE_CANNOT_CREATE_BACKUP_FILE);
X        if ((rename(filename, line) != 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 40; } else;
N
N   // open backup for reading
N        infile SET_TO fopen(line, "r");
X        infile = fopen(line, "r");
N        CHK((infile IS NULL), NCE_CANNOT_OPEN_BACKUP_FILE);
X        if ((infile == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 45; } else;
N
N   // open original for writing
N        outfile SET_TO fopen(filename, "w");
X        outfile = fopen(filename, "w");
N        CHK((outfile IS NULL), NCE_CANNOT_OPEN_VARIABLE_FILE);
X        if ((outfile == 0)) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 46; } else;
N
N        k SET_TO 0;
X        k = 0;
N        index SET_TO 0;
X        index = 0;
N        required SET_TO _required_parameters[index++];
X        required = _required_parameters[index++];
N        while (feof(infile) IS 0)
X        while (feof(infile) == 0)
N        {
N            if (fgets(line, 256, infile) IS NULL)
X            if (fgets(line, 256, infile) == 0)
N            {
N                break;
N            }
N   // try for a variable-value match
W "rs274ngc_pre.c" 12128 50 argument is incompatible with corresponding format string conversion
N            if (sscanf(line, "%d %f", &variable, &value) IS 2)
X            if (sscanf(line, "%d %f", &variable, &value) == 2)
N            {
N                CHK(((variable <= 0) OR (variable >= RS274NGC_MAX_PARAMETERS)),
N                    NCE_PARAMETER_NUMBER_OUT_OF_RANGE);
X                if (((variable <= 0) || (variable >= 5400))) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 142; } else;
N                for (; k < RS274NGC_MAX_PARAMETERS; k++)
X                for (; k < 5400; k++)
N                {
N                    if (k > variable)
N                        ERM(NCE_PARAMETER_FILE_OUT_OF_ORDER);
X                        if (1) { _setup . stack_index = 0; strcpy(_setup . stack[_setup . stack_index++], name); _setup . stack[_setup . stack_index][0] = 0; return 141; } else;
N                    else if (k IS variable)
X                    else if (k == variable)
N                    {
N                        sprintf(line, "%d\t%f\r\n", k, parameters[k]);
N                        fputs(line, outfile);
N                        if (k IS required)
X                        if (k == required)
N                            required SET_TO _required_parameters[index++];
X                            required = _required_parameters[index++];
N                        k++;
N                        break;
N                    }
N                    else if (k IS required)       // know (k < variable)
X                    else if (k == required)       
N                    {
N                        sprintf(line, "%d\t%f\r\n", k, parameters[k]);
N                        fputs(line, outfile);
N                        required SET_TO _required_parameters[index++];
X                        required = _required_parameters[index++];
N                    }
N                }
N            }
N        }
N        fclose(infile);
N        for (; k < RS274NGC_MAX_PARAMETERS; k++)
X        for (; k < 5400; k++)
N        {
N            if (k IS required)
X            if (k == required)
N            {
N                sprintf(line, "%d\t%f\r\n", k, parameters[k]);
N                fputs(line, outfile);
N                required SET_TO _required_parameters[index++];
X                required = _required_parameters[index++];
N            }
N        }
N        fclose(outfile);
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_synch
N
N   Returned Value: int (RS274NGC_OK)
N
N   Side Effects:
N   sets the value of many attribute of _setup by calling various
N   GET_EXTERNAL_xxx functions.
N
N   Called By:
N   rs274ngc_init
N   external programs
N
N   This function gets the _setup world model in synch with the rest of
N   the controller.
N
N   */
N
N    int rs274ngc_synch()                          /* NO ARGUMENTS */
N    {
N        _setup.control_mode SET_TO GET_EXTERNAL_MOTION_CONTROL_MODE();
X        _setup.control_mode = GET_EXTERNAL_MOTION_CONTROL_MODE();
N#ifdef AA
S   /*AA*/
S        _setup.AA_current SET_TO GET_EXTERNAL_POSITION_A();
N#endif
N#ifdef BB
S   /*BB*/
S        _setup.BB_current SET_TO GET_EXTERNAL_POSITION_B();
N#endif
N#ifdef CC
S   /*CC*/
S        _setup.CC_current SET_TO GET_EXTERNAL_POSITION_C();
N#endif
N        _setup.current_slot SET_TO GET_EXTERNAL_TOOL_SLOT();
X        _setup.current_slot = GET_EXTERNAL_TOOL_SLOT();
N        _setup.current_x SET_TO GET_EXTERNAL_POSITION_X();
X        _setup.current_x = GET_EXTERNAL_POSITION_X();
N        _setup.current_y SET_TO GET_EXTERNAL_POSITION_Y();
X        _setup.current_y = GET_EXTERNAL_POSITION_Y();
N        _setup.current_z SET_TO GET_EXTERNAL_POSITION_Z();
X        _setup.current_z = GET_EXTERNAL_POSITION_Z();
N        _setup.feed_rate SET_TO GET_EXTERNAL_FEED_RATE();
X        _setup.feed_rate = GET_EXTERNAL_FEED_RATE();
N        _setup.flood SET_TO (GET_EXTERNAL_FLOOD() ISNT 0) ? ON : OFF;
X        _setup.flood = (GET_EXTERNAL_FLOOD() != 0) ? 1 : 0;
N        _setup.length_units SET_TO GET_EXTERNAL_LENGTH_UNIT_TYPE();
X        _setup.length_units = GET_EXTERNAL_LENGTH_UNIT_TYPE();
N        _setup.mist SET_TO (GET_EXTERNAL_MIST() ISNT 0) ? ON : OFF;
X        _setup.mist = (GET_EXTERNAL_MIST() != 0) ? 1 : 0;
N        _setup.plane SET_TO GET_EXTERNAL_PLANE();
X        _setup.plane = GET_EXTERNAL_PLANE();
N        _setup.selected_tool_slot SET_TO GET_EXTERNAL_TOOL_SLOT();
X        _setup.selected_tool_slot = GET_EXTERNAL_TOOL_SLOT();
N        _setup.speed SET_TO GET_EXTERNAL_SPEED();
X        _setup.speed = GET_EXTERNAL_SPEED();
N        _setup.spindle_turning SET_TO GET_EXTERNAL_SPINDLE();
X        _setup.spindle_turning = GET_EXTERNAL_SPINDLE();
N        _setup.tool_max SET_TO GET_EXTERNAL_TOOL_MAX();
X        _setup.tool_max = GET_EXTERNAL_TOOL_MAX();
N        _setup.traverse_rate SET_TO GET_EXTERNAL_TRAVERSE_RATE();
X        _setup.traverse_rate = GET_EXTERNAL_TRAVERSE_RATE();
N
W "rs274ngc_pre.c" 12218 53 nested comment is not allowed
N/*        rs274ngc_load_tool_table();               /*  must set  _setup.tool_max first */
N
N        return RS274NGC_OK;
X        return 0;
N    }
N
N   /***********************************************************************/
N   /***********************************************************************/
N
N   /*
N
N   The functions in this section are to extract information from the
N   interpreter.
N
N   */
N
N   /***********************************************************************/
N
N   /* rs274ngc_active_g_codes
N
N   Returned Value: none
N
N   Side Effects: copies active G codes into the codes array
N
N   Called By: external programs
N
N   See documentation of write_g_codes.
N
N   */
N
N    void rs274ngc_active_g_codes(                 /* ARGUMENTS                   */
N    int * codes)                                  /* array of codes to copy into */
N    {
N        int n;
N
N        for (n SET_TO 0; n < RS274NGC_ACTIVE_G_CODES; n++)
X        for (n = 0; n < 12; n++)
N        {
N            codes[n] SET_TO _setup.active_g_codes[n];
X            codes[n] = _setup.active_g_codes[n];
N        }
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_active_m_codes
N
N   Returned Value: none
N
N   Side Effects: copies active M codes into the codes array
N
N   Called By: external programs
N
N   See documentation of write_m_codes.
N
N   */
N
N    void rs274ngc_active_m_codes(                 /* ARGUMENTS                   */
N    int * codes)                                  /* array of codes to copy into */
N    {
N        int n;
N
N        for (n SET_TO 0; n < RS274NGC_ACTIVE_M_CODES; n++)
X        for (n = 0; n < 7; n++)
N        {
N            codes[n] SET_TO _setup.active_m_codes[n];
X            codes[n] = _setup.active_m_codes[n];
N        }
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_active_settings
N
N   Returned Value: none
N
N   Side Effects: copies active F, S settings into array
N
N   Called By: external programs
N
N   See documentation of write_settings.
N
N   */
N
N    void rs274ngc_active_settings(                /* ARGUMENTS                      */
N    double * settings)                            /* array of settings to copy into */
N    {
N        int n;
N
N        for (n SET_TO 0; n < RS274NGC_ACTIVE_SETTINGS; n++)
X        for (n = 0; n < 3; n++)
N        {
N            settings[n] SET_TO _setup.active_settings[n];
X            settings[n] = _setup.active_settings[n];
N        }
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_error_text
N
N   Returned Value: none
N
N   Side Effects: see below
N
N   Called By: external programs
N
N   This copies the error string whose index in the _rs274ngc_errors array
N   is error_code into the error_text array -- unless the error_code is
N   an out-of-bounds index or the length of the error string is not less
N   than max_size, in which case an empty string is put into the
N   error_text. The length of the error_text array should be at least
N   max_size.
N
N   */
N    void rs274ngc_error_text(                     /* ARGUMENTS                            */
N    int error_code,                               /* code number of error                 */
N    char * error_text,                            /* char array to copy error text into   */
N    unsigned int max_size)                                 /* maximum number of characters to copy */
N    {
N        if (((error_code >= RS274NGC_MIN_ERROR) AND
X        if (((error_code >= 3) &&
N            (error_code <= RS274NGC_MAX_ERROR)) AND
X            (error_code <= 197)) &&
N            (strlen(_rs274ngc_errors[error_code]) < max_size))
N        {
N            strcpy(error_text, _rs274ngc_errors[error_code]);
N        }
N        else
N            error_text[0] SET_TO 0;
X            error_text[0] = 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_file_name
N
N   Returned Value: none
N
N   Side Effects: see below
N
N   Called By: external programs
N
N   This copies the _setup.filename (the name of the currently open
N   file) into the file_name array -- unless the name is not shorter than
N   max_size, in which case a null string is put in the file_name array.
N
N   */
N
N    void rs274ngc_file_name(                      /* ARGUMENTS                            */
N    char * file_name,                             /* string: to copy file name into       */
N    unsigned int max_size)                                 /* maximum number of characters to copy */
N    {
N        if (strlen(_setup.filename) < max_size)
N            strcpy(file_name, _setup.filename);
N        else
N            file_name[0] SET_TO 0;
X            file_name[0] = 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_line_length
N
N   Returned Value: the length of the most recently read line
N
N   Side Effects: none
N
N   Called By: external programs
N
N   */
N
N    int rs274ngc_line_length()
N    {
N        return _setup.line_length;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_line_text
N
N   Returned Value: none
N
N   Side Effects: See below
N
N   Called By: external programs
N
N   This copies at most (max_size - 1) non-null characters of the most
N   recently read line into the line_text string and puts a NULL after the
N   last non-null character.
N
N   */
N
N    void rs274ngc_line_text(                      /* ARGUMENTS                            */
N    char * line_text,                             /* string: to copy line into            */
N    int max_size)                                 /* maximum number of characters to copy */
N    {
N        int n;
N        char * the_text;
N
N        the_text SET_TO _setup.linetext;
X        the_text = _setup.linetext;
N        for (n SET_TO 0; n < (max_size - 1); n++)
X        for (n = 0; n < (max_size - 1); n++)
N        {
N            if (the_text[n] ISNT 0)
X            if (the_text[n] != 0)
N                line_text[n] SET_TO the_text[n];
X                line_text[n] = the_text[n];
N            else
N                break;
N        }
N        line_text[n] SET_TO 0;
X        line_text[n] = 0;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_sequence_number
N
N   Returned Value: the current interpreter sequence number (how many
N   lines read since the last time the sequence number was reset to zero,
N   which happens only when rs274ngc_init or rs274ngc_open is called).
N
N   Side Effects: none
N
N   Called By: external programs
N
N   */
N
N    int rs274ngc_sequence_number()
N    {
N        return _setup.sequence_number;
N    }
N
N   /***********************************************************************/
N
N   /* rs274ngc_stack_name
N
N   Returned Value: none
N
N   Side Effects: see below
N
N   Called By: external programs
N
N   This copies at most (max_size - 1) non-null characters from the
N   string whose index in the _setup.stack array is stack_index into the
N   function_name string and puts a NULL after the last non-null character --
N   unless the stack_index is an out-of-bounds index, in which case an
N   empty string is put into the function_name.
N
N   This function is intended to be used several times in a row to get the
N   stack of function calls that existed when the most recent error
N   occurred. It should be called first with stack_index equal to 0,
N   next with stack_index equal to 1, and so on, stopping when an
N   empty string is returned for the name.
N
N   */
N
N    void rs274ngc_stack_name(                     /* ARGUMENTS                            */
N    int stack_index,                              /* index into stack of function names   */
N    char * function_name,                         /* string: to copy function name into   */
N    int max_size)                                 /* maximum number of characters to copy */
N    {
N        int n;
N        char * the_name;
N
N        if ((stack_index > -1) AND (stack_index < 20))
X        if ((stack_index > -1) && (stack_index < 20))
N        {
N            the_name SET_TO _setup.stack[stack_index];
X            the_name = _setup.stack[stack_index];
N            for (n SET_TO 0; n < (max_size - 1); n++)
X            for (n = 0; n < (max_size - 1); n++)
N            {
N                if (the_name[n] ISNT 0)
X                if (the_name[n] != 0)
N                    function_name[n] SET_TO the_name[n];
X                    function_name[n] = the_name[n];
N                else
N                    break;
N            }
N            function_name[n] SET_TO 0;
X            function_name[n] = 0;
N        }
N        else
N            function_name[0] SET_TO 0;
X            function_name[0] = 0;
N    }
N
N   /***********************************************************************/
N   /***********************************************************************/
N   /* end of file */
