L 1 "main.c"
N/*******************************************************************************
N* File Name          : main.c
N* Author             : POWER AVR
N* Date First Issued  : 08/08/2008
N* Description        : Main program body
N********************************************************************************/
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_lib.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_lib.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file includes the peripherals header files in the
N*                      user application.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_LIB_H
N#define __STM32F10x_LIB_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_map.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_map.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the peripheral register's definitions
N*                      and memory mapping.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_MAP_H
N#define __STM32F10x_MAP_H
N
N#ifndef EXT
N  #define EXT extern
N#endif /* EXT */
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_conf.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_conf.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_conf.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : Library configuration file.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CONF_H
N#define __STM32F10x_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_type.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_type.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the common data types used for the
N*                      STM32F10x firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TYPE_H
N#define __STM32F10x_TYPE_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
Ntypedef signed long  s32;
Ntypedef signed short s16;
Ntypedef signed char  s8;
N
Ntypedef signed long  const sc32;  /* Read Only */
Ntypedef signed short const sc16;  /* Read Only */
Ntypedef signed char  const sc8;   /* Read Only */
N
Ntypedef volatile signed long  vs32;
Ntypedef volatile signed short vs16;
Ntypedef volatile signed char  vs8;
N
Ntypedef volatile signed long  const vsc32;  /* Read Only */
Ntypedef volatile signed short const vsc16;  /* Read Only */
Ntypedef volatile signed char  const vsc8;   /* Read Only */
N
Ntypedef unsigned long  u32;
Ntypedef unsigned short u16;
Ntypedef unsigned char  u8;
N
Ntypedef unsigned long  const uc32;  /* Read Only */
Ntypedef unsigned short const uc16;  /* Read Only */
Ntypedef unsigned char  const uc8;   /* Read Only */
N
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
Ntypedef volatile unsigned char  vu8;
N
Ntypedef volatile unsigned long  const vuc32;  /* Read Only */
Ntypedef volatile unsigned short const vuc16;  /* Read Only */
Ntypedef volatile unsigned char  const vuc8;   /* Read Only */
N
Ntypedef enum {FALSE = 0, TRUE = !FALSE} bool;
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N#define U8_MAX     ((u8)255)
N#define S8_MAX     ((s8)127)
N#define S8_MIN     ((s8)-128)
N#define U16_MAX    ((u16)65535u)
N#define S16_MAX    ((s16)32767)
N#define S16_MIN    ((s16)-32768)
N#define U32_MAX    ((u32)4294967295uL)
N#define S32_MAX    ((s32)2147483647)
N#define S32_MIN    ((s32)-2147483648)
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_TYPE_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 22 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
N   the "assert_param" macro in the firmware library code (see "Exported macro"
N   section below) */
N/* #define DEBUG    1*/
N
N/* Comment the line below to disable the specific peripheral inclusion */
N/************************************* ADC ************************************/
N#define _ADC
N#define _ADC1
N#define _ADC2
N#define _ADC3
N
N/************************************* BKP ************************************/
N#define _BKP 
N
N/************************************* CAN ************************************/
N#define _CAN
N
N/************************************* CRC ************************************/
N#define _CRC
N
N/************************************* DAC ************************************/
N#define _DAC
N
N/************************************* DBGMCU *********************************/
N#define _DBGMCU
N
N/************************************* DMA ************************************/
N#define _DMA
N#define _DMA1_Channel1
N#define _DMA1_Channel2
N#define _DMA1_Channel3
N#define _DMA1_Channel4
N#define _DMA1_Channel5
N#define _DMA1_Channel6
N#define _DMA1_Channel7
N#define _DMA2_Channel1
N#define _DMA2_Channel2
N#define _DMA2_Channel3
N#define _DMA2_Channel4
N#define _DMA2_Channel5
N
N/************************************* EXTI ***********************************/
N#define _EXTI
N
N/************************************* FLASH and Option Bytes *****************/
N#define _FLASH
N/* Uncomment the line below to enable FLASH program/erase/protections functions,
N   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
N   are enabled */
N#define _FLASH_PROG
N
N/************************************* FSMC ***********************************/
N#define _FSMC
N
N/************************************* GPIO ***********************************/
N#define _GPIO
N#define _GPIOA
N#define _GPIOB
N#define _GPIOC
N#define _GPIOD
N#define _GPIOE
N#define _GPIOF
N#define _GPIOG
N#define _AFIO
N
N/************************************* I2C ************************************/
N#define _I2C
N#define _I2C1
N#define _I2C2
N
N/************************************* IWDG ***********************************/
N#define _IWDG
N
N/************************************* NVIC ***********************************/
N#define _NVIC
N
N/************************************* PWR ************************************/
N#define _PWR
N
N/************************************* RCC ************************************/
N#define _RCC
N
N/************************************* RTC ************************************/
N#define _RTC
N
N/************************************* SDIO ***********************************/
N#define _SDIO
N
N/************************************* SPI ************************************/
N#define _SPI
N#define _SPI1
N#define _SPI2
N#define _SPI3
N
N/************************************* SysTick ********************************/
N#define _SysTick
N
N/************************************* TIM ************************************/
N#define _TIM
N#define _TIM1
N#define _TIM2
N#define _TIM3
N#define _TIM4
N#define _TIM5
N#define _TIM6
N#define _TIM7
N#define _TIM8
N
N/************************************* USART **********************************/
N#define _USART
N#define _USART1
N#define _USART2
N#define _USART3
N#define _UART4
N#define _UART5
N
N/************************************* WWDG ***********************************/
N#define _WWDG
N
N/* In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application */
N#define HSE_Value    ((u32)8000000) /* Value of the External oscillator in Hz*/
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  DEBUG
S/*******************************************************************************
S* Macro Name     : assert_param
S* Description    : The assert_param macro is used for function's parameters check.
S*                  It is used only if the library is compiled in DEBUG mode. 
S* Input          : - expr: If expr is false, it calls assert_failed function
S*                    which reports the name of the source file and the source
S*                    line number of the call that failed. 
S*                    If expr is true, it returns no value.
S* Return         : None
S*******************************************************************************/ 
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(u8* file, u32 line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* DEBUG */
N
N#endif /* __STM32F10x_CONF_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 27 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_map.h" 2
N#include "stm32f10x_type.h"
N#include "cortexm3_macro.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\cortexm3_macro.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : cortexm3_macro.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : Header file for cortexm3_macro.s.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CORTEXM3_MACRO_H
N#define __CORTEXM3_MACRO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid __WFI(void);
Nvoid __WFE(void);
Nvoid __SEV(void);
Nvoid __ISB(void);
Nvoid __DSB(void);
Nvoid __DMB(void);
Nvoid __SVC(void);
Nu32 __MRS_CONTROL(void);
Nvoid __MSR_CONTROL(u32 Control);
Nu32 __MRS_PSP(void);
Nvoid __MSR_PSP(u32 TopOfProcessStack);
Nu32 __MRS_MSP(void);
Nvoid __MSR_MSP(u32 TopOfMainStack);
Nvoid __RESETPRIMASK(void);
Nvoid __SETPRIMASK(void);
Nu32 __READ_PRIMASK(void);
Nvoid __RESETFAULTMASK(void);
Nvoid __SETFAULTMASK(void);
Nu32 __READ_FAULTMASK(void);
Nvoid __BASEPRICONFIG(u32 NewPriority);
Nu32 __GetBASEPRI(void);
Nu16 __REV_HalfWord(u16 Data);
Nu32 __REV_Word(u32 Data);
N
N#endif /* __CORTEXM3_MACRO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 29 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_map.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/******************************************************************************/
N/*                         Peripheral registers structures                    */
N/******************************************************************************/
N
N/*------------------------ Analog to Digital Converter -----------------------*/
Ntypedef struct
N{
N  vu32 SR;
N  vu32 CR1;
N  vu32 CR2;
N  vu32 SMPR1;
N  vu32 SMPR2;
N  vu32 JOFR1;
N  vu32 JOFR2;
N  vu32 JOFR3;
N  vu32 JOFR4;
N  vu32 HTR;
N  vu32 LTR;
N  vu32 SQR1;
N  vu32 SQR2;
N  vu32 SQR3;
N  vu32 JSQR;
N  vu32 JDR1;
N  vu32 JDR2;
N  vu32 JDR3;
N  vu32 JDR4;
N  vu32 DR;
N} ADC_TypeDef;
N
N/*------------------------ Backup Registers ----------------------------------*/
Ntypedef struct
N{
N  u32  RESERVED0;
N  vu16 DR1;
N  u16  RESERVED1;
N  vu16 DR2;
N  u16  RESERVED2;
N  vu16 DR3;
N  u16  RESERVED3;
N  vu16 DR4;
N  u16  RESERVED4;
N  vu16 DR5;
N  u16  RESERVED5;
N  vu16 DR6;
N  u16  RESERVED6;
N  vu16 DR7;
N  u16  RESERVED7;
N  vu16 DR8;
N  u16  RESERVED8;
N  vu16 DR9;
N  u16  RESERVED9;
N  vu16 DR10;
N  u16  RESERVED10; 
N  vu16 RTCCR;
N  u16  RESERVED11;
N  vu16 CR;
N  u16  RESERVED12;
N  vu16 CSR;
N  u16  RESERVED13[5];
N  vu16 DR11;
N  u16  RESERVED14;
N  vu16 DR12;
N  u16  RESERVED15;
N  vu16 DR13;
N  u16  RESERVED16;
N  vu16 DR14;
N  u16  RESERVED17;
N  vu16 DR15;
N  u16  RESERVED18;
N  vu16 DR16;
N  u16  RESERVED19;
N  vu16 DR17;
N  u16  RESERVED20;
N  vu16 DR18;
N  u16  RESERVED21;
N  vu16 DR19;
N  u16  RESERVED22;
N  vu16 DR20;
N  u16  RESERVED23;
N  vu16 DR21;
N  u16  RESERVED24;
N  vu16 DR22;
N  u16  RESERVED25;
N  vu16 DR23;
N  u16  RESERVED26;
N  vu16 DR24;
N  u16  RESERVED27;
N  vu16 DR25;
N  u16  RESERVED28;
N  vu16 DR26;
N  u16  RESERVED29;
N  vu16 DR27;
N  u16  RESERVED30;
N  vu16 DR28;
N  u16  RESERVED31;
N  vu16 DR29;
N  u16  RESERVED32;
N  vu16 DR30;
N  u16  RESERVED33; 
N  vu16 DR31;
N  u16  RESERVED34;
N  vu16 DR32;
N  u16  RESERVED35;
N  vu16 DR33;
N  u16  RESERVED36;
N  vu16 DR34;
N  u16  RESERVED37;
N  vu16 DR35;
N  u16  RESERVED38;
N  vu16 DR36;
N  u16  RESERVED39;
N  vu16 DR37;
N  u16  RESERVED40;
N  vu16 DR38;
N  u16  RESERVED41;
N  vu16 DR39;
N  u16  RESERVED42;
N  vu16 DR40;
N  u16  RESERVED43;
N  vu16 DR41;
N  u16  RESERVED44;
N  vu16 DR42;
N  u16  RESERVED45;    
N} BKP_TypeDef;
N
N/*------------------------ Controller Area Network ---------------------------*/
Ntypedef struct
N{
N  vu32 TIR;
N  vu32 TDTR;
N  vu32 TDLR;
N  vu32 TDHR;
N} CAN_TxMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 RIR;
N  vu32 RDTR;
N  vu32 RDLR;
N  vu32 RDHR;
N} CAN_FIFOMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 FR1;
N  vu32 FR2;
N} CAN_FilterRegister_TypeDef;
N
Ntypedef struct
N{
N  vu32 MCR;
N  vu32 MSR;
N  vu32 TSR;
N  vu32 RF0R;
N  vu32 RF1R;
N  vu32 IER;
N  vu32 ESR;
N  vu32 BTR;
N  u32  RESERVED0[88];
N  CAN_TxMailBox_TypeDef sTxMailBox[3];
N  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
N  u32  RESERVED1[12];
N  vu32 FMR;
N  vu32 FM1R;
N  u32  RESERVED2;
N  vu32 FS1R;
N  u32  RESERVED3;
N  vu32 FFA1R;
N  u32  RESERVED4;
N  vu32 FA1R;
N  u32  RESERVED5[8];
N  CAN_FilterRegister_TypeDef sFilterRegister[14];
N} CAN_TypeDef;
N
N/*------------------------ CRC calculation unit ------------------------------*/
Ntypedef struct
N{
N  vu32 DR;
N  vu8  IDR;
N  u8   RESERVED0;
N  u16  RESERVED1;
N  vu32 CR;
N} CRC_TypeDef;
N
N
N/*------------------------ Digital to Analog Converter -----------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 SWTRIGR;
N  vu32 DHR12R1;
N  vu32 DHR12L1;
N  vu32 DHR8R1;
N  vu32 DHR12R2;
N  vu32 DHR12L2;
N  vu32 DHR8R2;
N  vu32 DHR12RD;
N  vu32 DHR12LD;
N  vu32 DHR8RD;
N  vu32 DOR1;
N  vu32 DOR2;
N} DAC_TypeDef;
N
N/*------------------------ Debug MCU -----------------------------------------*/
Ntypedef struct
N{
N  vu32 IDCODE;
N  vu32 CR;	
N}DBGMCU_TypeDef;
N
N/*------------------------ DMA Controller ------------------------------------*/
Ntypedef struct
N{
N  vu32 CCR;
N  vu32 CNDTR;
N  vu32 CPAR;
N  vu32 CMAR;
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  vu32 ISR;
N  vu32 IFCR;
N} DMA_TypeDef;
N
N/*------------------------ External Interrupt/Event Controller ---------------*/
Ntypedef struct
N{
N  vu32 IMR;
N  vu32 EMR;
N  vu32 RTSR;
N  vu32 FTSR;
N  vu32 SWIER;
N  vu32 PR;
N} EXTI_TypeDef;
N
N/*------------------------ FLASH and Option Bytes Registers ------------------*/
Ntypedef struct
N{
N  vu32 ACR;
N  vu32 KEYR;
N  vu32 OPTKEYR;
N  vu32 SR;
N  vu32 CR;
N  vu32 AR;
N  vu32 RESERVED;
N  vu32 OBR;
N  vu32 WRPR;
N} FLASH_TypeDef;
N
Ntypedef struct
N{
N  vu16 RDP;
N  vu16 USER;
N  vu16 Data0;
N  vu16 Data1;
N  vu16 WRP0;
N  vu16 WRP1;
N  vu16 WRP2;
N  vu16 WRP3;
N} OB_TypeDef;
N
N/*------------------------ Flexible Static Memory Controller -----------------*/
Ntypedef struct
N{
N  vu32 BTCR[8];   
N} FSMC_Bank1_TypeDef; 
N
Ntypedef struct
N{
N  vu32 BWTR[7];
N} FSMC_Bank1E_TypeDef;
N
Ntypedef struct
N{
N  vu32 PCR2;
N  vu32 SR2;
N  vu32 PMEM2;
N  vu32 PATT2;
N  u32  RESERVED0;   
N  vu32 ECCR2; 
N} FSMC_Bank2_TypeDef;  
N
Ntypedef struct
N{
N  vu32 PCR3;
N  vu32 SR3;
N  vu32 PMEM3;
N  vu32 PATT3;
N  u32  RESERVED0;   
N  vu32 ECCR3; 
N} FSMC_Bank3_TypeDef; 
N
Ntypedef struct
N{
N  vu32 PCR4;
N  vu32 SR4;
N  vu32 PMEM4;
N  vu32 PATT4;
N  vu32 PIO4; 
N} FSMC_Bank4_TypeDef; 
N
N/*------------------------ General Purpose and Alternate Function IO ---------*/
Ntypedef struct
N{
N  vu32 CRL;
N  vu32 CRH;
N  vu32 IDR;
N  vu32 ODR;
N  vu32 BSRR;
N  vu32 BRR;
N  vu32 LCKR;
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  vu32 EVCR;
N  vu32 MAPR;
N  vu32 EXTICR[4];
N} AFIO_TypeDef;
N
N/*------------------------ Inter-integrated Circuit Interface ----------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 OAR1;
N  u16  RESERVED2;
N  vu16 OAR2;
N  u16  RESERVED3;
N  vu16 DR;
N  u16  RESERVED4;
N  vu16 SR1;
N  u16  RESERVED5;
N  vu16 SR2;
N  u16  RESERVED6;
N  vu16 CCR;
N  u16  RESERVED7;
N  vu16 TRISE;
N  u16  RESERVED8;
N} I2C_TypeDef;
N
N/*------------------------ Independent WATCHDOG ------------------------------*/
Ntypedef struct
N{
N  vu32 KR;
N  vu32 PR;
N  vu32 RLR;
N  vu32 SR;
N} IWDG_TypeDef;
N
N/*------------------------ Nested Vectored Interrupt Controller --------------*/
Ntypedef struct
N{
N  vu32 ISER[2];
N  u32  RESERVED0[30];
N  vu32 ICER[2];
N  u32  RSERVED1[30];
N  vu32 ISPR[2];
N  u32  RESERVED2[30];
N  vu32 ICPR[2];
N  u32  RESERVED3[30];
N  vu32 IABR[2];
N  u32  RESERVED4[62];
N  vu32 IPR[15];
N} NVIC_TypeDef;
N
Ntypedef struct
N{
N  vuc32 CPUID;
N  vu32 ICSR;
N  vu32 VTOR;
N  vu32 AIRCR;
N  vu32 SCR;
N  vu32 CCR;
N  vu32 SHPR[3];
N  vu32 SHCSR;
N  vu32 CFSR;
N  vu32 HFSR;
N  vu32 DFSR;
N  vu32 MMFAR;
N  vu32 BFAR;
N  vu32 AFSR;
N} SCB_TypeDef;
N
N/*------------------------ Power Control -------------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CSR;
N} PWR_TypeDef;
N
N/*------------------------ Reset and Clock Control ---------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFGR;
N  vu32 CIR;
N  vu32 APB2RSTR;
N  vu32 APB1RSTR;
N  vu32 AHBENR;
N  vu32 APB2ENR;
N  vu32 APB1ENR;
N  vu32 BDCR;
N  vu32 CSR;
N} RCC_TypeDef;
N
N/*------------------------ Real-Time Clock -----------------------------------*/
Ntypedef struct
N{
N  vu16 CRH;
N  u16  RESERVED0;
N  vu16 CRL;
N  u16  RESERVED1;
N  vu16 PRLH;
N  u16  RESERVED2;
N  vu16 PRLL;
N  u16  RESERVED3;
N  vu16 DIVH;
N  u16  RESERVED4;
N  vu16 DIVL;
N  u16  RESERVED5;
N  vu16 CNTH;
N  u16  RESERVED6;
N  vu16 CNTL;
N  u16  RESERVED7;
N  vu16 ALRH;
N  u16  RESERVED8;
N  vu16 ALRL;
N  u16  RESERVED9;
N} RTC_TypeDef;
N
N/*------------------------ SD host Interface ---------------------------------*/
Ntypedef struct
N{
N  vu32 POWER;
N  vu32 CLKCR;
N  vu32 ARG;
N  vu32 CMD;
N  vuc32 RESPCMD;
N  vuc32 RESP1;
N  vuc32 RESP2;
N  vuc32 RESP3;
N  vuc32 RESP4;
N  vu32 DTIMER;
N  vu32 DLEN;
N  vu32 DCTRL;
N  vuc32 DCOUNT;
N  vuc32 STA;
N  vu32 ICR;
N  vu32 MASK;
N  u32  RESERVED0[2];
N  vuc32 FIFOCNT;
N  u32  RESERVED1[13];
N  vu32 FIFO;
N} SDIO_TypeDef;
N
N/*------------------------ Serial Peripheral Interface -----------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SR;
N  u16  RESERVED2;
N  vu16 DR;
N  u16  RESERVED3;
N  vu16 CRCPR;
N  u16  RESERVED4;
N  vu16 RXCRCR;
N  u16  RESERVED5;
N  vu16 TXCRCR;
N  u16  RESERVED6;
N  vu16 I2SCFGR;
N  u16  RESERVED7;
N  vu16 I2SPR;
N  u16  RESERVED8;  
N} SPI_TypeDef;
N
N/*------------------------ SystemTick ----------------------------------------*/
Ntypedef struct
N{
N  vu32 CTRL;
N  vu32 LOAD;
N  vu32 VAL;
N  vuc32 CALIB;
N} SysTick_TypeDef;
N
N/*------------------------ TIM -----------------------------------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SMCR;
N  u16  RESERVED2;
N  vu16 DIER;
N  u16  RESERVED3;
N  vu16 SR;
N  u16  RESERVED4;
N  vu16 EGR;
N  u16  RESERVED5;
N  vu16 CCMR1;
N  u16  RESERVED6;
N  vu16 CCMR2;
N  u16  RESERVED7;
N  vu16 CCER;
N  u16  RESERVED8;
N  vu16 CNT;
N  u16  RESERVED9;
N  vu16 PSC;
N  u16  RESERVED10;
N  vu16 ARR;
N  u16  RESERVED11;
N  vu16 RCR;
N  u16  RESERVED12;
N  vu16 CCR1;
N  u16  RESERVED13;
N  vu16 CCR2;
N  u16  RESERVED14;
N  vu16 CCR3;
N  u16  RESERVED15;
N  vu16 CCR4;
N  u16  RESERVED16;
N  vu16 BDTR;
N  u16  RESERVED17;
N  vu16 DCR;
N  u16  RESERVED18;
N  vu16 DMAR;
N  u16  RESERVED19;
N} TIM_TypeDef;
N
N/*----------------- Universal Synchronous Asynchronous Receiver Transmitter --*/
Ntypedef struct
N{
N  vu16 SR;
N  u16  RESERVED0;
N  vu16 DR;
N  u16  RESERVED1;
N  vu16 BRR;
N  u16  RESERVED2;
N  vu16 CR1;
N  u16  RESERVED3;
N  vu16 CR2;
N  u16  RESERVED4;
N  vu16 CR3;
N  u16  RESERVED5;
N  vu16 GTPR;
N  u16  RESERVED6;
N} USART_TypeDef;
N
N/*------------------------ Window WATCHDOG -----------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFR;
N  vu32 SR;
N} WWDG_TypeDef;
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Peripheral and SRAM base address in the alias region */
N#define PERIPH_BB_BASE        ((u32)0x42000000)
N#define SRAM_BB_BASE          ((u32)0x22000000)
N
N/* Peripheral and SRAM base address in the bit-band region */
N#define SRAM_BASE             ((u32)0x20000000)
N#define PERIPH_BASE           ((u32)0x40000000)
N
N/* FSMC registers base address */
N#define FSMC_R_BASE           ((u32)0xA0000000)
N
N/* Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN_BASE              (APB1PERIPH_BASE + 0x6400)
N#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N
N#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
N#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
N#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
N#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
N#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
N#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
N
N#define SDIO_BASE             (PERIPH_BASE + 0x18000)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N
N/* Flash registers base address */
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000)
N/* Flash Option Bytes base address */
N#define OB_BASE               ((u32)0x1FFFF800)
N
N/* FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE          ((u32)0xE0042000)
N
N/* System Control Space memory map */
N#define SCS_BASE              ((u32)0xE000E000)
N
N#define SysTick_BASE          (SCS_BASE + 0x0010)
N#define NVIC_BASE             (SCS_BASE + 0x0100)
N#define SCB_BASE              (SCS_BASE + 0x0D00)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/*------------------------ Non Debug Mode ------------------------------------*/
N#ifndef DEBUG
N#ifdef _TIM2
N  #define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#endif /*_TIM2 */
N
N#ifdef _TIM3
N  #define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#endif /*_TIM3 */
N
N#ifdef _TIM4
N  #define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#endif /*_TIM4 */
N
N#ifdef _TIM5
N  #define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#endif /*_TIM5 */
N
N#ifdef _TIM6
N  #define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#endif /*_TIM6 */
N
N#ifdef _TIM7
N  #define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#endif /*_TIM7 */
N
N#ifdef _RTC
N  #define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#endif /*_RTC */
N
N#ifdef _WWDG
N  #define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#endif /*_WWDG */
N
N#ifdef _IWDG
N  #define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#endif /*_IWDG */
N
N#ifdef _SPI2
N  #define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#endif /*_SPI2 */
N
N#ifdef _SPI3
N  #define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#endif /*_SPI3 */
N
N#ifdef _USART2
N  #define USART2              ((USART_TypeDef *) USART2_BASE)
N#endif /*_USART2 */
N
N#ifdef _USART3
N  #define USART3              ((USART_TypeDef *) USART3_BASE)
N#endif /*_USART3 */
N
N#ifdef _UART4
N  #define UART4              ((USART_TypeDef *) UART4_BASE)
N#endif /*_UART4 */
N
N#ifdef _UART5
N  #define UART5              ((USART_TypeDef *) UART5_BASE)
N#endif /*_USART5 */
N
N#ifdef _I2C1
N  #define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#endif /*_I2C1 */
N
N#ifdef _I2C2
N  #define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#endif /*_I2C2 */
N
N#ifdef _CAN
N  #define CAN                 ((CAN_TypeDef *) CAN_BASE)
N#endif /*_CAN */
N
N#ifdef _BKP
N  #define BKP                 ((BKP_TypeDef *) BKP_BASE)
N#endif /*_BKP */
N
N#ifdef _PWR
N  #define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#endif /*_PWR */
N
N#ifdef _DAC
N  #define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#endif /*_DAC */
N
N#ifdef _AFIO
N  #define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
N#endif /*_AFIO */
N
N#ifdef _EXTI
N  #define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#endif /*_EXTI */
N
N#ifdef _GPIOA
N  #define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#endif /*_GPIOA */
N
N#ifdef _GPIOB
N  #define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#endif /*_GPIOB */
N
N#ifdef _GPIOC
N  #define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#endif /*_GPIOC */
N
N#ifdef _GPIOD
N  #define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#endif /*_GPIOD */
N
N#ifdef _GPIOE
N  #define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#endif /*_GPIOE */
N
N#ifdef _GPIOF
N  #define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#endif /*_GPIOF */
N
N#ifdef _GPIOG
N  #define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#endif /*_GPIOG */
N
N#ifdef _ADC1
N  #define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#endif /*_ADC1 */
N
N#ifdef _ADC2
N  #define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#endif /*_ADC2 */
N
N#ifdef _TIM1
N  #define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#endif /*_TIM1 */
N
N#ifdef _SPI1
N  #define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#endif /*_SPI1 */
N
N#ifdef _TIM8
N  #define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#endif /*_TIM8 */
N
N#ifdef _USART1
N  #define USART1              ((USART_TypeDef *) USART1_BASE)
N#endif /*_USART1 */
N
N#ifdef _ADC3
N  #define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#endif /*_ADC3 */
N
N#ifdef _SDIO
N  #define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#endif /*_SDIO */
N
N#ifdef _DMA
N  #define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N  #define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#endif /*_DMA */
N
N#ifdef _DMA1_Channel1
N  #define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#endif /*_DMA1_Channel1 */
N
N#ifdef _DMA1_Channel2
N  #define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#endif /*_DMA1_Channel2 */
N
N#ifdef _DMA1_Channel3
N  #define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#endif /*_DMA1_Channel3 */
N
N#ifdef _DMA1_Channel4
N  #define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#endif /*_DMA1_Channel4 */
N
N#ifdef _DMA1_Channel5
N  #define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#endif /*_DMA1_Channel5 */
N
N#ifdef _DMA1_Channel6
N  #define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#endif /*_DMA1_Channel6 */
N
N#ifdef _DMA1_Channel7
N  #define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#endif /*_DMA1_Channel7 */
N
N#ifdef _DMA2_Channel1
N  #define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#endif /*_DMA2_Channel1 */
N
N#ifdef _DMA2_Channel2
N  #define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#endif /*_DMA2_Channel2 */
N
N#ifdef _DMA2_Channel3
N  #define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#endif /*_DMA2_Channel3 */
N
N#ifdef _DMA2_Channel4
N  #define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#endif /*_DMA2_Channel4 */
N
N#ifdef _DMA2_Channel5
N  #define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#endif /*_DMA2_Channel5 */
N
N#ifdef _RCC
N  #define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#endif /*_RCC */
N
N#ifdef _CRC
N  #define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#endif /*_CRC */
N
N#ifdef _FLASH
N  #define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N  #define OB                  ((OB_TypeDef *) OB_BASE) 
N#endif /*_FLASH */
N
N#ifdef _FSMC
N  #define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
N  #define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
N  #define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
N  #define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
N  #define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#endif /*_FSMC */
N
N#ifdef _DBGMCU
N  #define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#endif /*_DBGMCU */
N
N#ifdef _SysTick
N  #define SysTick             ((SysTick_TypeDef *) SysTick_BASE)
N#endif /*_SysTick */
N
N#ifdef _NVIC
N  #define NVIC                ((NVIC_TypeDef *) NVIC_BASE)
N  #define SCB                 ((SCB_TypeDef *) SCB_BASE)  
N#endif /*_NVIC */
N
N/*------------------------ Debug Mode ----------------------------------------*/
N#else   /* DEBUG */
S#ifdef _TIM2
S  EXT TIM_TypeDef             *TIM2;
S#endif /*_TIM2 */
S
S#ifdef _TIM3
S  EXT TIM_TypeDef             *TIM3;
S#endif /*_TIM3 */
S
S#ifdef _TIM4
S  EXT TIM_TypeDef             *TIM4;
S#endif /*_TIM4 */
S
S#ifdef _TIM5
S  EXT TIM_TypeDef             *TIM5;
S#endif /*_TIM5 */
S
S#ifdef _TIM6
S  EXT TIM_TypeDef             *TIM6;
S#endif /*_TIM6 */
S
S#ifdef _TIM7
S  EXT TIM_TypeDef             *TIM7;
S#endif /*_TIM7 */
S
S#ifdef _RTC
S  EXT RTC_TypeDef             *RTC;
S#endif /*_RTC */
S
S#ifdef _WWDG
S  EXT WWDG_TypeDef            *WWDG;
S#endif /*_WWDG */
S
S#ifdef _IWDG
S  EXT IWDG_TypeDef            *IWDG;
S#endif /*_IWDG */
S
S#ifdef _SPI2
S  EXT SPI_TypeDef             *SPI2;
S#endif /*_SPI2 */
S
S#ifdef _SPI3
S  EXT SPI_TypeDef             *SPI3;
S#endif /*_SPI3 */
S
S#ifdef _USART2
S  EXT USART_TypeDef           *USART2;
S#endif /*_USART2 */
S
S#ifdef _USART3
S  EXT USART_TypeDef           *USART3;
S#endif /*_USART3 */
S
S#ifdef _UART4
S  EXT USART_TypeDef           *UART4;
S#endif /*_UART4 */
S
S#ifdef _UART5
S  EXT USART_TypeDef           *UART5;
S#endif /*_UART5 */
S
S#ifdef _I2C1
S  EXT I2C_TypeDef             *I2C1;
S#endif /*_I2C1 */
S
S#ifdef _I2C2
S  EXT I2C_TypeDef             *I2C2;
S#endif /*_I2C2 */
S
S#ifdef _CAN
S  EXT CAN_TypeDef             *CAN;
S#endif /*_CAN */
S
S#ifdef _BKP
S  EXT BKP_TypeDef             *BKP;
S#endif /*_BKP */
S
S#ifdef _PWR
S  EXT PWR_TypeDef             *PWR;
S#endif /*_PWR */
S
S#ifdef _DAC
S  EXT DAC_TypeDef             *DAC;
S#endif /*_DAC */
S
S#ifdef _AFIO
S  EXT AFIO_TypeDef            *AFIO;
S#endif /*_AFIO */
S
S#ifdef _EXTI
S  EXT EXTI_TypeDef            *EXTI;
S#endif /*_EXTI */
S
S#ifdef _GPIOA
S  EXT GPIO_TypeDef            *GPIOA;
S#endif /*_GPIOA */
S
S#ifdef _GPIOB
S  EXT GPIO_TypeDef            *GPIOB;
S#endif /*_GPIOB */
S
S#ifdef _GPIOC
S  EXT GPIO_TypeDef            *GPIOC;
S#endif /*_GPIOC */
S
S#ifdef _GPIOD
S  EXT GPIO_TypeDef            *GPIOD;
S#endif /*_GPIOD */
S
S#ifdef _GPIOE
S  EXT GPIO_TypeDef            *GPIOE;
S#endif /*_GPIOE */
S
S#ifdef _GPIOF
S  EXT GPIO_TypeDef            *GPIOF;
S#endif /*_GPIOF */
S
S#ifdef _GPIOG
S  EXT GPIO_TypeDef            *GPIOG;
S#endif /*_GPIOG */
S
S#ifdef _ADC1
S  EXT ADC_TypeDef             *ADC1;
S#endif /*_ADC1 */
S
S#ifdef _ADC2
S  EXT ADC_TypeDef             *ADC2;
S#endif /*_ADC2 */
S
S#ifdef _TIM1
S  EXT TIM_TypeDef             *TIM1;
S#endif /*_TIM1 */
S
S#ifdef _SPI1
S  EXT SPI_TypeDef             *SPI1;
S#endif /*_SPI1 */
S
S#ifdef _TIM8
S  EXT TIM_TypeDef             *TIM8;
S#endif /*_TIM8 */
S
S#ifdef _USART1
S  EXT USART_TypeDef           *USART1;
S#endif /*_USART1 */
S
S#ifdef _ADC3
S  EXT ADC_TypeDef             *ADC3;
S#endif /*_ADC3 */
S
S#ifdef _SDIO
S  EXT SDIO_TypeDef            *SDIO;
S#endif /*_SDIO */
S
S#ifdef _DMA
S  EXT DMA_TypeDef             *DMA1;
S  EXT DMA_TypeDef             *DMA2;
S#endif /*_DMA */
S
S#ifdef _DMA1_Channel1
S  EXT DMA_Channel_TypeDef     *DMA1_Channel1;
S#endif /*_DMA1_Channel1 */
S
S#ifdef _DMA1_Channel2
S  EXT DMA_Channel_TypeDef     *DMA1_Channel2;
S#endif /*_DMA1_Channel2 */
S
S#ifdef _DMA1_Channel3
S  EXT DMA_Channel_TypeDef     *DMA1_Channel3;
S#endif /*_DMA1_Channel3 */
S
S#ifdef _DMA1_Channel4
S  EXT DMA_Channel_TypeDef     *DMA1_Channel4;
S#endif /*_DMA1_Channel4 */
S
S#ifdef _DMA1_Channel5
S  EXT DMA_Channel_TypeDef     *DMA1_Channel5;
S#endif /*_DMA1_Channel5 */
S
S#ifdef _DMA1_Channel6
S  EXT DMA_Channel_TypeDef     *DMA1_Channel6;
S#endif /*_DMA1_Channel6 */
S
S#ifdef _DMA1_Channel7
S  EXT DMA_Channel_TypeDef     *DMA1_Channel7;
S#endif /*_DMA1_Channel7 */
S
S#ifdef _DMA2_Channel1
S  EXT DMA_Channel_TypeDef     *DMA2_Channel1;
S#endif /*_DMA2_Channel1 */
S
S#ifdef _DMA2_Channel2
S  EXT DMA_Channel_TypeDef     *DMA2_Channel2;
S#endif /*_DMA2_Channel2 */
S
S#ifdef _DMA2_Channel3
S  EXT DMA_Channel_TypeDef     *DMA2_Channel3;
S#endif /*_DMA2_Channel3 */
S
S#ifdef _DMA2_Channel4
S  EXT DMA_Channel_TypeDef     *DMA2_Channel4;
S#endif /*_DMA2_Channel4 */
S
S#ifdef _DMA2_Channel5
S  EXT DMA_Channel_TypeDef     *DMA2_Channel5;
S#endif /*_DMA2_Channel5 */
S
S#ifdef _RCC
S  EXT RCC_TypeDef             *RCC;
S#endif /*_RCC */
S
S#ifdef _CRC
S  EXT CRC_TypeDef             *CRC;
S#endif /*_CRC */
S
S#ifdef _FLASH
S  EXT FLASH_TypeDef            *FLASH;
S  EXT OB_TypeDef               *OB;  
S#endif /*_FLASH */
S
S#ifdef _FSMC
S  EXT FSMC_Bank1_TypeDef      *FSMC_Bank1;
S  EXT FSMC_Bank1E_TypeDef     *FSMC_Bank1E;
S  EXT FSMC_Bank2_TypeDef      *FSMC_Bank2;
S  EXT FSMC_Bank3_TypeDef      *FSMC_Bank3;
S  EXT FSMC_Bank4_TypeDef      *FSMC_Bank4;
S#endif /*_FSMC */
S
S#ifdef _DBGMCU
S  EXT DBGMCU_TypeDef          *DBGMCU;
S#endif /*_DBGMCU */
S
S#ifdef _SysTick
S  EXT SysTick_TypeDef         *SysTick;
S#endif /*_SysTick */
S
S#ifdef _NVIC
S  EXT NVIC_TypeDef            *NVIC;
S  EXT SCB_TypeDef             *SCB;
S#endif /*_NVIC */
S
N#endif  /* DEBUG */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_MAP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 23 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N
N#ifdef _ADC
N  #include "stm32f10x_adc.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_adc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_adc.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      ADC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_ADC_H
N#define __STM32F10x_ADC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* ADC Init structure definition */
Ntypedef struct
N{
N  u32 ADC_Mode;
N  FunctionalState ADC_ScanConvMode; 
N  FunctionalState ADC_ContinuousConvMode;
N  u32 ADC_ExternalTrigConv;
N  u32 ADC_DataAlign;
N  u8 ADC_NbrOfChannel;
N}ADC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N#define IS_ADC_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC2_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC3_BASE))
X#define IS_ADC_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC2_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC3_BASE))
N                                 
N#define IS_ADC_DMA_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC3_BASE))
X#define IS_ADC_DMA_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC3_BASE))
N
N/* ADC dual mode -------------------------------------------------------------*/
N#define ADC_Mode_Independent                       ((u32)0x00000000)
N#define ADC_Mode_RegInjecSimult                    ((u32)0x00010000)
N#define ADC_Mode_RegSimult_AlterTrig               ((u32)0x00020000)
N#define ADC_Mode_InjecSimult_FastInterl            ((u32)0x00030000)
N#define ADC_Mode_InjecSimult_SlowInterl            ((u32)0x00040000)
N#define ADC_Mode_InjecSimult                       ((u32)0x00050000)
N#define ADC_Mode_RegSimult                         ((u32)0x00060000)
N#define ADC_Mode_FastInterl                        ((u32)0x00070000)
N#define ADC_Mode_SlowInterl                        ((u32)0x00080000)
N#define ADC_Mode_AlterTrig                         ((u32)0x00090000)
N
N#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
N                           ((MODE) == ADC_Mode_RegInjecSimult) || \
N                           ((MODE) == ADC_Mode_RegSimult_AlterTrig) || \
N                           ((MODE) == ADC_Mode_InjecSimult_FastInterl) || \
N                           ((MODE) == ADC_Mode_InjecSimult_SlowInterl) || \
N                           ((MODE) == ADC_Mode_InjecSimult) || \
N                           ((MODE) == ADC_Mode_RegSimult) || \
N                           ((MODE) == ADC_Mode_FastInterl) || \
N                           ((MODE) == ADC_Mode_SlowInterl) || \
N                           ((MODE) == ADC_Mode_AlterTrig))
X#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) ||                            ((MODE) == ADC_Mode_RegInjecSimult) ||                            ((MODE) == ADC_Mode_RegSimult_AlterTrig) ||                            ((MODE) == ADC_Mode_InjecSimult_FastInterl) ||                            ((MODE) == ADC_Mode_InjecSimult_SlowInterl) ||                            ((MODE) == ADC_Mode_InjecSimult) ||                            ((MODE) == ADC_Mode_RegSimult) ||                            ((MODE) == ADC_Mode_FastInterl) ||                            ((MODE) == ADC_Mode_SlowInterl) ||                            ((MODE) == ADC_Mode_AlterTrig))
N
N/* ADC extrenal trigger sources for regular channels conversion --------------*/
N/* for ADC1 and ADC2 */
N#define ADC_ExternalTrigConv_T1_CC1                ((u32)0x00000000)
N#define ADC_ExternalTrigConv_T1_CC2                ((u32)0x00020000)
N#define ADC_ExternalTrigConv_T2_CC2                ((u32)0x00060000)
N#define ADC_ExternalTrigConv_T3_TRGO               ((u32)0x00080000)
N#define ADC_ExternalTrigConv_T4_CC4                ((u32)0x000A0000)
N#define ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO    ((u32)0x000C0000)
N/* for ADC1, ADC2 and ADC3 */
N#define ADC_ExternalTrigConv_T1_CC3                ((u32)0x00040000)
N#define ADC_ExternalTrigConv_None                  ((u32)0x000E0000)
N/* for ADC3 */
N#define ADC_ExternalTrigConv_T3_CC1                ((u32)0x00000000)
N#define ADC_ExternalTrigConv_T2_CC3                ((u32)0x00020000)
N#define ADC_ExternalTrigConv_T8_CC1                ((u32)0x00060000)
N#define ADC_ExternalTrigConv_T8_TRGO               ((u32)0x00080000)
N#define ADC_ExternalTrigConv_T5_CC1                ((u32)0x000A0000)
N#define ADC_ExternalTrigConv_T5_CC3                ((u32)0x000C0000)
N
N#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_None) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
X#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_None) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
N
N/* ADC data align ------------------------------------------------------------*/
N#define ADC_DataAlign_Right                        ((u32)0x00000000)
N#define ADC_DataAlign_Left                         ((u32)0x00000800)
N
N#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
N                                  ((ALIGN) == ADC_DataAlign_Left))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) ||                                   ((ALIGN) == ADC_DataAlign_Left))
N
N/* ADC channels --------------------------------------------------------------*/
N#define ADC_Channel_0                               ((u8)0x00)
N#define ADC_Channel_1                               ((u8)0x01)
N#define ADC_Channel_2                               ((u8)0x02)
N#define ADC_Channel_3                               ((u8)0x03)
N#define ADC_Channel_4                               ((u8)0x04)
N#define ADC_Channel_5                               ((u8)0x05)
N#define ADC_Channel_6                               ((u8)0x06)
N#define ADC_Channel_7                               ((u8)0x07)
N#define ADC_Channel_8                               ((u8)0x08)
N#define ADC_Channel_9                               ((u8)0x09)
N#define ADC_Channel_10                              ((u8)0x0A)
N#define ADC_Channel_11                              ((u8)0x0B)
N#define ADC_Channel_12                              ((u8)0x0C)
N#define ADC_Channel_13                              ((u8)0x0D)
N#define ADC_Channel_14                              ((u8)0x0E)
N#define ADC_Channel_15                              ((u8)0x0F)
N#define ADC_Channel_16                              ((u8)0x10)
N#define ADC_Channel_17                              ((u8)0x11)
N
N#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) || \
N                                 ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) || \
N                                 ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) || \
N                                 ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) || \
N                                 ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) || \
N                                 ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) || \
N                                 ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \
N                                 ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \
N                                 ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) ||                                  ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) ||                                  ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) ||                                  ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) ||                                  ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) ||                                  ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) ||                                  ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) ||                                  ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) ||                                  ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
N
N/* ADC sampling times --------------------------------------------------------*/
N#define ADC_SampleTime_1Cycles5                    ((u8)0x00)
N#define ADC_SampleTime_7Cycles5                    ((u8)0x01)
N#define ADC_SampleTime_13Cycles5                   ((u8)0x02)
N#define ADC_SampleTime_28Cycles5                   ((u8)0x03)
N#define ADC_SampleTime_41Cycles5                   ((u8)0x04)
N#define ADC_SampleTime_55Cycles5                   ((u8)0x05)
N#define ADC_SampleTime_71Cycles5                   ((u8)0x06)
N#define ADC_SampleTime_239Cycles5                  ((u8)0x07)
N
N#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_7Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_13Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_28Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_41Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_55Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_71Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_239Cycles5))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) ||                                   ((TIME) == ADC_SampleTime_7Cycles5) ||                                   ((TIME) == ADC_SampleTime_13Cycles5) ||                                   ((TIME) == ADC_SampleTime_28Cycles5) ||                                   ((TIME) == ADC_SampleTime_41Cycles5) ||                                   ((TIME) == ADC_SampleTime_55Cycles5) ||                                   ((TIME) == ADC_SampleTime_71Cycles5) ||                                   ((TIME) == ADC_SampleTime_239Cycles5))
N
N/* ADC extrenal trigger sources for injected channels conversion -------------*/
N/* For ADC1 and ADC2 */
N#define ADC_ExternalTrigInjecConv_T2_TRGO           ((u32)0x00002000)
N#define ADC_ExternalTrigInjecConv_T2_CC1            ((u32)0x00003000)
N#define ADC_ExternalTrigInjecConv_T3_CC4            ((u32)0x00004000)
N#define ADC_ExternalTrigInjecConv_T4_TRGO           ((u32)0x00005000)
N#define ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4 ((u32)0x00006000)
N/* For ADC1, ADC2 and ADC3 */
N#define ADC_ExternalTrigInjecConv_T1_TRGO           ((u32)0x00000000)
N#define ADC_ExternalTrigInjecConv_T1_CC4            ((u32)0x00001000)
N#define ADC_ExternalTrigInjecConv_None              ((u32)0x00007000)
N/* For ADC3 */
N#define ADC_ExternalTrigInjecConv_T4_CC3            ((u32)0x00002000)
N#define ADC_ExternalTrigInjecConv_T8_CC2            ((u32)0x00003000)
N#define ADC_ExternalTrigInjecConv_T8_CC4            ((u32)0x00004000)
N#define ADC_ExternalTrigInjecConv_T5_TRGO           ((u32)0x00005000)
N#define ADC_ExternalTrigInjecConv_T5_CC4            ((u32)0x00006000)
N
N#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_None) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
X#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_None) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
N
N/* ADC injected channel selection --------------------------------------------*/
N#define ADC_InjectedChannel_1                       ((u8)0x14)
N#define ADC_InjectedChannel_2                       ((u8)0x18)
N#define ADC_InjectedChannel_3                       ((u8)0x1C)
N#define ADC_InjectedChannel_4                       ((u8)0x20)
N
N#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_4))
X#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) ||                                           ((CHANNEL) == ADC_InjectedChannel_2) ||                                           ((CHANNEL) == ADC_InjectedChannel_3) ||                                           ((CHANNEL) == ADC_InjectedChannel_4))
N
N/* ADC analog watchdog selection ---------------------------------------------*/
N#define ADC_AnalogWatchdog_SingleRegEnable         ((u32)0x00800200)
N#define ADC_AnalogWatchdog_SingleInjecEnable       ((u32)0x00400200)
N#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((u32)0x00C00200)
N#define ADC_AnalogWatchdog_AllRegEnable            ((u32)0x00800000)
N#define ADC_AnalogWatchdog_AllInjecEnable          ((u32)0x00400000)
N#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((u32)0x00C00000)
N#define ADC_AnalogWatchdog_None                    ((u32)0x00000000)
N
N#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
X#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_None))
N
N/* ADC interrupts definition -------------------------------------------------*/
N#define ADC_IT_EOC                                 ((u16)0x0220)
N#define ADC_IT_AWD                                 ((u16)0x0140)
N#define ADC_IT_JEOC                                ((u16)0x0480)
N
N#define IS_ADC_IT(IT) ((((IT) & (u16)0xF81F) == 0x00) && ((IT) != 0x00))
N#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
N                           ((IT) == ADC_IT_JEOC))
X#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) ||                            ((IT) == ADC_IT_JEOC))
N
N/* ADC flags definition ------------------------------------------------------*/
N#define ADC_FLAG_AWD                               ((u8)0x01)
N#define ADC_FLAG_EOC                               ((u8)0x02)
N#define ADC_FLAG_JEOC                              ((u8)0x04)
N#define ADC_FLAG_JSTRT                             ((u8)0x08)
N#define ADC_FLAG_STRT                              ((u8)0x10)
N
N#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (u8)0xE0) == 0x00) && ((FLAG) != 0x00))
N#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) || \
N                               ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) || \
N                               ((FLAG) == ADC_FLAG_STRT))
X#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) ||                                ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) ||                                ((FLAG) == ADC_FLAG_STRT))
N
N/* ADC thresholds ------------------------------------------------------------*/
N#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
N
N/* ADC injected offset -------------------------------------------------------*/
N#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
N
N/* ADC injected length -------------------------------------------------------*/
N#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
N
N/* ADC injected rank ---------------------------------------------------------*/
N#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
N
N/* ADC regular length --------------------------------------------------------*/
N#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
N
N/* ADC regular rank ----------------------------------------------------------*/
N#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
N
N/* ADC regular discontinuous mode number -------------------------------------*/
N#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid ADC_DeInit(ADC_TypeDef* ADCx);
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState);
Nvoid ADC_ResetCalibration(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);
Nvoid ADC_StartCalibration(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);
Nvoid ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
NFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
Nvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number);
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime);
Nvoid ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nu16 ADC_GetConversionValue(ADC_TypeDef* ADCx);
Nu32 ADC_GetDualModeConversionValue(void);
Nvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv);
Nvoid ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
NFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
Nvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime);
Nvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length);
Nvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset);
Nu16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel);
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog);
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold, u16 LowThreshold);
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel);
Nvoid ADC_TempSensorVrefintCmd(FunctionalState NewState);
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG);
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG);
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT);
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT);
N
N#endif /*__STM32F10x_ADC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 26 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_ADC */
N
N#ifdef _BKP
N  #include "stm32f10x_bkp.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_bkp.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_bkp.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      BKP firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_BKP_H
N#define __STM32F10x_BKP_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Tamper Pin active level */
N#define BKP_TamperPinLevel_High           ((u16)0x0000)
N#define BKP_TamperPinLevel_Low            ((u16)0x0001)
N
N#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) || \
N                                        ((LEVEL) == BKP_TamperPinLevel_Low))
X#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) ||                                         ((LEVEL) == BKP_TamperPinLevel_Low))
N
N/* RTC output source to output on the Tamper pin */
N#define BKP_RTCOutputSource_None          ((u16)0x0000)
N#define BKP_RTCOutputSource_CalibClock    ((u16)0x0080)
N#define BKP_RTCOutputSource_Alarm         ((u16)0x0100)
N#define BKP_RTCOutputSource_Second        ((u16)0x0300)
N
N#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_CalibClock) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_Alarm) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_Second))
X#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) ||                                           ((SOURCE) == BKP_RTCOutputSource_CalibClock) ||                                           ((SOURCE) == BKP_RTCOutputSource_Alarm) ||                                           ((SOURCE) == BKP_RTCOutputSource_Second))
N
N/* Data Backup Register */
N#define BKP_DR1                           ((u16)0x0004)
N#define BKP_DR2                           ((u16)0x0008)
N#define BKP_DR3                           ((u16)0x000C)
N#define BKP_DR4                           ((u16)0x0010)
N#define BKP_DR5                           ((u16)0x0014)
N#define BKP_DR6                           ((u16)0x0018)
N#define BKP_DR7                           ((u16)0x001C)
N#define BKP_DR8                           ((u16)0x0020)
N#define BKP_DR9                           ((u16)0x0024)
N#define BKP_DR10                          ((u16)0x0028)
N#define BKP_DR11                          ((u16)0x0040)
N#define BKP_DR12                          ((u16)0x0044)
N#define BKP_DR13                          ((u16)0x0048)
N#define BKP_DR14                          ((u16)0x004C)
N#define BKP_DR15                          ((u16)0x0050)
N#define BKP_DR16                          ((u16)0x0054)
N#define BKP_DR17                          ((u16)0x0058)
N#define BKP_DR18                          ((u16)0x005C)
N#define BKP_DR19                          ((u16)0x0060)
N#define BKP_DR20                          ((u16)0x0064)
N#define BKP_DR21                          ((u16)0x0068)
N#define BKP_DR22                          ((u16)0x006C)
N#define BKP_DR23                          ((u16)0x0070)
N#define BKP_DR24                          ((u16)0x0074)
N#define BKP_DR25                          ((u16)0x0078)
N#define BKP_DR26                          ((u16)0x007C)
N#define BKP_DR27                          ((u16)0x0080)
N#define BKP_DR28                          ((u16)0x0084)
N#define BKP_DR29                          ((u16)0x0088)
N#define BKP_DR30                          ((u16)0x008C)
N#define BKP_DR31                          ((u16)0x0090)
N#define BKP_DR32                          ((u16)0x0094)
N#define BKP_DR33                          ((u16)0x0098)
N#define BKP_DR34                          ((u16)0x009C)
N#define BKP_DR35                          ((u16)0x00A0)
N#define BKP_DR36                          ((u16)0x00A4)
N#define BKP_DR37                          ((u16)0x00A8)
N#define BKP_DR38                          ((u16)0x00AC)
N#define BKP_DR39                          ((u16)0x00B0)
N#define BKP_DR40                          ((u16)0x00B4)
N#define BKP_DR41                          ((u16)0x00B8)
N#define BKP_DR42                          ((u16)0x00BC)
N
N#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  || \
N                       ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  || \
N                       ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  || \
N                       ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) || \
N                       ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) || \
N                       ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) || \
N                       ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) || \
N                       ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) || \
N                       ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) || \
N                       ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) || \
N                       ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) || \
N                       ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) || \
N                       ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) || \
N                       ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
X#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  ||                        ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  ||                        ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  ||                        ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) ||                        ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) ||                        ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) ||                        ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) ||                        ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) ||                        ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) ||                        ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) ||                        ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) ||                        ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) ||                        ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) ||                        ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
N
N#define IS_BKP_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x7F)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid BKP_DeInit(void);
Nvoid BKP_TamperPinLevelConfig(u16 BKP_TamperPinLevel);
Nvoid BKP_TamperPinCmd(FunctionalState NewState);
Nvoid BKP_ITConfig(FunctionalState NewState);
Nvoid BKP_RTCOutputConfig(u16 BKP_RTCOutputSource);
Nvoid BKP_SetRTCCalibrationValue(u8 CalibrationValue);
Nvoid BKP_WriteBackupRegister(u16 BKP_DR, u16 Data);
Nu16 BKP_ReadBackupRegister(u16 BKP_DR);
NFlagStatus BKP_GetFlagStatus(void);
Nvoid BKP_ClearFlag(void);
NITStatus BKP_GetITStatus(void);
Nvoid BKP_ClearITPendingBit(void);
N
N#endif /* __STM32F10x_BKP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 30 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_BKP */
N
N#ifdef _CAN
N  #include "stm32f10x_can.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_can.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_can.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      CAN firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CAN_H
N#define __STM32F10x_CAN_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* CAN init structure definition */
Ntypedef struct
N{
N  FunctionalState CAN_TTCM;
N  FunctionalState CAN_ABOM;
N  FunctionalState CAN_AWUM;
N  FunctionalState CAN_NART;
N  FunctionalState CAN_RFLM;
N  FunctionalState CAN_TXFP;
N  u8 CAN_Mode;
N  u8 CAN_SJW;
N  u8 CAN_BS1;
N  u8 CAN_BS2;
N  u16 CAN_Prescaler;
N} CAN_InitTypeDef;
N
N/* CAN filter init structure definition */
Ntypedef struct
N{
N  u8 CAN_FilterNumber;
N  u8 CAN_FilterMode;
N  u8 CAN_FilterScale;
N  u16 CAN_FilterIdHigh;
N  u16 CAN_FilterIdLow;
N  u16 CAN_FilterMaskIdHigh;
N  u16 CAN_FilterMaskIdLow;
N  u16 CAN_FilterFIFOAssignment;
N  FunctionalState CAN_FilterActivation;
N} CAN_FilterInitTypeDef;
N
N/* CAN Tx message structure definition */
Ntypedef struct
N{
N  u32 StdId;
N  u32 ExtId;
N  u8 IDE;
N  u8 RTR;
N  u8 DLC;
N  u8 Data[8];
N} CanTxMsg;
N
N/* CAN Rx message structure definition */
Ntypedef struct
N{
N  u32 StdId;
N  u32 ExtId;
N  u8 IDE;
N  u8 RTR;
N  u8 DLC;
N  u8 Data[8];
N  u8 FMI;
N} CanRxMsg;
N
N/* Exported constants --------------------------------------------------------*/
N
N/* CAN sleep constants */
N#define CANINITFAILED              ((u8)0x00) /* CAN initialization failed */
N#define CANINITOK                  ((u8)0x01) /* CAN initialization failed */
N
N/* CAN operating mode */
N#define CAN_Mode_Normal             ((u8)0x00)  /* normal mode */
N#define CAN_Mode_LoopBack           ((u8)0x01)  /* loopback mode */
N#define CAN_Mode_Silent             ((u8)0x02)  /* silent mode */
N#define CAN_Mode_Silent_LoopBack    ((u8)0x03)  /* loopback combined with silent mode */
N
N#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || ((MODE) == CAN_Mode_LoopBack)|| \
N                           ((MODE) == CAN_Mode_Silent) || ((MODE) == CAN_Mode_Silent_LoopBack))
X#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || ((MODE) == CAN_Mode_LoopBack)||                            ((MODE) == CAN_Mode_Silent) || ((MODE) == CAN_Mode_Silent_LoopBack))
N
N/* CAN synchronisation jump width */
N#define CAN_SJW_1tq                 ((u8)0x00)  /* 1 time quantum */
N#define CAN_SJW_2tq                 ((u8)0x01)  /* 2 time quantum */
N#define CAN_SJW_3tq                 ((u8)0x02)  /* 3 time quantum */
N#define CAN_SJW_4tq                 ((u8)0x03)  /* 4 time quantum */
N
N#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \
N                         ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
X#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)||                          ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
N
N/* time quantum in bit segment 1 */
N#define CAN_BS1_1tq                 ((u8)0x00)  /* 1 time quantum */
N#define CAN_BS1_2tq                 ((u8)0x01)  /* 2 time quantum */
N#define CAN_BS1_3tq                 ((u8)0x02)  /* 3 time quantum */
N#define CAN_BS1_4tq                 ((u8)0x03)  /* 4 time quantum */
N#define CAN_BS1_5tq                 ((u8)0x04)  /* 5 time quantum */
N#define CAN_BS1_6tq                 ((u8)0x05)  /* 6 time quantum */
N#define CAN_BS1_7tq                 ((u8)0x06)  /* 7 time quantum */
N#define CAN_BS1_8tq                 ((u8)0x07)  /* 8 time quantum */
N#define CAN_BS1_9tq                 ((u8)0x08)  /* 9 time quantum */
N#define CAN_BS1_10tq                ((u8)0x09)  /* 10 time quantum */
N#define CAN_BS1_11tq                ((u8)0x0A)  /* 11 time quantum */
N#define CAN_BS1_12tq                ((u8)0x0B)  /* 12 time quantum */
N#define CAN_BS1_13tq                ((u8)0x0C)  /* 13 time quantum */
N#define CAN_BS1_14tq                ((u8)0x0D)  /* 14 time quantum */
N#define CAN_BS1_15tq                ((u8)0x0E)  /* 15 time quantum */
N#define CAN_BS1_16tq                ((u8)0x0F)  /* 16 time quantum */
N
N#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16tq)
N
N/* time quantum in bit segment 2 */
N#define CAN_BS2_1tq                 ((u8)0x00)  /* 1 time quantum */
N#define CAN_BS2_2tq                 ((u8)0x01)  /* 2 time quantum */
N#define CAN_BS2_3tq                 ((u8)0x02)  /* 3 time quantum */
N#define CAN_BS2_4tq                 ((u8)0x03)  /* 4 time quantum */
N#define CAN_BS2_5tq                 ((u8)0x04)  /* 5 time quantum */
N#define CAN_BS2_6tq                 ((u8)0x05)  /* 6 time quantum */
N#define CAN_BS2_7tq                 ((u8)0x06)  /* 7 time quantum */
N#define CAN_BS2_8tq                 ((u8)0x07)  /* 8 time quantum */
N
N#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8tq)
N
N/* CAN clock prescaler */
N#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
N
N/* CAN filter number */
N#define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 13)
N
N/* CAN filter mode */
N#define CAN_FilterMode_IdMask       ((u8)0x00)  /* id/mask mode */
N#define CAN_FilterMode_IdList       ((u8)0x01)  /* identifier list mode */
N
N#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \
N                                  ((MODE) == CAN_FilterMode_IdList))
X#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) ||                                   ((MODE) == CAN_FilterMode_IdList))
N
N/* CAN filter scale */
N#define CAN_FilterScale_16bit       ((u8)0x00) /* 16-bit filter scale */
N#define CAN_FilterScale_32bit       ((u8)0x01) /* 2-bit filter scale */
N
N#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \
N                                    ((SCALE) == CAN_FilterScale_32bit))
X#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) ||                                     ((SCALE) == CAN_FilterScale_32bit))
N
N/* CAN filter FIFO assignation */
N#define CAN_FilterFIFO0             ((u8)0x00)  /* Filter FIFO 0 assignment for filter x */
N#define CAN_FilterFIFO1             ((u8)0x01)  /* Filter FIFO 1 assignment for filter x */
N
N#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \
N                                  ((FIFO) == CAN_FilterFIFO1))
X#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) ||                                   ((FIFO) == CAN_FilterFIFO1))
N
N/* CAN Tx */
N#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((u8)0x02))
N#define IS_CAN_STDID(STDID)   ((STDID) <= ((u32)0x7FF))
N#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((u32)0x1FFFFFFF))
N#define IS_CAN_DLC(DLC)       ((DLC) <= ((u8)0x08))
N
N/* CAN identifier type */
N#define CAN_ID_STD                 ((u32)0x00000000)  /* Standard Id */
N#define CAN_ID_EXT                 ((u32)0x00000004)  /* Extended Id */
N
N#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_ID_STD) || ((IDTYPE) == CAN_ID_EXT))
N
N/* CAN remote transmission request */
N#define CAN_RTR_DATA                ((u32)0x00000000)  /* Data frame */
N#define CAN_RTR_REMOTE              ((u32)0x00000002)  /* Remote frame */
N
N#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_DATA) || ((RTR) == CAN_RTR_REMOTE))
N
N/* CAN transmit constants */
N#define CANTXFAILED                 ((u8)0x00) /* CAN transmission failed */
N#define CANTXOK                     ((u8)0x01) /* CAN transmission succeeded */
N#define CANTXPENDING                ((u8)0x02) /* CAN transmission pending */
N#define CAN_NO_MB                   ((u8)0x04) /* CAN cell did not provide an empty mailbox */
N
N/* CAN receive FIFO number constants */
N#define CAN_FIFO0                 ((u8)0x00) /* CAN FIFO0 used to receive */
N#define CAN_FIFO1                 ((u8)0x01) /* CAN FIFO1 used to receive */
N
N#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
N
N/* CAN sleep constants */
N#define CANSLEEPFAILED              ((u8)0x00) /* CAN did not enter the sleep mode */
N#define CANSLEEPOK                  ((u8)0x01) /* CAN entered the sleep mode */
N
N/* CAN wake up constants */
N#define CANWAKEUPFAILED             ((u8)0x00) /* CAN did not leave the sleep mode */
N#define CANWAKEUPOK                 ((u8)0x01) /* CAN leaved the sleep mode */
N
N/* CAN flags */
N#define CAN_FLAG_EWG                ((u32)0x00000001) /* Error Warning Flag */
N#define CAN_FLAG_EPV                ((u32)0x00000002) /* Error Passive Flag */
N#define CAN_FLAG_BOF                ((u32)0x00000004) /* Bus-Off Flag */
N
N#define IS_CAN_FLAG(FLAG) (((FLAG) == CAN_FLAG_EWG) || ((FLAG) == CAN_FLAG_EPV) ||\
N                           ((FLAG) == CAN_FLAG_BOF))
X#define IS_CAN_FLAG(FLAG) (((FLAG) == CAN_FLAG_EWG) || ((FLAG) == CAN_FLAG_EPV) ||                           ((FLAG) == CAN_FLAG_BOF))
N
N/* CAN interrupts */
N#define CAN_IT_RQCP0                ((u32)0x00000005) /* Request completed mailbox 0 */
N#define CAN_IT_RQCP1                ((u32)0x00000006) /* Request completed mailbox 1 */
N#define CAN_IT_RQCP2                ((u32)0x00000007) /* Request completed mailbox 2 */
N#define CAN_IT_TME                  ((u32)0x00000001) /* Transmit mailbox empty */
N#define CAN_IT_FMP0                 ((u32)0x00000002) /* FIFO 0 message pending */
N#define CAN_IT_FF0                  ((u32)0x00000004) /* FIFO 0 full */
N#define CAN_IT_FOV0                 ((u32)0x00000008) /* FIFO 0 overrun */
N#define CAN_IT_FMP1                 ((u32)0x00000010) /* FIFO 1 message pending */
N#define CAN_IT_FF1                  ((u32)0x00000020) /* FIFO 1 full */
N#define CAN_IT_FOV1                 ((u32)0x00000040) /* FIFO 1 overrun */
N#define CAN_IT_EWG                  ((u32)0x00000100) /* Error warning */
N#define CAN_IT_EPV                  ((u32)0x00000200) /* Error passive */
N#define CAN_IT_BOF                  ((u32)0x00000400) /* Bus-off */
N#define CAN_IT_LEC                  ((u32)0x00000800) /* Last error code */
N#define CAN_IT_ERR                  ((u32)0x00008000) /* Error */
N#define CAN_IT_WKU                  ((u32)0x00010000) /* Wake-up */
N#define CAN_IT_SLK                  ((u32)0x00020000) /* Sleep */
N
N#define IS_CAN_ITConfig(IT) (((IT) == CAN_IT_TME)   || ((IT) == CAN_IT_FMP0)  ||\
N                             ((IT) == CAN_IT_FF0)   || ((IT) == CAN_IT_FOV0)  ||\
N                             ((IT) == CAN_IT_FMP1)  || ((IT) == CAN_IT_FF1)   ||\
N                             ((IT) == CAN_IT_FOV1)  || ((IT) == CAN_IT_EWG)   ||\
N                             ((IT) == CAN_IT_EPV)   || ((IT) == CAN_IT_BOF)   ||\
N                             ((IT) == CAN_IT_LEC)   || ((IT) == CAN_IT_ERR)   ||\
N                             ((IT) == CAN_IT_WKU)   || ((IT) == CAN_IT_SLK))
X#define IS_CAN_ITConfig(IT) (((IT) == CAN_IT_TME)   || ((IT) == CAN_IT_FMP0)  ||                             ((IT) == CAN_IT_FF0)   || ((IT) == CAN_IT_FOV0)  ||                             ((IT) == CAN_IT_FMP1)  || ((IT) == CAN_IT_FF1)   ||                             ((IT) == CAN_IT_FOV1)  || ((IT) == CAN_IT_EWG)   ||                             ((IT) == CAN_IT_EPV)   || ((IT) == CAN_IT_BOF)   ||                             ((IT) == CAN_IT_LEC)   || ((IT) == CAN_IT_ERR)   ||                             ((IT) == CAN_IT_WKU)   || ((IT) == CAN_IT_SLK))
N
N#define IS_CAN_ITStatus(IT) (((IT) == CAN_IT_RQCP0)  || ((IT) == CAN_IT_RQCP1)  ||\
N                             ((IT) == CAN_IT_RQCP2)  || ((IT) == CAN_IT_FF0)    ||\
N                             ((IT) == CAN_IT_FOV0)   || ((IT) == CAN_IT_FF1)    ||\
N                             ((IT) == CAN_IT_FOV1)   || ((IT) == CAN_IT_EWG)    ||\
N                             ((IT) == CAN_IT_EPV)    || ((IT) == CAN_IT_BOF)    ||\
N                             ((IT) == CAN_IT_WKU)    || ((IT) == CAN_IT_SLK))
X#define IS_CAN_ITStatus(IT) (((IT) == CAN_IT_RQCP0)  || ((IT) == CAN_IT_RQCP1)  ||                             ((IT) == CAN_IT_RQCP2)  || ((IT) == CAN_IT_FF0)    ||                             ((IT) == CAN_IT_FOV0)   || ((IT) == CAN_IT_FF1)    ||                             ((IT) == CAN_IT_FOV1)   || ((IT) == CAN_IT_EWG)    ||                             ((IT) == CAN_IT_EPV)    || ((IT) == CAN_IT_BOF)    ||                             ((IT) == CAN_IT_WKU)    || ((IT) == CAN_IT_SLK))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported function protypes ----------------------------------------------- */
Nvoid CAN_DeInit(void);
Nu8 CAN_Init(CAN_InitTypeDef* CAN_InitStruct);
Nvoid CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);
Nvoid CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);
Nvoid CAN_ITConfig(u32 CAN_IT, FunctionalState NewState);
Nu8 CAN_Transmit(CanTxMsg* TxMessage);
Nu8 CAN_TransmitStatus(u8 TransmitMailbox);
Nvoid CAN_CancelTransmit(u8 Mailbox);
Nvoid CAN_FIFORelease(u8 FIFONumber);
Nu8 CAN_MessagePending(u8 FIFONumber);
Nvoid CAN_Receive(u8 FIFONumber, CanRxMsg* RxMessage);
Nu8 CAN_Sleep(void);
Nu8 CAN_WakeUp(void);
NFlagStatus CAN_GetFlagStatus(u32 CAN_FLAG);
Nvoid CAN_ClearFlag(u32 CAN_FLAG);
NITStatus CAN_GetITStatus(u32 CAN_IT);
Nvoid CAN_ClearITPendingBit(u32 CAN_IT);
N
N#endif /* __STM32F10x_CAN_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 34 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_CAN */
N
N#ifdef _CRC
N  #include "stm32f10x_crc.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_crc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_crc.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      CRC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CRC_H
N#define __STM32F10x_CRC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid CRC_ResetDR(void);
Nu32 CRC_CalcCRC(u32 Data);
Nu32 CRC_CalcBlockCRC(u32 pBuffer[], u32 BufferLength);
Nu32 CRC_GetCRC(void);
Nvoid CRC_SetIDRegister(u8 IDValue);
Nu8 CRC_GetIDRegister(void);
N
N#endif /* __STM32F10x_CRC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 38 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_CRC */
N
N#ifdef _DAC
N  #include "stm32f10x_dac.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_dac.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_dac.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      DAC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_DAC_H
N#define __STM32F10x_DAC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* DAC Init structure definition */
Ntypedef struct
N{
N  u32 DAC_Trigger;
N  u32 DAC_WaveGeneration;
N  u32 DAC_LFSRUnmask_TriangleAmplitude;
N  u32 DAC_OutputBuffer; 
N}DAC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* DAC trigger selection */
N#define DAC_Trigger_None                   ((u32)0x00000000)
N#define DAC_Trigger_T6_TRGO                ((u32)0x00000004)
N#define DAC_Trigger_T8_TRGO                ((u32)0x0000000C)
N#define DAC_Trigger_T7_TRGO                ((u32)0x00000014)
N#define DAC_Trigger_T5_TRGO                ((u32)0x0000001C)
N#define DAC_Trigger_T2_TRGO                ((u32)0x00000024)
N#define DAC_Trigger_T4_TRGO                ((u32)0x0000002C)
N#define DAC_Trigger_Ext_IT9                ((u32)0x00000034)
N#define DAC_Trigger_Software               ((u32)0x0000003C)
N
N#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
N                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T8_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
N                                 ((TRIGGER) == DAC_Trigger_Software))
X#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) ||                                  ((TRIGGER) == DAC_Trigger_T6_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T8_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T7_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T5_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T2_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T4_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_Ext_IT9) ||                                  ((TRIGGER) == DAC_Trigger_Software))
N
N/* DAC wave generation */
N#define DAC_WaveGeneration_None            ((u32)0x00000000)
N#define DAC_WaveGeneration_Noise           ((u32)0x00000040)
N#define DAC_WaveGeneration_Triangle        ((u32)0x00000080)
N
N#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
N                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
N                                    ((WAVE) == DAC_WaveGeneration_Triangle))
X#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) ||                                     ((WAVE) == DAC_WaveGeneration_Noise) ||                                     ((WAVE) == DAC_WaveGeneration_Triangle))
N
N/* DAC noise wave generation mask / triangle wave generation max amplitude */
N#define DAC_LFSRUnmask_Bit0                ((u32)0x00000000)
N#define DAC_LFSRUnmask_Bits1_0             ((u32)0x00000100)
N#define DAC_LFSRUnmask_Bits2_0             ((u32)0x00000200)
N#define DAC_LFSRUnmask_Bits3_0             ((u32)0x00000300)
N#define DAC_LFSRUnmask_Bits4_0             ((u32)0x00000400)
N#define DAC_LFSRUnmask_Bits5_0             ((u32)0x00000500)
N#define DAC_LFSRUnmask_Bits6_0             ((u32)0x00000600)
N#define DAC_LFSRUnmask_Bits7_0             ((u32)0x00000700)
N#define DAC_LFSRUnmask_Bits8_0             ((u32)0x00000800)
N#define DAC_LFSRUnmask_Bits9_0             ((u32)0x00000900)
N#define DAC_LFSRUnmask_Bits10_0            ((u32)0x00000A00)
N#define DAC_LFSRUnmask_Bits11_0            ((u32)0x00000B00)
N
N#define DAC_TriangleAmplitude_1            ((u32)0x00000000)
N#define DAC_TriangleAmplitude_3            ((u32)0x00000100)
N#define DAC_TriangleAmplitude_7            ((u32)0x00000200)
N#define DAC_TriangleAmplitude_15           ((u32)0x00000300)
N#define DAC_TriangleAmplitude_31           ((u32)0x00000400)
N#define DAC_TriangleAmplitude_63           ((u32)0x00000500)
N#define DAC_TriangleAmplitude_127          ((u32)0x00000600)
N#define DAC_TriangleAmplitude_255          ((u32)0x00000700)
N#define DAC_TriangleAmplitude_511          ((u32)0x00000800)
N#define DAC_TriangleAmplitude_1023         ((u32)0x00000900)
N#define DAC_TriangleAmplitude_2047         ((u32)0x00000A00)
N#define DAC_TriangleAmplitude_4095         ((u32)0x00000B00)
N
N#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
X#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits1_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits2_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits3_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits4_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits5_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits6_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits7_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits8_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits9_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits10_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits11_0) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1) ||                                                       ((VALUE) == DAC_TriangleAmplitude_3) ||                                                       ((VALUE) == DAC_TriangleAmplitude_7) ||                                                       ((VALUE) == DAC_TriangleAmplitude_15) ||                                                       ((VALUE) == DAC_TriangleAmplitude_31) ||                                                       ((VALUE) == DAC_TriangleAmplitude_63) ||                                                       ((VALUE) == DAC_TriangleAmplitude_127) ||                                                       ((VALUE) == DAC_TriangleAmplitude_255) ||                                                       ((VALUE) == DAC_TriangleAmplitude_511) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1023) ||                                                       ((VALUE) == DAC_TriangleAmplitude_2047) ||                                                       ((VALUE) == DAC_TriangleAmplitude_4095))
N
N/* DAC output buffer */
N#define DAC_OutputBuffer_Enable            ((u32)0x00000000)
N#define DAC_OutputBuffer_Disable           ((u32)0x00000002)
N
N#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
N                                           ((STATE) == DAC_OutputBuffer_Disable))
X#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) ||                                            ((STATE) == DAC_OutputBuffer_Disable))
N
N/* DAC Channel selection */
N#define DAC_Channel_1                      ((u32)0x00000000)
N#define DAC_Channel_2                      ((u32)0x00000010)
N
N#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
N                                 ((CHANNEL) == DAC_Channel_2))
X#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) ||                                  ((CHANNEL) == DAC_Channel_2))
N
N/* DAC data alignement */
N#define DAC_Align_12b_R                    ((u32)0x00000000)
N#define DAC_Align_12b_L                    ((u32)0x00000004)
N#define DAC_Align_8b_R                     ((u32)0x00000008)
N
N#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
N                             ((ALIGN) == DAC_Align_12b_L) || \
N                             ((ALIGN) == DAC_Align_8b_R))
X#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) ||                              ((ALIGN) == DAC_Align_12b_L) ||                              ((ALIGN) == DAC_Align_8b_R))
N
N/* DAC wave generation */
N#define DAC_Wave_Noise                     ((u32)0x00000040)
N#define DAC_Wave_Triangle                  ((u32)0x00000080)
N
N#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
N                           ((WAVE) == DAC_Wave_Triangle))
X#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) ||                            ((WAVE) == DAC_Wave_Triangle))
N
N/* DAC data ------------------------------------------------------------------*/
N#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0) 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
Nvoid DAC_DeInit(void);
Nvoid DAC_Init(u32 DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_Cmd(u32 DAC_Channel, FunctionalState NewState);
Nvoid DAC_DMACmd(u32 DAC_Channel, FunctionalState NewState);
Nvoid DAC_SoftwareTriggerCmd(u32 DAC_Channel, FunctionalState NewState);
Nvoid DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
Nvoid DAC_WaveGenerationCmd(u32 DAC_Channel, u32 DAC_Wave, FunctionalState NewState);
Nvoid DAC_SetChannel1Data(u32 DAC_Align, u16 Data);
Nvoid DAC_SetChannel2Data(u32 DAC_Align, u16 Data);
Nvoid DAC_SetDualChannelData(u32 DAC_Align, u16 Data2, u16 Data1);
Nu16 DAC_GetDataOutputValue(u32 DAC_Channel);
N
N#endif /*__STM32F10x_DAC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 42 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_DAC */
N
N#ifdef _DBGMCU
N  #include "stm32f10x_dbgmcu.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_dbgmcu.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_dbgmcu.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      DBGMCU firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_DBGMCU_H
N#define __STM32F10x_DBGMCU_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N#define DBGMCU_SLEEP                 ((u32)0x00000001)
N#define DBGMCU_STOP                  ((u32)0x00000002)
N#define DBGMCU_STANDBY               ((u32)0x00000004)
N#define DBGMCU_IWDG_STOP             ((u32)0x00000100)
N#define DBGMCU_WWDG_STOP             ((u32)0x00000200)
N#define DBGMCU_TIM1_STOP             ((u32)0x00000400)
N#define DBGMCU_TIM2_STOP             ((u32)0x00000800)
N#define DBGMCU_TIM3_STOP             ((u32)0x00001000)
N#define DBGMCU_TIM4_STOP             ((u32)0x00002000)
N#define DBGMCU_CAN_STOP              ((u32)0x00004000)
N#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((u32)0x00008000)
N#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((u32)0x00010000)
N#define DBGMCU_TIM5_STOP             ((u32)0x00020000)
N#define DBGMCU_TIM6_STOP             ((u32)0x00040000)
N#define DBGMCU_TIM7_STOP             ((u32)0x00080000)
N#define DBGMCU_TIM8_STOP             ((u32)0x00100000)
N                                           
N#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0xFFE000F8) == 0x00) && ((PERIPH) != 0x00))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nu32 DBGMCU_GetREVID(void);
Nu32 DBGMCU_GetDEVID(void);
Nvoid DBGMCU_Config(u32 DBGMCU_Periph, FunctionalState NewState);
N
N#endif /* __STM32F10x_DBGMCU_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
N
N
L 46 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_DBGMCU */
N
N#ifdef _DMA
N  #include "stm32f10x_dma.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_dma.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_dma.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      DMA firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_DMA_H
N#define __STM32F10x_DMA_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* DMA Init structure definition */
Ntypedef struct
N{
N  u32 DMA_PeripheralBaseAddr;
N  u32 DMA_MemoryBaseAddr;
N  u32 DMA_DIR;
N  u32 DMA_BufferSize;
N  u32 DMA_PeripheralInc;
N  u32 DMA_MemoryInc;
N  u32 DMA_PeripheralDataSize;
N  u32 DMA_MemoryDataSize;
N  u32 DMA_Mode;
N  u32 DMA_Priority;
N  u32 DMA_M2M;
N}DMA_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N#define IS_DMA_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == DMA1_Channel1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == DMA1_Channel2_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA1_Channel3_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA1_Channel4_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA1_Channel5_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA1_Channel6_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA1_Channel7_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA2_Channel1_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA2_Channel2_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA2_Channel3_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA2_Channel4_BASE)  || \
N                                   ((*(u32*)&(PERIPH)) == DMA2_Channel5_BASE))
X#define IS_DMA_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == DMA1_Channel1_BASE) ||                                    ((*(u32*)&(PERIPH)) == DMA1_Channel2_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA1_Channel3_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA1_Channel4_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA1_Channel5_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA1_Channel6_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA1_Channel7_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA2_Channel1_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA2_Channel2_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA2_Channel3_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA2_Channel4_BASE)  ||                                    ((*(u32*)&(PERIPH)) == DMA2_Channel5_BASE))
N
N/* DMA data transfer direction -----------------------------------------------*/
N#define DMA_DIR_PeripheralDST              ((u32)0x00000010)
N#define DMA_DIR_PeripheralSRC              ((u32)0x00000000)
N
N#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \
N                         ((DIR) == DMA_DIR_PeripheralSRC))
X#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) ||                          ((DIR) == DMA_DIR_PeripheralSRC))
N
N/* DMA peripheral incremented mode -------------------------------------------*/
N#define DMA_PeripheralInc_Enable           ((u32)0x00000040)
N#define DMA_PeripheralInc_Disable          ((u32)0x00000000)
N
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
N                                            ((STATE) == DMA_PeripheralInc_Disable))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) ||                                             ((STATE) == DMA_PeripheralInc_Disable))
N
N/* DMA memory incremented mode -----------------------------------------------*/
N#define DMA_MemoryInc_Enable               ((u32)0x00000080)
N#define DMA_MemoryInc_Disable              ((u32)0x00000000)
N
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
N                                        ((STATE) == DMA_MemoryInc_Disable))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) ||                                         ((STATE) == DMA_MemoryInc_Disable))
N
N/* DMA peripheral data size --------------------------------------------------*/
N#define DMA_PeripheralDataSize_Byte        ((u32)0x00000000)
N#define DMA_PeripheralDataSize_HalfWord    ((u32)0x00000100)
N#define DMA_PeripheralDataSize_Word        ((u32)0x00000200)
N
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_Word))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) ||                                            ((SIZE) == DMA_PeripheralDataSize_HalfWord) ||                                            ((SIZE) == DMA_PeripheralDataSize_Word))
N
N/* DMA memory data size ------------------------------------------------------*/
N#define DMA_MemoryDataSize_Byte            ((u32)0x00000000)
N#define DMA_MemoryDataSize_HalfWord        ((u32)0x00000400)
N#define DMA_MemoryDataSize_Word            ((u32)0x00000800)
N
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
N                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
N                                       ((SIZE) == DMA_MemoryDataSize_Word))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) ||                                        ((SIZE) == DMA_MemoryDataSize_HalfWord) ||                                        ((SIZE) == DMA_MemoryDataSize_Word))
N
N/* DMA circular/normal mode --------------------------------------------------*/
N#define DMA_Mode_Circular                  ((u32)0x00000020)
N#define DMA_Mode_Normal                    ((u32)0x00000000)
N
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Circular) || ((MODE) == DMA_Mode_Normal))
N
N/* DMA priority level --------------------------------------------------------*/
N#define DMA_Priority_VeryHigh              ((u32)0x00003000)
N#define DMA_Priority_High                  ((u32)0x00002000)
N#define DMA_Priority_Medium                ((u32)0x00001000)
N#define DMA_Priority_Low                   ((u32)0x00000000)
N
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
N                                   ((PRIORITY) == DMA_Priority_High) || \
N                                   ((PRIORITY) == DMA_Priority_Medium) || \
N                                   ((PRIORITY) == DMA_Priority_Low))
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) ||                                    ((PRIORITY) == DMA_Priority_High) ||                                    ((PRIORITY) == DMA_Priority_Medium) ||                                    ((PRIORITY) == DMA_Priority_Low))
N
N/* DMA memory to memory ------------------------------------------------------*/
N#define DMA_M2M_Enable                     ((u32)0x00004000)
N#define DMA_M2M_Disable                    ((u32)0x00000000)
N
N#define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Enable) || ((STATE) == DMA_M2M_Disable))
N
N/* DMA interrupts definition -------------------------------------------------*/
N#define DMA_IT_TC                          ((u32)0x00000002)
N#define DMA_IT_HT                          ((u32)0x00000004)
N#define DMA_IT_TE                          ((u32)0x00000008)
N
N#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFFF1) == 0x00) && ((IT) != 0x00))
N
N/* For DMA1 */
N#define DMA1_IT_GL1                        ((u32)0x00000001)
N#define DMA1_IT_TC1                        ((u32)0x00000002)
N#define DMA1_IT_HT1                        ((u32)0x00000004)
N#define DMA1_IT_TE1                        ((u32)0x00000008)
N#define DMA1_IT_GL2                        ((u32)0x00000010)
N#define DMA1_IT_TC2                        ((u32)0x00000020)
N#define DMA1_IT_HT2                        ((u32)0x00000040)
N#define DMA1_IT_TE2                        ((u32)0x00000080)
N#define DMA1_IT_GL3                        ((u32)0x00000100)
N#define DMA1_IT_TC3                        ((u32)0x00000200)
N#define DMA1_IT_HT3                        ((u32)0x00000400)
N#define DMA1_IT_TE3                        ((u32)0x00000800)
N#define DMA1_IT_GL4                        ((u32)0x00001000)
N#define DMA1_IT_TC4                        ((u32)0x00002000)
N#define DMA1_IT_HT4                        ((u32)0x00004000)
N#define DMA1_IT_TE4                        ((u32)0x00008000)
N#define DMA1_IT_GL5                        ((u32)0x00010000)
N#define DMA1_IT_TC5                        ((u32)0x00020000)
N#define DMA1_IT_HT5                        ((u32)0x00040000)
N#define DMA1_IT_TE5                        ((u32)0x00080000)
N#define DMA1_IT_GL6                        ((u32)0x00100000)
N#define DMA1_IT_TC6                        ((u32)0x00200000)
N#define DMA1_IT_HT6                        ((u32)0x00400000)
N#define DMA1_IT_TE6                        ((u32)0x00800000)
N#define DMA1_IT_GL7                        ((u32)0x01000000)
N#define DMA1_IT_TC7                        ((u32)0x02000000)
N#define DMA1_IT_HT7                        ((u32)0x04000000)
N#define DMA1_IT_TE7                        ((u32)0x08000000)
N/* For DMA2 */
N#define DMA2_IT_GL1                        ((u32)0x10000001)
N#define DMA2_IT_TC1                        ((u32)0x10000002)
N#define DMA2_IT_HT1                        ((u32)0x10000004)
N#define DMA2_IT_TE1                        ((u32)0x10000008)
N#define DMA2_IT_GL2                        ((u32)0x10000010)
N#define DMA2_IT_TC2                        ((u32)0x10000020)
N#define DMA2_IT_HT2                        ((u32)0x10000040)
N#define DMA2_IT_TE2                        ((u32)0x10000080)
N#define DMA2_IT_GL3                        ((u32)0x10000100)
N#define DMA2_IT_TC3                        ((u32)0x10000200)
N#define DMA2_IT_HT3                        ((u32)0x10000400)
N#define DMA2_IT_TE3                        ((u32)0x10000800)
N#define DMA2_IT_GL4                        ((u32)0x10001000)
N#define DMA2_IT_TC4                        ((u32)0x10002000)
N#define DMA2_IT_HT4                        ((u32)0x10004000)
N#define DMA2_IT_TE4                        ((u32)0x10008000)
N#define DMA2_IT_GL5                        ((u32)0x10010000)
N#define DMA2_IT_TC5                        ((u32)0x10020000)
N#define DMA2_IT_HT5                        ((u32)0x10040000)
N#define DMA2_IT_TE5                        ((u32)0x10080000)
N
N#define IS_DMA_CLEAR_IT(IT) (((((IT) & 0xF0000000) == 0x00) || (((IT) & 0xEFF00000) == 0x00)) && ((IT) != 0x00))
N#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \
N                           ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \
N                           ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \
N                           ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) || \
N                           ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) || \
N                           ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) || \
N                           ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) || \
N                           ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) || \
N                           ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) || \
N                           ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) || \
N                           ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) || \
N                           ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) || \
N                           ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) || \
N                           ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) || \
N                           ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) || \
N                           ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) || \
N                           ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) || \
N                           ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) || \
N                           ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) || \
N                           ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) || \
N                           ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) || \
N                           ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) || \
N                           ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \
N                           ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
X#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) ||                            ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) ||                            ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) ||                            ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) ||                            ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) ||                            ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) ||                            ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) ||                            ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) ||                            ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) ||                            ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) ||                            ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) ||                            ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) ||                            ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) ||                            ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) ||                            ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) ||                            ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) ||                            ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) ||                            ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) ||                            ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) ||                            ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) ||                            ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) ||                            ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) ||                            ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) ||                            ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
N
N/* DMA flags definition ------------------------------------------------------*/
N/* For DMA1 */
N#define DMA1_FLAG_GL1                      ((u32)0x00000001)
N#define DMA1_FLAG_TC1                      ((u32)0x00000002)
N#define DMA1_FLAG_HT1                      ((u32)0x00000004)
N#define DMA1_FLAG_TE1                      ((u32)0x00000008)
N#define DMA1_FLAG_GL2                      ((u32)0x00000010)
N#define DMA1_FLAG_TC2                      ((u32)0x00000020)
N#define DMA1_FLAG_HT2                      ((u32)0x00000040)
N#define DMA1_FLAG_TE2                      ((u32)0x00000080)
N#define DMA1_FLAG_GL3                      ((u32)0x00000100)
N#define DMA1_FLAG_TC3                      ((u32)0x00000200)
N#define DMA1_FLAG_HT3                      ((u32)0x00000400)
N#define DMA1_FLAG_TE3                      ((u32)0x00000800)
N#define DMA1_FLAG_GL4                      ((u32)0x00001000)
N#define DMA1_FLAG_TC4                      ((u32)0x00002000)
N#define DMA1_FLAG_HT4                      ((u32)0x00004000)
N#define DMA1_FLAG_TE4                      ((u32)0x00008000)
N#define DMA1_FLAG_GL5                      ((u32)0x00010000)
N#define DMA1_FLAG_TC5                      ((u32)0x00020000)
N#define DMA1_FLAG_HT5                      ((u32)0x00040000)
N#define DMA1_FLAG_TE5                      ((u32)0x00080000)
N#define DMA1_FLAG_GL6                      ((u32)0x00100000)
N#define DMA1_FLAG_TC6                      ((u32)0x00200000)
N#define DMA1_FLAG_HT6                      ((u32)0x00400000)
N#define DMA1_FLAG_TE6                      ((u32)0x00800000)
N#define DMA1_FLAG_GL7                      ((u32)0x01000000)
N#define DMA1_FLAG_TC7                      ((u32)0x02000000)
N#define DMA1_FLAG_HT7                      ((u32)0x04000000)
N#define DMA1_FLAG_TE7                      ((u32)0x08000000)
N/* For DMA2 */
N#define DMA2_FLAG_GL1                      ((u32)0x10000001)
N#define DMA2_FLAG_TC1                      ((u32)0x10000002)
N#define DMA2_FLAG_HT1                      ((u32)0x10000004)
N#define DMA2_FLAG_TE1                      ((u32)0x10000008)
N#define DMA2_FLAG_GL2                      ((u32)0x10000010)
N#define DMA2_FLAG_TC2                      ((u32)0x10000020)
N#define DMA2_FLAG_HT2                      ((u32)0x10000040)
N#define DMA2_FLAG_TE2                      ((u32)0x10000080)
N#define DMA2_FLAG_GL3                      ((u32)0x10000100)
N#define DMA2_FLAG_TC3                      ((u32)0x10000200)
N#define DMA2_FLAG_HT3                      ((u32)0x10000400)
N#define DMA2_FLAG_TE3                      ((u32)0x10000800)
N#define DMA2_FLAG_GL4                      ((u32)0x10001000)
N#define DMA2_FLAG_TC4                      ((u32)0x10002000)
N#define DMA2_FLAG_HT4                      ((u32)0x10004000)
N#define DMA2_FLAG_TE4                      ((u32)0x10008000)
N#define DMA2_FLAG_GL5                      ((u32)0x10010000)
N#define DMA2_FLAG_TC5                      ((u32)0x10020000)
N#define DMA2_FLAG_HT5                      ((u32)0x10040000)
N#define DMA2_FLAG_TE5                      ((u32)0x10080000)
N
N#define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) & 0xF0000000) == 0x00) || (((FLAG) & 0xEFF00000) == 0x00)) && ((FLAG) != 0x00))
N#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \
N                               ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \
N                               ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \
N                               ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) || \
N                               ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) || \
N                               ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) || \
N                               ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) || \
N                               ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) || \
N                               ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) || \
N                               ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) || \
N                               ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) || \
N                               ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) || \
N                               ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) || \
N                               ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) || \
N                               ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) || \
N                               ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) || \
N                               ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) || \
N                               ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) || \
N                               ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) || \
N                               ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) || \
N                               ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) || \
N                               ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \
N                               ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \
N                               ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
X#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) ||                                ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) ||                                ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) ||                                ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) ||                                ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) ||                                ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) ||                                ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) ||                                ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) ||                                ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) ||                                ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) ||                                ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) ||                                ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) ||                                ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) ||                                ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) ||                                ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) ||                                ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) ||                                ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) ||                                ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) ||                                ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) ||                                ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) ||                                ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) ||                                ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) ||                                ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) ||                                ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
N
N/* DMA Buffer Size -----------------------------------------------------------*/
N#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);
Nvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);
Nvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, u32 DMA_IT, FunctionalState NewState);
Nu16 DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
NFlagStatus DMA_GetFlagStatus(u32 DMA_FLAG);
Nvoid DMA_ClearFlag(u32 DMA_FLAG);
NITStatus DMA_GetITStatus(u32 DMA_IT);
Nvoid DMA_ClearITPendingBit(u32 DMA_IT);
N
N#endif /*__STM32F10x_DMA_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 50 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_DMA */
N
N#ifdef _EXTI
N  #include "stm32f10x_exti.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_exti.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_exti.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      EXTI firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_EXTI_H
N#define __STM32F10x_EXTI_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* EXTI mode enumeration -----------------------------------------------------*/
Ntypedef enum
N{
N  EXTI_Mode_Interrupt = 0x00,
N  EXTI_Mode_Event = 0x04
N}EXTIMode_TypeDef;
N
N#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
N                            
N/* EXTI Trigger enumeration --------------------------------------------------*/
Ntypedef enum
N{
N  EXTI_Trigger_Rising = 0x08,
N  EXTI_Trigger_Falling = 0x0C,  
N  EXTI_Trigger_Rising_Falling = 0x10
N}EXTITrigger_TypeDef;
N
N#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
N                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
N                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
X#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) ||                                   ((TRIGGER) == EXTI_Trigger_Falling) ||                                   ((TRIGGER) == EXTI_Trigger_Rising_Falling))
N
N/* EXTI Init Structure definition --------------------------------------------*/
Ntypedef struct
N{
N  u32 EXTI_Line;
N  EXTIMode_TypeDef EXTI_Mode;
N  EXTITrigger_TypeDef EXTI_Trigger;
N  FunctionalState EXTI_LineCmd;
N}EXTI_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* EXTI Lines ----------------------------------------------------------------*/
N#define EXTI_Line0       ((u32)0x00001)  /* External interrupt line 0 */
N#define EXTI_Line1       ((u32)0x00002)  /* External interrupt line 1 */
N#define EXTI_Line2       ((u32)0x00004)  /* External interrupt line 2 */
N#define EXTI_Line3       ((u32)0x00008)  /* External interrupt line 3 */
N#define EXTI_Line4       ((u32)0x00010)  /* External interrupt line 4 */
N#define EXTI_Line5       ((u32)0x00020)  /* External interrupt line 5 */
N#define EXTI_Line6       ((u32)0x00040)  /* External interrupt line 6 */
N#define EXTI_Line7       ((u32)0x00080)  /* External interrupt line 7 */
N#define EXTI_Line8       ((u32)0x00100)  /* External interrupt line 8 */
N#define EXTI_Line9       ((u32)0x00200)  /* External interrupt line 9 */
N#define EXTI_Line10      ((u32)0x00400)  /* External interrupt line 10 */
N#define EXTI_Line11      ((u32)0x00800)  /* External interrupt line 11 */
N#define EXTI_Line12      ((u32)0x01000)  /* External interrupt line 12 */
N#define EXTI_Line13      ((u32)0x02000)  /* External interrupt line 13 */
N#define EXTI_Line14      ((u32)0x04000)  /* External interrupt line 14 */
N#define EXTI_Line15      ((u32)0x08000)  /* External interrupt line 15 */
N#define EXTI_Line16      ((u32)0x10000)  /* External interrupt line 16
N                                            Connected to the PVD Output */
N#define EXTI_Line17      ((u32)0x20000)  /* External interrupt line 17 
N                                            Connected to the RTC Alarm event */
N#define EXTI_Line18      ((u32)0x40000)  /* External interrupt line 18 
N                                            Connected to the USB Wakeup from 
N                                            suspend event */
N
N#define IS_EXTI_LINE(LINE) ((((LINE) & (u32)0xFFF80000) == 0x00) && ((LINE) != (u16)0x00))
N
N#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
N                            ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
N                            ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
N                            ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
N                            ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
N                            ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
N                            ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
N                            ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
N                            ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
N                            ((LINE) == EXTI_Line18))
X#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) ||                             ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) ||                             ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) ||                             ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) ||                             ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) ||                             ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) ||                             ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) ||                             ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) ||                             ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) ||                             ((LINE) == EXTI_Line18))
N                                 
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid EXTI_DeInit(void);
Nvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_GenerateSWInterrupt(u32 EXTI_Line);
NFlagStatus EXTI_GetFlagStatus(u32 EXTI_Line);
Nvoid EXTI_ClearFlag(u32 EXTI_Line);
NITStatus EXTI_GetITStatus(u32 EXTI_Line);
Nvoid EXTI_ClearITPendingBit(u32 EXTI_Line);
N
N#endif /* __STM32F10x_EXTI_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 54 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_EXTI */
N
N#ifdef _FLASH
N  #include "stm32f10x_flash.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_flash.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_flash.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      FLASH firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_FLASH_H
N#define __STM32F10x_FLASH_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N#ifdef _FLASH_PROG
N/* FLASH Status */
Ntypedef enum
N{ 
N  FLASH_BUSY = 1,
N  FLASH_ERROR_PG,
N  FLASH_ERROR_WRP,
N  FLASH_COMPLETE,
N  FLASH_TIMEOUT
N}FLASH_Status;
N#endif
N
N/* Flash Latency -------------------------------------------------------------*/
N#define FLASH_Latency_0                ((u32)0x00000000)  /* FLASH Zero Latency cycle */
N#define FLASH_Latency_1                ((u32)0x00000001)  /* FLASH One Latency cycle */
N#define FLASH_Latency_2                ((u32)0x00000002)  /* FLASH Two Latency cycles */
N
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
N                                   ((LATENCY) == FLASH_Latency_1) || \
N                                   ((LATENCY) == FLASH_Latency_2))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) ||                                    ((LATENCY) == FLASH_Latency_1) ||                                    ((LATENCY) == FLASH_Latency_2))
N
N/* Half Cycle Enable/Disable -------------------------------------------------*/
N#define FLASH_HalfCycleAccess_Enable   ((u32)0x00000008)  /* FLASH Half Cycle Enable */
N#define FLASH_HalfCycleAccess_Disable  ((u32)0x00000000)  /* FLASH Half Cycle Disable */
N
N#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) || \
N                                               ((STATE) == FLASH_HalfCycleAccess_Disable)) 
X#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) ||                                                ((STATE) == FLASH_HalfCycleAccess_Disable)) 
N
N
N/* Prefetch Buffer Enable/Disable --------------------------------------------*/
N#define FLASH_PrefetchBuffer_Enable    ((u32)0x00000010)  /* FLASH Prefetch Buffer Enable */
N#define FLASH_PrefetchBuffer_Disable   ((u32)0x00000000)  /* FLASH Prefetch Buffer Disable */
N
N#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) || \
N                                              ((STATE) == FLASH_PrefetchBuffer_Disable)) 
X#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) ||                                               ((STATE) == FLASH_PrefetchBuffer_Disable)) 
N
N#ifdef _FLASH_PROG
N/* Option Bytes Write Protection ---------------------------------------------*/
N/* Values to be used with STM32F10Xxx Medium-density devices: FLASH memory density
N   ranges between 32 and 128 Kbytes with page size equal to 1 Kbytes */
N#define FLASH_WRProt_Pages0to3         ((u32)0x00000001) /* Write protection of page 0 to 3 */
N#define FLASH_WRProt_Pages4to7         ((u32)0x00000002) /* Write protection of page 4 to 7 */
N#define FLASH_WRProt_Pages8to11        ((u32)0x00000004) /* Write protection of page 8 to 11 */
N#define FLASH_WRProt_Pages12to15       ((u32)0x00000008) /* Write protection of page 12 to 15 */
N#define FLASH_WRProt_Pages16to19       ((u32)0x00000010) /* Write protection of page 16 to 19 */
N#define FLASH_WRProt_Pages20to23       ((u32)0x00000020) /* Write protection of page 20 to 23 */
N#define FLASH_WRProt_Pages24to27       ((u32)0x00000040) /* Write protection of page 24 to 27 */
N#define FLASH_WRProt_Pages28to31       ((u32)0x00000080) /* Write protection of page 28 to 31 */
N#define FLASH_WRProt_Pages32to35       ((u32)0x00000100) /* Write protection of page 32 to 35 */
N#define FLASH_WRProt_Pages36to39       ((u32)0x00000200) /* Write protection of page 36 to 39 */
N#define FLASH_WRProt_Pages40to43       ((u32)0x00000400) /* Write protection of page 40 to 43 */
N#define FLASH_WRProt_Pages44to47       ((u32)0x00000800) /* Write protection of page 44 to 47 */
N#define FLASH_WRProt_Pages48to51       ((u32)0x00001000) /* Write protection of page 48 to 51 */
N#define FLASH_WRProt_Pages52to55       ((u32)0x00002000) /* Write protection of page 52 to 55 */
N#define FLASH_WRProt_Pages56to59       ((u32)0x00004000) /* Write protection of page 56 to 59 */
N#define FLASH_WRProt_Pages60to63       ((u32)0x00008000) /* Write protection of page 60 to 63 */
N#define FLASH_WRProt_Pages64to67       ((u32)0x00010000) /* Write protection of page 64 to 67 */
N#define FLASH_WRProt_Pages68to71       ((u32)0x00020000) /* Write protection of page 68 to 71 */
N#define FLASH_WRProt_Pages72to75       ((u32)0x00040000) /* Write protection of page 72 to 75 */
N#define FLASH_WRProt_Pages76to79       ((u32)0x00080000) /* Write protection of page 76 to 79 */
N#define FLASH_WRProt_Pages80to83       ((u32)0x00100000) /* Write protection of page 80 to 83 */
N#define FLASH_WRProt_Pages84to87       ((u32)0x00200000) /* Write protection of page 84 to 87 */
N#define FLASH_WRProt_Pages88to91       ((u32)0x00400000) /* Write protection of page 88 to 91 */
N#define FLASH_WRProt_Pages92to95       ((u32)0x00800000) /* Write protection of page 92 to 95 */
N#define FLASH_WRProt_Pages96to99       ((u32)0x01000000) /* Write protection of page 96 to 99 */
N#define FLASH_WRProt_Pages100to103     ((u32)0x02000000) /* Write protection of page 100 to 103 */
N#define FLASH_WRProt_Pages104to107     ((u32)0x04000000) /* Write protection of page 104 to 107 */
N#define FLASH_WRProt_Pages108to111     ((u32)0x08000000) /* Write protection of page 108 to 111 */
N#define FLASH_WRProt_Pages112to115     ((u32)0x10000000) /* Write protection of page 112 to 115 */
N#define FLASH_WRProt_Pages116to119     ((u32)0x20000000) /* Write protection of page 115 to 119 */
N#define FLASH_WRProt_Pages120to123     ((u32)0x40000000) /* Write protection of page 120 to 123 */
N#define FLASH_WRProt_Pages124to127     ((u32)0x80000000) /* Write protection of page 124 to 127 */
N/* Values to be used with STM32F10Xxx High-density devices: FLASH memory density
N   ranges between 256 and 512 Kbytes with page size equal to 2 Kbytes */
N#define FLASH_WRProt_Pages0to1         ((u32)0x00000001) /* Write protection of page 0 to 1 */
N#define FLASH_WRProt_Pages2to3         ((u32)0x00000002) /* Write protection of page 2 to 3 */
N#define FLASH_WRProt_Pages4to5         ((u32)0x00000004) /* Write protection of page 4 to 5 */
N#define FLASH_WRProt_Pages6to7         ((u32)0x00000008) /* Write protection of page 6 to 7 */
N#define FLASH_WRProt_Pages8to9         ((u32)0x00000010) /* Write protection of page 8 to 9 */
N#define FLASH_WRProt_Pages10to11       ((u32)0x00000020) /* Write protection of page 10 to 11 */
N#define FLASH_WRProt_Pages12to13       ((u32)0x00000040) /* Write protection of page 12 to 13 */
N#define FLASH_WRProt_Pages14to15       ((u32)0x00000080) /* Write protection of page 14 to 15 */
N#define FLASH_WRProt_Pages16to17       ((u32)0x00000100) /* Write protection of page 16 to 17 */
N#define FLASH_WRProt_Pages18to19       ((u32)0x00000200) /* Write protection of page 18 to 19 */
N#define FLASH_WRProt_Pages20to21       ((u32)0x00000400) /* Write protection of page 20 to 21 */
N#define FLASH_WRProt_Pages22to23       ((u32)0x00000800) /* Write protection of page 22 to 23 */
N#define FLASH_WRProt_Pages24to25       ((u32)0x00001000) /* Write protection of page 24 to 25 */
N#define FLASH_WRProt_Pages26to27       ((u32)0x00002000) /* Write protection of page 26 to 27 */
N#define FLASH_WRProt_Pages28to29       ((u32)0x00004000) /* Write protection of page 28 to 29 */
N#define FLASH_WRProt_Pages30to31       ((u32)0x00008000) /* Write protection of page 30 to 31 */
N#define FLASH_WRProt_Pages32to33       ((u32)0x00010000) /* Write protection of page 32 to 33 */
N#define FLASH_WRProt_Pages34to35       ((u32)0x00020000) /* Write protection of page 34 to 35 */
N#define FLASH_WRProt_Pages36to37       ((u32)0x00040000) /* Write protection of page 36 to 37 */
N#define FLASH_WRProt_Pages38to39       ((u32)0x00080000) /* Write protection of page 38 to 39 */
N#define FLASH_WRProt_Pages40to41       ((u32)0x00100000) /* Write protection of page 40 to 41 */
N#define FLASH_WRProt_Pages42to43       ((u32)0x00200000) /* Write protection of page 42 to 43 */
N#define FLASH_WRProt_Pages44to45       ((u32)0x00400000) /* Write protection of page 44 to 45 */
N#define FLASH_WRProt_Pages46to47       ((u32)0x00800000) /* Write protection of page 46 to 47 */
N#define FLASH_WRProt_Pages48to49       ((u32)0x01000000) /* Write protection of page 48 to 49 */
N#define FLASH_WRProt_Pages50to51       ((u32)0x02000000) /* Write protection of page 50 to 51 */
N#define FLASH_WRProt_Pages52to53       ((u32)0x04000000) /* Write protection of page 52 to 53 */
N#define FLASH_WRProt_Pages54to55       ((u32)0x08000000) /* Write protection of page 54 to 55 */
N#define FLASH_WRProt_Pages56to57       ((u32)0x10000000) /* Write protection of page 56 to 57 */
N#define FLASH_WRProt_Pages58to59       ((u32)0x20000000) /* Write protection of page 58 to 59 */
N#define FLASH_WRProt_Pages60to61       ((u32)0x40000000) /* Write protection of page 60 to 61 */
N#define FLASH_WRProt_Pages62to255      ((u32)0x80000000) /* Write protection of page 62 to 255 */
N#define FLASH_WRProt_AllPages          ((u32)0xFFFFFFFF) /* Write protection of all Pages */
N
N#define IS_FLASH_WRPROT_PAGE(PAGE) (((PAGE) != 0x00000000))
N
N#define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) < 0x0807FFFF))
N#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804) || ((ADDRESS) == 0x1FFFF806))
N
N/* Option Bytes IWatchdog ----------------------------------------------------*/
N#define OB_IWDG_SW                     ((u16)0x0001)  /* Software IWDG selected */
N#define OB_IWDG_HW                     ((u16)0x0000)  /* Hardware IWDG selected */
N
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N/* Option Bytes nRST_STOP ----------------------------------------------------*/
N#define OB_STOP_NoRST                  ((u16)0x0002) /* No reset generated when entering in STOP */
N#define OB_STOP_RST                    ((u16)0x0000) /* Reset generated when entering in STOP */
N
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
N
N/* Option Bytes nRST_STDBY ---------------------------------------------------*/
N#define OB_STDBY_NoRST                 ((u16)0x0004) /* No reset generated when entering in STANDBY */
N#define OB_STDBY_RST                   ((u16)0x0000) /* Reset generated when entering in STANDBY */
N
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
N
N/* FLASH Interrupts ----------------------------------------------------------*/
N#define FLASH_IT_ERROR                 ((u32)0x00000400)  /* FPEC error interrupt source */
N#define FLASH_IT_EOP                   ((u32)0x00001000)  /* End of FLASH Operation Interrupt source */
N
N#define IS_FLASH_IT(IT) ((((IT) & (u32)0xFFFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
N
N/* FLASH Flags ---------------------------------------------------------------*/
N#define FLASH_FLAG_BSY                 ((u32)0x00000001)  /* FLASH Busy flag */
N#define FLASH_FLAG_EOP                 ((u32)0x00000020)  /* FLASH End of Operation flag */
N#define FLASH_FLAG_PGERR               ((u32)0x00000004)  /* FLASH Program error flag */
N#define FLASH_FLAG_WRPRTERR            ((u32)0x00000010)  /* FLASH Write protected error flag */
N#define FLASH_FLAG_OPTERR              ((u32)0x00000001)  /* FLASH Option Byte error flag */
N 
N#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (u32)0xFFFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))
N
N#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
N                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
N                                  ((FLAG) == FLASH_FLAG_OPTERR))
X#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) ||                                   ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) ||                                   ((FLAG) == FLASH_FLAG_OPTERR))
N#endif
N								 
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid FLASH_SetLatency(u32 FLASH_Latency);
Nvoid FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess);
Nvoid FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer);
N
N#ifdef _FLASH_PROG
Nvoid FLASH_Unlock(void);
Nvoid FLASH_Lock(void);
NFLASH_Status FLASH_ErasePage(u32 Page_Address);
NFLASH_Status FLASH_EraseAllPages(void);
NFLASH_Status FLASH_EraseOptionBytes(void);
NFLASH_Status FLASH_ProgramWord(u32 Address, u32 Data);
NFLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data);
NFLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data);
NFLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages);
NFLASH_Status FLASH_ReadOutProtection(FunctionalState NewState);
NFLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY);
Nu32 FLASH_GetUserOptionByte(void);
Nu32 FLASH_GetWriteProtectionOptionByte(void);
NFlagStatus FLASH_GetReadOutProtectionStatus(void);
NFlagStatus FLASH_GetPrefetchBufferStatus(void);
Nvoid FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState);
NFlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG);
Nvoid FLASH_ClearFlag(u16 FLASH_FLAG);
NFLASH_Status FLASH_GetStatus(void);
NFLASH_Status FLASH_WaitForLastOperation(u32 Timeout);
N#endif
N
N#endif /* __STM32F10x_FLASH_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 58 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_FLASH */
N
N#ifdef _FSMC
N  #include "stm32f10x_fsmc.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_fsmc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_fsmc.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      FSMC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_FSMC_H
N#define __STM32F10x_FSMC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Timing parameters For NOR/SRAM Banks */
Ntypedef struct
N{
N  u32 FSMC_AddressSetupTime;
N  u32 FSMC_AddressHoldTime;
N  u32 FSMC_DataSetupTime;
N  u32 FSMC_BusTurnAroundDuration;
N  u32 FSMC_CLKDivision;
N  u32 FSMC_DataLatency;
N  u32 FSMC_AccessMode;
N}FSMC_NORSRAMTimingInitTypeDef;
N
N/* FSMC NOR/SRAM Init structure definition */
Ntypedef struct
N{
N  u32 FSMC_Bank;
N  u32 FSMC_DataAddressMux;
N  u32 FSMC_MemoryType;
N  u32 FSMC_MemoryDataWidth;
N  u32 FSMC_BurstAccessMode;
N  u32 FSMC_WaitSignalPolarity;
N  u32 FSMC_WrapMode;
N  u32 FSMC_WaitSignalActive;
N  u32 FSMC_WriteOperation;
N  u32 FSMC_WaitSignal;
N  u32 FSMC_ExtendedMode;
N  u32 FSMC_AsyncWait;
N  u32 FSMC_WriteBurst;
N  /* Timing Parameters for write and read access if the  ExtendedMode is not used*/
N  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct;
N  /* Timing Parameters for write access if the  ExtendedMode is used*/
N  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;
N}FSMC_NORSRAMInitTypeDef;
N
N/* Timing parameters For FSMC NAND and PCCARD Banks */
Ntypedef struct
N{
N  u32 FSMC_SetupTime;
N  u32 FSMC_WaitSetupTime;
N  u32 FSMC_HoldSetupTime;
N  u32 FSMC_HiZSetupTime;
N}FSMC_NAND_PCCARDTimingInitTypeDef;
N
N/* FSMC NAND Init structure definition */
Ntypedef struct
N{
N  u32 FSMC_Bank;
N  u32 FSMC_Waitfeature;
N  u32 FSMC_MemoryDataWidth;
N  u32 FSMC_ECC;
N  u32 FSMC_ECCPageSize;
N  u32 FSMC_AddressLowMapping;
N  u32 FSMC_TCLRSetupTime;
N  u32 FSMC_TARSetupTime;
N  /* FSMC Common Space Timing */
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;
N  /* FSMC Attribute Space Timing */
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;
N}FSMC_NANDInitTypeDef;
N
N/* FSMC PCCARD Init structure definition */
Ntypedef struct
N{
N  u32 FSMC_Waitfeature;
N  u32 FSMC_AddressLowMapping;
N  u32 FSMC_TCLRSetupTime;
N  u32 FSMC_TARSetupTime;
N  /* FSMC Common Space Timing */
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;
N  /* FSMC Attribute Space Timing */
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;
N  /* FSMC IO Space Timing */
N  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct;
N}FSMC_PCCARDInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/*-------------------------------FSMC Banks definitions ----------------------*/
N#define FSMC_Bank1_NORSRAM1                             ((u32)0x00000000)
N#define FSMC_Bank1_NORSRAM2                             ((u32)0x00000002)
N#define FSMC_Bank1_NORSRAM3                             ((u32)0x00000004)
N#define FSMC_Bank1_NORSRAM4                             ((u32)0x00000006)
N#define FSMC_Bank2_NAND                                 ((u32)0x00000010)
N#define FSMC_Bank3_NAND                                 ((u32)0x00000100)
N#define FSMC_Bank4_PCCARD                               ((u32)0x00001000)
N
N#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \
N                                    ((BANK) == FSMC_Bank1_NORSRAM4))                           
X#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) ||                                     ((BANK) == FSMC_Bank1_NORSRAM2) ||                                     ((BANK) == FSMC_Bank1_NORSRAM3) ||                                     ((BANK) == FSMC_Bank1_NORSRAM4))                           
N
N
N#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                                 ((BANK) == FSMC_Bank3_NAND))
X#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                  ((BANK) == FSMC_Bank3_NAND))
N
N#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                                    ((BANK) == FSMC_Bank3_NAND) || \
N                                    ((BANK) == FSMC_Bank4_PCCARD))
X#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                     ((BANK) == FSMC_Bank3_NAND) ||                                     ((BANK) == FSMC_Bank4_PCCARD))
N                                    
N#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
N                               ((BANK) == FSMC_Bank3_NAND) || \
N                               ((BANK) == FSMC_Bank4_PCCARD))                                    
X#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) ||                                ((BANK) == FSMC_Bank3_NAND) ||                                ((BANK) == FSMC_Bank4_PCCARD))                                    
N
N
N/*------------------------------- NOR/SRAM Banks -----------------------------*/
N/* FSMC Data/Address Bus Multiplexing ----------------------------------------*/
N#define FSMC_DataAddressMux_Disable                       ((u32)0x00000000)
N#define FSMC_DataAddressMux_Enable                        ((u32)0x00000002)
N
N#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
N                          ((MUX) == FSMC_DataAddressMux_Enable))                           
X#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) ||                           ((MUX) == FSMC_DataAddressMux_Enable))                           
N
N/* FSMC Memory Type ----------------------------------------------------------*/
N#define FSMC_MemoryType_SRAM                            ((u32)0x00000000)
N#define FSMC_MemoryType_CRAM                            ((u32)0x00000004)
N#define FSMC_MemoryType_NOR                             ((u32)0x00000008)
N#define FSMC_MemoryType_COSMORAM                        ((u32)0x0000000C)
N
N#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
N                                ((MEMORY) == FSMC_MemoryType_CRAM)|| \
N                                ((MEMORY) == FSMC_MemoryType_NOR)|| \
N                                ((MEMORY) == FSMC_MemoryType_COSMORAM))
X#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) ||                                 ((MEMORY) == FSMC_MemoryType_CRAM)||                                 ((MEMORY) == FSMC_MemoryType_NOR)||                                 ((MEMORY) == FSMC_MemoryType_COSMORAM))
N                                     
N/* FSMC  Data Width ----------------------------------------------------------*/
N#define FSMC_MemoryDataWidth_8b                         ((u32)0x00000000)
N#define FSMC_MemoryDataWidth_16b                        ((u32)0x00000010)
N
N#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
N                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))
X#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) ||                                      ((WIDTH) == FSMC_MemoryDataWidth_16b))
N                                      
N                               
N/* FSMC Burst Access Mode ----------------------------------------------------*/
N#define FSMC_BurstAccessMode_Disable                    ((u32)0x00000000) 
N#define FSMC_BurstAccessMode_Enable                     ((u32)0x00000100)
N
N#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
N                                  ((STATE) == FSMC_BurstAccessMode_Enable))
X#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) ||                                   ((STATE) == FSMC_BurstAccessMode_Enable))
N
N/* FSMC Wait Signal Polarity -------------------------------------------------*/                                  
N#define FSMC_WaitSignalPolarity_Low                     ((u32)0x00000000)
N#define FSMC_WaitSignalPolarity_High                    ((u32)0x00000200)
N
N#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
N                                         ((POLARITY) == FSMC_WaitSignalPolarity_High)) 
X#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) ||                                          ((POLARITY) == FSMC_WaitSignalPolarity_High)) 
N                                        
N/* FSMC Wrap Mode ------------------------------------------------------------*/ 
N#define FSMC_WrapMode_Disable                           ((u32)0x00000000)
N#define FSMC_WrapMode_Enable                            ((u32)0x00000400) 
N
N#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
N                                 ((MODE) == FSMC_WrapMode_Enable))
X#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) ||                                  ((MODE) == FSMC_WrapMode_Enable))
N                                 
N/* FSMC Wait Timing ----------------------------------------------------------*/                                 
N#define FSMC_WaitSignalActive_BeforeWaitState           ((u32)0x00000000)
N#define FSMC_WaitSignalActive_DuringWaitState           ((u32)0x00000800) 
N
N#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
N                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
X#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) ||                                             ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
N                                    
N/* FSMC Write Operation ------------------------------------------------------*/
N#define FSMC_WriteOperation_Disable                     ((u32)0x00000000)
N#define FSMC_WriteOperation_Enable                      ((u32)0x00001000)
N
N#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
N                                            ((OPERATION) == FSMC_WriteOperation_Enable))
X#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) ||                                             ((OPERATION) == FSMC_WriteOperation_Enable))
N                              
N/* FSMC Wait Signal ----------------------------------------------------------*/
N#define FSMC_WaitSignal_Disable                         ((u32)0x00000000)
N#define FSMC_WaitSignal_Enable                          ((u32)0x00002000) 
N
N#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
N                                      ((SIGNAL) == FSMC_WaitSignal_Enable))
X#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) ||                                       ((SIGNAL) == FSMC_WaitSignal_Enable))
N
N/* FSMC Extended Mode --------------------------------------------------------*/
N#define FSMC_ExtendedMode_Disable                       ((u32)0x00000000)
N#define FSMC_ExtendedMode_Enable                        ((u32)0x00004000)                                  
N
N#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
N                                     ((MODE) == FSMC_ExtendedMode_Enable)) 
X#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) ||                                      ((MODE) == FSMC_ExtendedMode_Enable)) 
N                               
N/* FSMC Asynchronous Wait ----------------------------------------------------*/
N#define FSMC_AsyncWait_Disable                          ((u32)0x00000000)
N#define FSMC_AsyncWait_Enable                           ((u32)0x00008000)
N
N#define IS_FSMC_ASYNC_WAIT(WAIT) (((WAIT) == FSMC_AsyncWait_Disable) || \
N                                  ((WAIT) == FSMC_AsyncWait_Enable))
X#define IS_FSMC_ASYNC_WAIT(WAIT) (((WAIT) == FSMC_AsyncWait_Disable) ||                                   ((WAIT) == FSMC_AsyncWait_Enable))
N                                  
N/* FSMC Write Burst ----------------------------------------------------------*/                                  
N#define FSMC_WriteBurst_Disable                         ((u32)0x00000000)
N#define FSMC_WriteBurst_Enable                          ((u32)0x00080000) 
N
N#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
N                                    ((BURST) == FSMC_WriteBurst_Enable))
X#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) ||                                     ((BURST) == FSMC_WriteBurst_Enable))
N
N/* FSMC Address Setup Time ---------------------------------------------------*/
N#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
N
N/* FSMC Address Hold Time ----------------------------------------------------*/
N#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
N
N/* FSMC Data Setup Time ------------------------------------------------------*/
N#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
N
N/* FSMC Bus Turn around Duration ---------------------------------------------*/
N#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
N
N/* FSMC CLK Division ---------------------------------------------------------*/
N#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
N
N/* FSMC Data Latency ---------------------------------------------------------*/
N#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
N
N/* FSMC Access Mode ----------------------------------------------------------*/
N#define FSMC_AccessMode_A                               ((u32)0x00000000)
N#define FSMC_AccessMode_B                               ((u32)0x10000000) 
N#define FSMC_AccessMode_C                               ((u32)0x20000000)
N#define FSMC_AccessMode_D                               ((u32)0x30000000)
N
N#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
N                                   ((MODE) == FSMC_AccessMode_B) || \
N                                   ((MODE) == FSMC_AccessMode_C) || \
N                                   ((MODE) == FSMC_AccessMode_D)) 
X#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) ||                                    ((MODE) == FSMC_AccessMode_B) ||                                    ((MODE) == FSMC_AccessMode_C) ||                                    ((MODE) == FSMC_AccessMode_D)) 
N                                  
N/*----------------------------- NAND and PCCARD Banks ------------------------*/
N/* FSMC Wait feature ---------------------------------------------------------*/
N#define FSMC_Waitfeature_Disable                        ((u32)0x00000000)
N#define FSMC_Waitfeature_Enable                         ((u32)0x00000002)
N
N#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
N                                       ((FEATURE) == FSMC_Waitfeature_Enable))
X#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) ||                                        ((FEATURE) == FSMC_Waitfeature_Enable))
N                                    
N/* FSMC Memory Data Width ----------------------------------------------------*/
N#define FSMC_MemoryDataWidth_8b                         ((u32)0x00000000)
N#define FSMC_MemoryDataWidth_16b                        ((u32)0x00000010)
N
N#define IS_FSMC_DATA_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
N                                   ((WIDTH) == FSMC_MemoryDataWidth_16b))
X#define IS_FSMC_DATA_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) ||                                    ((WIDTH) == FSMC_MemoryDataWidth_16b))
N                                    
N/* FSMC ECC ------------------------------------------------------------------*/
N#define FSMC_ECC_Disable                                ((u32)0x00000000)
N#define FSMC_ECC_Enable                                 ((u32)0x00000040)
N
N#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
N                                  ((STATE) == FSMC_ECC_Enable))
X#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) ||                                   ((STATE) == FSMC_ECC_Enable))
N                                            
N/* FSMC ECC Page Size --------------------------------------------------------*/
N#define FSMC_ECCPageSize_256Bytes                       ((u32)0x00000000)
N#define FSMC_ECCPageSize_512Bytes                       ((u32)0x00020000)
N#define FSMC_ECCPageSize_1024Bytes                      ((u32)0x00040000)
N#define FSMC_ECCPageSize_2048Bytes                      ((u32)0x00060000)
N#define FSMC_ECCPageSize_4096Bytes                      ((u32)0x00080000)
N#define FSMC_ECCPageSize_8192Bytes                      ((u32)0x000A0000)
N
N#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_512Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \
N                                    ((SIZE) == FSMC_ECCPageSize_8192Bytes))
X#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_512Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_1024Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_2048Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_4096Bytes) ||                                     ((SIZE) == FSMC_ECCPageSize_8192Bytes))
N                                                              
N/* FSMC Address Low Mapping --------------------------------------------------*/
N#define FSMC_AddressLowMapping_Direct                   ((u32)0x00000000)
N#define FSMC_AddressLowMapping_InDirect                 ((u32)0x00000100)
N
N#define IS_FSMC_ADDRESS_LOW_MAPPING(MAPPING) (((MAPPING) == FSMC_AddressLowMapping_Direct) || \
N                                              ((MAPPING) == FSMC_AddressLowMapping_InDirect))
X#define IS_FSMC_ADDRESS_LOW_MAPPING(MAPPING) (((MAPPING) == FSMC_AddressLowMapping_Direct) ||                                               ((MAPPING) == FSMC_AddressLowMapping_InDirect))
N/* FSMC TCLR Setup Time ------------------------------------------------------*/
N#define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
N
N/* FSMC TAR Setup Time -------------------------------------------------------*/
N#define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
N
N/* FSMC Setup Time ----------------------------------------------------*/
N#define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
N
N/* FSMC Wait Setup Time -----------------------------------------------*/
N#define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
N
N/* FSMC Hold Setup Time -----------------------------------------------*/
N#define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
N
N/* FSMC HiZ Setup Time ------------------------------------------------*/
N#define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
N
N/* FSMC Interrupt sources ----------------------------------------------------*/
N#define FSMC_IT_RisingEdge                              ((u32)0x00000008)
N#define FSMC_IT_Level                                   ((u32)0x00000010)
N#define FSMC_IT_FallingEdge                             ((u32)0x00000020)
N
N#define IS_FSMC_IT(IT) ((((IT) & (u32)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))
N
N#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \
N                            ((IT) == FSMC_IT_Level) || \
N                            ((IT) == FSMC_IT_FallingEdge)) 
X#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) ||                             ((IT) == FSMC_IT_Level) ||                             ((IT) == FSMC_IT_FallingEdge)) 
N
N/* FSMC Flags ----------------------------------------------------------------*/
N#define FSMC_FLAG_RisingEdge                            ((u32)0x00000001)
N#define FSMC_FLAG_Level                                 ((u32)0x00000002)
N#define FSMC_FLAG_FallingEdge                           ((u32)0x00000004)
N#define FSMC_FLAG_FEMPT                                 ((u32)0x00000040)
N
N#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \
N                                ((FLAG) == FSMC_FLAG_Level) || \
N                                ((FLAG) == FSMC_FLAG_FallingEdge) || \
N                                ((FLAG) == FSMC_FLAG_FEMPT))
X#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) ||                                 ((FLAG) == FSMC_FLAG_Level) ||                                 ((FLAG) == FSMC_FLAG_FallingEdge) ||                                 ((FLAG) == FSMC_FLAG_FEMPT))
N
N#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) & (u32)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))                                                                                                                                                                                                                                                                                                                                  
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid FSMC_NORSRAMDeInit(u32 FSMC_Bank);
Nvoid FSMC_NANDDeInit(u32 FSMC_Bank);
Nvoid FSMC_PCCARDDeInit(void);
Nvoid FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
Nvoid FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
Nvoid FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
Nvoid FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
Nvoid FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
Nvoid FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
Nvoid FSMC_NORSRAMCmd(u32 FSMC_Bank, FunctionalState NewState);
Nvoid FSMC_NANDCmd(u32 FSMC_Bank, FunctionalState NewState);
Nvoid FSMC_PCCARDCmd(FunctionalState NewState);
Nvoid FSMC_NANDECCCmd(u32 FSMC_Bank, FunctionalState NewState);
Nu32 FSMC_GetECC(u32 FSMC_Bank);
Nvoid FSMC_ITConfig(u32 FSMC_Bank, u32 FSMC_IT, FunctionalState NewState);
NFlagStatus FSMC_GetFlagStatus(u32 FSMC_Bank, u32 FSMC_FLAG);
Nvoid FSMC_ClearFlag(u32 FSMC_Bank, u32 FSMC_FLAG);
NITStatus FSMC_GetITStatus(u32 FSMC_Bank, u32 FSMC_IT);
Nvoid FSMC_ClearITPendingBit(u32 FSMC_Bank, u32 FSMC_IT);
N
N#endif /*__STM32F10x_FSMC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 62 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_FSMC */
N
N#ifdef _GPIO
N  #include "stm32f10x_gpio.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_gpio.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_gpio.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      GPIO firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_GPIO_H
N#define __STM32F10x_GPIO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == GPIOA_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOB_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOC_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOD_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOE_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOF_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOG_BASE))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == GPIOA_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOB_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOC_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOD_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOE_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOF_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOG_BASE))
N                                     
N/* Output Maximum frequency selection ----------------------------------------*/
Ntypedef enum
N{ 
N  GPIO_Speed_10MHz = 1,
N  GPIO_Speed_2MHz, 
N  GPIO_Speed_50MHz
N}GPIOSpeed_TypeDef;
N
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) || \
N                              ((SPEED) == GPIO_Speed_50MHz))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) ||                               ((SPEED) == GPIO_Speed_50MHz))
N                                         
N/* Configuration Mode enumeration --------------------------------------------*/
Ntypedef enum
N{ GPIO_Mode_AIN = 0x0,
N  GPIO_Mode_IN_FLOATING = 0x04,
N  GPIO_Mode_IPD = 0x28,
N  GPIO_Mode_IPU = 0x48,
N  GPIO_Mode_Out_OD = 0x14,
N  GPIO_Mode_Out_PP = 0x10,
N  GPIO_Mode_AF_OD = 0x1C,
N  GPIO_Mode_AF_PP = 0x18
N}GPIOMode_TypeDef;
N
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) || \
N                            ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \
N                            ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \
N                            ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) ||                             ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) ||                             ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) ||                             ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
N                              
N/* GPIO Init structure definition */
Ntypedef struct
N{
N  u16 GPIO_Pin;
N  GPIOSpeed_TypeDef GPIO_Speed;
N  GPIOMode_TypeDef GPIO_Mode;
N}GPIO_InitTypeDef;
N
N/* Bit_SET and Bit_RESET enumeration -----------------------------------------*/
Ntypedef enum
N{ Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N
N/* Exported constants --------------------------------------------------------*/
N/* GPIO pins define ----------------------------------------------------------*/
N#define GPIO_Pin_0                 ((u16)0x0001)  /* Pin 0 selected */
N#define GPIO_Pin_1                 ((u16)0x0002)  /* Pin 1 selected */
N#define GPIO_Pin_2                 ((u16)0x0004)  /* Pin 2 selected */
N#define GPIO_Pin_3                 ((u16)0x0008)  /* Pin 3 selected */
N#define GPIO_Pin_4                 ((u16)0x0010)  /* Pin 4 selected */
N#define GPIO_Pin_5                 ((u16)0x0020)  /* Pin 5 selected */
N#define GPIO_Pin_6                 ((u16)0x0040)  /* Pin 6 selected */
N#define GPIO_Pin_7                 ((u16)0x0080)  /* Pin 7 selected */
N#define GPIO_Pin_8                 ((u16)0x0100)  /* Pin 8 selected */
N#define GPIO_Pin_9                 ((u16)0x0200)  /* Pin 9 selected */
N#define GPIO_Pin_10                ((u16)0x0400)  /* Pin 10 selected */
N#define GPIO_Pin_11                ((u16)0x0800)  /* Pin 11 selected */
N#define GPIO_Pin_12                ((u16)0x1000)  /* Pin 12 selected */
N#define GPIO_Pin_13                ((u16)0x2000)  /* Pin 13 selected */
N#define GPIO_Pin_14                ((u16)0x4000)  /* Pin 14 selected */
N#define GPIO_Pin_15                ((u16)0x8000)  /* Pin 15 selected */
N#define GPIO_Pin_All               ((u16)0xFFFF)  /* All pins selected */
N
N#define IS_GPIO_PIN(PIN) ((((PIN) & (u16)0x00) == 0x00) && ((PIN) != (u16)0x00))
N
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
N                              ((PIN) == GPIO_Pin_1) || \
N                              ((PIN) == GPIO_Pin_2) || \
N                              ((PIN) == GPIO_Pin_3) || \
N                              ((PIN) == GPIO_Pin_4) || \
N                              ((PIN) == GPIO_Pin_5) || \
N                              ((PIN) == GPIO_Pin_6) || \
N                              ((PIN) == GPIO_Pin_7) || \
N                              ((PIN) == GPIO_Pin_8) || \
N                              ((PIN) == GPIO_Pin_9) || \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                               ((PIN) == GPIO_Pin_1) ||                               ((PIN) == GPIO_Pin_2) ||                               ((PIN) == GPIO_Pin_3) ||                               ((PIN) == GPIO_Pin_4) ||                               ((PIN) == GPIO_Pin_5) ||                               ((PIN) == GPIO_Pin_6) ||                               ((PIN) == GPIO_Pin_7) ||                               ((PIN) == GPIO_Pin_8) ||                               ((PIN) == GPIO_Pin_9) ||                               ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N                            
N/* GPIO Remap define ---------------------------------------------------------*/
N#define GPIO_Remap_SPI1            ((u32)0x00000001)  /* SPI1 Alternate Function mapping */
N#define GPIO_Remap_I2C1            ((u32)0x00000002)  /* I2C1 Alternate Function mapping */
N#define GPIO_Remap_USART1          ((u32)0x00000004)  /* USART1 Alternate Function mapping */
N#define GPIO_Remap_USART2          ((u32)0x00000008)  /* USART2 Alternate Function mapping */
N#define GPIO_PartialRemap_USART3   ((u32)0x00140010)  /* USART3 Partial Alternate Function mapping */
N#define GPIO_FullRemap_USART3      ((u32)0x00140030)  /* USART3 Full Alternate Function mapping */
N#define GPIO_PartialRemap_TIM1     ((u32)0x00160040)  /* TIM1 Partial Alternate Function mapping */
N#define GPIO_FullRemap_TIM1        ((u32)0x001600C0)  /* TIM1 Full Alternate Function mapping */
N#define GPIO_PartialRemap1_TIM2    ((u32)0x00180100)  /* TIM2 Partial1 Alternate Function mapping */
N#define GPIO_PartialRemap2_TIM2    ((u32)0x00180200)  /* TIM2 Partial2 Alternate Function mapping */
N#define GPIO_FullRemap_TIM2        ((u32)0x00180300)  /* TIM2 Full Alternate Function mapping */
N#define GPIO_PartialRemap_TIM3     ((u32)0x001A0800)  /* TIM3 Partial Alternate Function mapping */
N#define GPIO_FullRemap_TIM3        ((u32)0x001A0C00)  /* TIM3 Full Alternate Function mapping */
N#define GPIO_Remap_TIM4            ((u32)0x00001000)  /* TIM4 Alternate Function mapping */
N#define GPIO_Remap1_CAN            ((u32)0x001D4000)  /* CAN Alternate Function mapping */
N#define GPIO_Remap2_CAN            ((u32)0x001D6000)  /* CAN Alternate Function mapping */
N#define GPIO_Remap_PD01            ((u32)0x00008000)  /* PD01 Alternate Function mapping */
N#define GPIO_Remap_TIM5CH4_LSI     ((u32)0x00200001)  /* LSI connected to TIM5 Channel4 input capture for calibration */
N#define GPIO_Remap_ADC1_ETRGINJ    ((u32)0x00200002)  /* ADC1 External Trigger Injected Conversion remapping */
N#define GPIO_Remap_ADC1_ETRGREG    ((u32)0x00200004)  /* ADC1 External Trigger Regular Conversion remapping */
N#define GPIO_Remap_ADC2_ETRGINJ    ((u32)0x00200008)  /* ADC2 External Trigger Injected Conversion remapping */
N#define GPIO_Remap_ADC2_ETRGREG    ((u32)0x00200010)  /* ADC2 External Trigger Regular Conversion remapping */
N#define GPIO_Remap_SWJ_NoJTRST     ((u32)0x00300100)  /* Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */
N#define GPIO_Remap_SWJ_JTAGDisable ((u32)0x00300200)  /* JTAG-DP Disabled and SW-DP Enabled */
N#define GPIO_Remap_SWJ_Disable     ((u32)0x00300400)  /* Full SWJ Disabled (JTAG-DP + SW-DP) */
N
N
N#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) || \
N                              ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) || \
N                              ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) || \
N                              ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) || \
N                              ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) || \
N                              ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) || \
N                              ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) || \
N                              ((REMAP) == GPIO_Remap1_CAN) || ((REMAP) == GPIO_Remap2_CAN) || \
N                              ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) || \
N                              ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) || \
N                              ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) || \
N                              ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable)|| \
N                              ((REMAP) == GPIO_Remap_SWJ_Disable))
X#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) ||                               ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) ||                               ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) ||                               ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) ||                               ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) ||                               ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) ||                               ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) ||                               ((REMAP) == GPIO_Remap1_CAN) || ((REMAP) == GPIO_Remap2_CAN) ||                               ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) ||                               ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) ||                               ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) ||                               ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable)||                               ((REMAP) == GPIO_Remap_SWJ_Disable))
N                              
N/* GPIO Port Sources ---------------------------------------------------------*/
N#define GPIO_PortSourceGPIOA       ((u8)0x00)
N#define GPIO_PortSourceGPIOB       ((u8)0x01)
N#define GPIO_PortSourceGPIOC       ((u8)0x02)
N#define GPIO_PortSourceGPIOD       ((u8)0x03)
N#define GPIO_PortSourceGPIOE       ((u8)0x04)
N#define GPIO_PortSourceGPIOF       ((u8)0x05)
N#define GPIO_PortSourceGPIOG       ((u8)0x06)
N
N#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOE))
X#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOB) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOC) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOD) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOE))
N                                         
N#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOE) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOF) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOG))
X#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOB) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOC) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOD) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOE) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOF) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOG))
N                                       
N/* GPIO Pin sources ----------------------------------------------------------*/
N#define GPIO_PinSource0            ((u8)0x00)
N#define GPIO_PinSource1            ((u8)0x01)
N#define GPIO_PinSource2            ((u8)0x02)
N#define GPIO_PinSource3            ((u8)0x03)
N#define GPIO_PinSource4            ((u8)0x04)
N#define GPIO_PinSource5            ((u8)0x05)
N#define GPIO_PinSource6            ((u8)0x06)
N#define GPIO_PinSource7            ((u8)0x07)
N#define GPIO_PinSource8            ((u8)0x08)
N#define GPIO_PinSource9            ((u8)0x09)
N#define GPIO_PinSource10           ((u8)0x0A)
N#define GPIO_PinSource11           ((u8)0x0B)
N#define GPIO_PinSource12           ((u8)0x0C)
N#define GPIO_PinSource13           ((u8)0x0D)
N#define GPIO_PinSource14           ((u8)0x0E)
N#define GPIO_PinSource15           ((u8)0x0F)
N
N#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
N                                       ((PINSOURCE) == GPIO_PinSource1) || \
N                                       ((PINSOURCE) == GPIO_PinSource2) || \
N                                       ((PINSOURCE) == GPIO_PinSource3) || \
N                                       ((PINSOURCE) == GPIO_PinSource4) || \
N                                       ((PINSOURCE) == GPIO_PinSource5) || \
N                                       ((PINSOURCE) == GPIO_PinSource6) || \
N                                       ((PINSOURCE) == GPIO_PinSource7) || \
N                                       ((PINSOURCE) == GPIO_PinSource8) || \
N                                       ((PINSOURCE) == GPIO_PinSource9) || \
N                                       ((PINSOURCE) == GPIO_PinSource10) || \
N                                       ((PINSOURCE) == GPIO_PinSource11) || \
N                                       ((PINSOURCE) == GPIO_PinSource12) || \
N                                       ((PINSOURCE) == GPIO_PinSource13) || \
N                                       ((PINSOURCE) == GPIO_PinSource14) || \
N                                       ((PINSOURCE) == GPIO_PinSource15))
X#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) ||                                        ((PINSOURCE) == GPIO_PinSource1) ||                                        ((PINSOURCE) == GPIO_PinSource2) ||                                        ((PINSOURCE) == GPIO_PinSource3) ||                                        ((PINSOURCE) == GPIO_PinSource4) ||                                        ((PINSOURCE) == GPIO_PinSource5) ||                                        ((PINSOURCE) == GPIO_PinSource6) ||                                        ((PINSOURCE) == GPIO_PinSource7) ||                                        ((PINSOURCE) == GPIO_PinSource8) ||                                        ((PINSOURCE) == GPIO_PinSource9) ||                                        ((PINSOURCE) == GPIO_PinSource10) ||                                        ((PINSOURCE) == GPIO_PinSource11) ||                                        ((PINSOURCE) == GPIO_PinSource12) ||                                        ((PINSOURCE) == GPIO_PinSource13) ||                                        ((PINSOURCE) == GPIO_PinSource14) ||                                        ((PINSOURCE) == GPIO_PinSource15))
N                          
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid GPIO_DeInit(GPIO_TypeDef* GPIOx);
Nvoid GPIO_AFIODeInit(void);
Nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
Nu8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nu16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
Nu8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nu16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
Nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal);
Nvoid GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal);
Nvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nvoid GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource);
Nvoid GPIO_EventOutputCmd(FunctionalState NewState);
Nvoid GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState);
Nvoid GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource);
N
N#endif /* __STM32F10x_GPIO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 66 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_GPIO */
N
N#ifdef _I2C
N  #include "stm32f10x_i2c.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_i2c.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_i2c.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      I2C firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_I2C_H    
N#define __STM32F10x_I2C_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* I2C Init structure definition */
Ntypedef struct
N{
N  u16 I2C_Mode;
N  u16 I2C_DutyCycle;
N  u16 I2C_OwnAddress1;
N  u16 I2C_Ack;
N  u16 I2C_AcknowledgedAddress;
N  u32 I2C_ClockSpeed;
N}I2C_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N#define IS_I2C_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == I2C1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == I2C2_BASE))
X#define IS_I2C_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == I2C1_BASE) ||                                    ((*(u32*)&(PERIPH)) == I2C2_BASE))
N
N/* I2C modes */
N#define I2C_Mode_I2C                    ((u16)0x0000)
N#define I2C_Mode_SMBusDevice            ((u16)0x0002)
N#define I2C_Mode_SMBusHost              ((u16)0x000A)
N
N#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
N                           ((MODE) == I2C_Mode_SMBusDevice) || \
N                           ((MODE) == I2C_Mode_SMBusHost))
X#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) ||                            ((MODE) == I2C_Mode_SMBusDevice) ||                            ((MODE) == I2C_Mode_SMBusHost))
N/* I2C duty cycle in fast mode */
N#define I2C_DutyCycle_16_9              ((u16)0x4000)
N#define I2C_DutyCycle_2                 ((u16)0xBFFF)
N
N#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
N                                  ((CYCLE) == I2C_DutyCycle_2))
X#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) ||                                   ((CYCLE) == I2C_DutyCycle_2))
N
N/* I2C cknowledgementy */
N#define I2C_Ack_Enable                  ((u16)0x0400)
N#define I2C_Ack_Disable                 ((u16)0x0000)
N
N#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
N                                 ((STATE) == I2C_Ack_Disable))
X#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) ||                                  ((STATE) == I2C_Ack_Disable))
N
N/* I2C transfer direction */
N#define  I2C_Direction_Transmitter      ((u8)0x00)
N#define  I2C_Direction_Receiver         ((u8)0x01)
N
N#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
N                                     ((DIRECTION) == I2C_Direction_Receiver))
X#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) ||                                      ((DIRECTION) == I2C_Direction_Receiver))
N
N/* I2C acknowledged address defines */
N#define I2C_AcknowledgedAddress_7bit    ((u16)0x4000)
N#define I2C_AcknowledgedAddress_10bit   ((u16)0xC000)
N
N#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
N                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
X#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) ||                                              ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
N
N/* I2C registers */
N#define I2C_Register_CR1                ((u8)0x00)
N#define I2C_Register_CR2                ((u8)0x04)
N#define I2C_Register_OAR1               ((u8)0x08)
N#define I2C_Register_OAR2               ((u8)0x0C)
N#define I2C_Register_DR                 ((u8)0x10)
N#define I2C_Register_SR1                ((u8)0x14)
N#define I2C_Register_SR2                ((u8)0x18)
N#define I2C_Register_CCR                ((u8)0x1C)
N#define I2C_Register_TRISE              ((u8)0x20)
N
N#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
N                                   ((REGISTER) == I2C_Register_CR2) || \
N                                   ((REGISTER) == I2C_Register_OAR1) || \
N                                   ((REGISTER) == I2C_Register_OAR2) || \
N                                   ((REGISTER) == I2C_Register_DR) || \
N                                   ((REGISTER) == I2C_Register_SR1) || \
N                                   ((REGISTER) == I2C_Register_SR2) || \
N                                   ((REGISTER) == I2C_Register_CCR) || \
N                                   ((REGISTER) == I2C_Register_TRISE))
X#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) ||                                    ((REGISTER) == I2C_Register_CR2) ||                                    ((REGISTER) == I2C_Register_OAR1) ||                                    ((REGISTER) == I2C_Register_OAR2) ||                                    ((REGISTER) == I2C_Register_DR) ||                                    ((REGISTER) == I2C_Register_SR1) ||                                    ((REGISTER) == I2C_Register_SR2) ||                                    ((REGISTER) == I2C_Register_CCR) ||                                    ((REGISTER) == I2C_Register_TRISE))
N
N/* I2C SMBus alert pin level */
N#define I2C_SMBusAlert_Low              ((u16)0x2000)
N#define I2C_SMBusAlert_High             ((u16)0xDFFF)
N
N#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
N                                   ((ALERT) == I2C_SMBusAlert_High))
X#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) ||                                    ((ALERT) == I2C_SMBusAlert_High))
N
N/* I2C PEC position */
N#define I2C_PECPosition_Next            ((u16)0x0800)
N#define I2C_PECPosition_Current         ((u16)0xF7FF)
N
N#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
N                                       ((POSITION) == I2C_PECPosition_Current))
X#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) ||                                        ((POSITION) == I2C_PECPosition_Current))
N
N/* I2C interrupts definition */
N#define I2C_IT_BUF                      ((u16)0x0400)
N#define I2C_IT_EVT                      ((u16)0x0200)
N#define I2C_IT_ERR                      ((u16)0x0100)
N
N#define IS_I2C_CONFIG_IT(IT) ((((IT) & (u16)0xF8FF) == 0x00) && ((IT) != 0x00))
N
N/* I2C interrupts definition */
N#define I2C_IT_SMBALERT                 ((u32)0x10008000)
N#define I2C_IT_TIMEOUT                  ((u32)0x10004000)
N#define I2C_IT_PECERR                   ((u32)0x10001000)
N#define I2C_IT_OVR                      ((u32)0x10000800)
N#define I2C_IT_AF                       ((u32)0x10000400)
N#define I2C_IT_ARLO                     ((u32)0x10000200)
N#define I2C_IT_BERR                     ((u32)0x10000100)
N#define I2C_IT_TXE                      ((u32)0x00000080)
N#define I2C_IT_RXNE                     ((u32)0x00000040)
N#define I2C_IT_STOPF                    ((u32)0x60000010)
N#define I2C_IT_ADD10                    ((u32)0x20000008)
N#define I2C_IT_BTF                      ((u32)0x60000004)
N#define I2C_IT_ADDR                     ((u32)0xA0000002)
N#define I2C_IT_SB                       ((u32)0x20000001)
N
N#define IS_I2C_CLEAR_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
N                             ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
N                             ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
N                             ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_STOPF) || \
N                             ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
N                             ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
X#define IS_I2C_CLEAR_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) ||                              ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) ||                              ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) ||                              ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_STOPF) ||                              ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) ||                              ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
N
N#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
N                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
N                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
N                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
N                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
N                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
N                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
X#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) ||                            ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) ||                            ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) ||                            ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) ||                            ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) ||                            ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) ||                            ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
N
N/* I2C flags definition */
N#define I2C_FLAG_DUALF                  ((u32)0x00800000)
N#define I2C_FLAG_SMBHOST                ((u32)0x00400000)
N#define I2C_FLAG_SMBDEFAULT             ((u32)0x00200000)
N#define I2C_FLAG_GENCALL                ((u32)0x00100000)
N#define I2C_FLAG_TRA                    ((u32)0x00040000)
N#define I2C_FLAG_BUSY                   ((u32)0x00020000)
N#define I2C_FLAG_MSL                    ((u32)0x00010000)
N#define I2C_FLAG_SMBALERT               ((u32)0x10008000)
N#define I2C_FLAG_TIMEOUT                ((u32)0x10004000)
N#define I2C_FLAG_PECERR                 ((u32)0x10001000)
N#define I2C_FLAG_OVR                    ((u32)0x10000800)
N#define I2C_FLAG_AF                     ((u32)0x10000400)
N#define I2C_FLAG_ARLO                   ((u32)0x10000200)
N#define I2C_FLAG_BERR                   ((u32)0x10000100)
N#define I2C_FLAG_TXE                    ((u32)0x00000080)
N#define I2C_FLAG_RXNE                   ((u32)0x00000040)
N#define I2C_FLAG_STOPF                  ((u32)0x60000010)
N#define I2C_FLAG_ADD10                  ((u32)0x20000008)
N#define I2C_FLAG_BTF                    ((u32)0x60000004)
N#define I2C_FLAG_ADDR                   ((u32)0xA0000002)
N#define I2C_FLAG_SB                     ((u32)0x20000001)
N
N#define IS_I2C_CLEAR_FLAG(FLAG) (((FLAG) == I2C_FLAG_SMBALERT) || ((FLAG) == I2C_FLAG_TIMEOUT) || \
N                                 ((FLAG) == I2C_FLAG_PECERR) || ((FLAG) == I2C_FLAG_OVR) || \
N                                 ((FLAG) == I2C_FLAG_AF) || ((FLAG) == I2C_FLAG_ARLO) || \
N                                 ((FLAG) == I2C_FLAG_BERR) || ((FLAG) == I2C_FLAG_STOPF) || \
N                                 ((FLAG) == I2C_FLAG_ADD10) || ((FLAG) == I2C_FLAG_BTF) || \
N                                 ((FLAG) == I2C_FLAG_ADDR) || ((FLAG) == I2C_FLAG_SB))
X#define IS_I2C_CLEAR_FLAG(FLAG) (((FLAG) == I2C_FLAG_SMBALERT) || ((FLAG) == I2C_FLAG_TIMEOUT) ||                                  ((FLAG) == I2C_FLAG_PECERR) || ((FLAG) == I2C_FLAG_OVR) ||                                  ((FLAG) == I2C_FLAG_AF) || ((FLAG) == I2C_FLAG_ARLO) ||                                  ((FLAG) == I2C_FLAG_BERR) || ((FLAG) == I2C_FLAG_STOPF) ||                                  ((FLAG) == I2C_FLAG_ADD10) || ((FLAG) == I2C_FLAG_BTF) ||                                  ((FLAG) == I2C_FLAG_ADDR) || ((FLAG) == I2C_FLAG_SB))
N
N#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
N                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
N                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
N                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
N                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
N                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
N                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
N                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
N                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
N                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
N                               ((FLAG) == I2C_FLAG_SB))
X#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) ||                                ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) ||                                ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) ||                                ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) ||                                ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) ||                                ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) ||                                ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) ||                                ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) ||                                ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) ||                                ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) ||                                ((FLAG) == I2C_FLAG_SB))
N
N/* I2C Events */
N/* EV1 */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((u32)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
N#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((u32)0x00020002) /* BUSY and ADDR flags */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((u32)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
N#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((u32)0x00820000)  /* DUALF and BUSY flags */
N#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((u32)0x00120000)  /* GENCALL and BUSY flags */
N
N/* EV2 */
N#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((u32)0x00020040)  /* BUSY and RXNE flags */
N     
N/* EV3 */
N#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((u32)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
N
N/* EV4 */
N#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((u32)0x00000010)  /* STOPF flag */
N
N/* EV5 */
N#define  I2C_EVENT_MASTER_MODE_SELECT                      ((u32)0x00030001)  /* BUSY, MSL and SB flag */
N
N/* EV6 */
N#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((u32)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
N#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((u32)0x00030002)  /* BUSY, MSL and ADDR flags */
N
N/* EV7 */
N#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((u32)0x00030040)  /* BUSY, MSL and RXNE flags */
N
N/* EV8 */
N#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((u32)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
N      
N/* EV9 */
N#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((u32)0x00030008)  /* BUSY, MSL and ADD10 flags */
N                                          
N/* EV3_2 */
N#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((u32)0x00000400)  /* AF flag */
N
N#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
N                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
X#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) ||                              ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) ||                              ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
N
N/* I2C own address1 -----------------------------------------------------------*/
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
N/* I2C clock speed ------------------------------------------------------------*/
N#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid I2C_DeInit(I2C_TypeDef* I2Cx);
Nvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address);
Nvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState);
Nvoid I2C_SendData(I2C_TypeDef* I2Cx, u8 Data);
Nu8 I2C_ReceiveData(I2C_TypeDef* I2Cx);
Nvoid I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction);
Nu16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register);
Nvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert);
Nvoid I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition);
Nvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nu8 I2C_GetPEC(I2C_TypeDef* I2Cx);
Nvoid I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle);
Nu32 I2C_GetLastEvent(I2C_TypeDef* I2Cx);
NErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT);
NFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG);
Nvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG);
NITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT);
Nvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT);
N
N#endif /*__STM32F10x_I2C_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 70 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_I2C */
N
N#ifdef _IWDG
N  #include "stm32f10x_iwdg.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_iwdg.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_iwdg.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      IWDG firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_IWDG_H
N#define __STM32F10x_IWDG_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Write access to IWDG_PR and IWDG_RLR registers */
N#define IWDG_WriteAccess_Enable     ((u16)0x5555)
N#define IWDG_WriteAccess_Disable    ((u16)0x0000)
N
N#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
N                                      ((ACCESS) == IWDG_WriteAccess_Disable))
X#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) ||                                       ((ACCESS) == IWDG_WriteAccess_Disable))
N
N/* IWDG prescaler */
N#define IWDG_Prescaler_4            ((u8)0x00)
N#define IWDG_Prescaler_8            ((u8)0x01)
N#define IWDG_Prescaler_16           ((u8)0x02)
N#define IWDG_Prescaler_32           ((u8)0x03)
N#define IWDG_Prescaler_64           ((u8)0x04)
N#define IWDG_Prescaler_128          ((u8)0x05)
N#define IWDG_Prescaler_256          ((u8)0x06)
N
N#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_16) || \
N                                      ((PRESCALER) == IWDG_Prescaler_32) || \
N                                      ((PRESCALER) == IWDG_Prescaler_64) || \
N                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
N                                      ((PRESCALER) == IWDG_Prescaler_256))
X#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  ||                                       ((PRESCALER) == IWDG_Prescaler_8)  ||                                       ((PRESCALER) == IWDG_Prescaler_16) ||                                       ((PRESCALER) == IWDG_Prescaler_32) ||                                       ((PRESCALER) == IWDG_Prescaler_64) ||                                       ((PRESCALER) == IWDG_Prescaler_128)||                                       ((PRESCALER) == IWDG_Prescaler_256))
N
N/* IWDG Flag */
N#define IWDG_FLAG_PVU               ((u16)0x0001)
N#define IWDG_FLAG_RVU               ((u16)0x0002)
N
N#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
N
N#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid IWDG_WriteAccessCmd(u16 IWDG_WriteAccess);
Nvoid IWDG_SetPrescaler(u8 IWDG_Prescaler);
Nvoid IWDG_SetReload(u16 Reload);
Nvoid IWDG_ReloadCounter(void);
Nvoid IWDG_Enable(void);
NFlagStatus IWDG_GetFlagStatus(u16 IWDG_FLAG);
N
N#endif /* __STM32F10x_IWDG_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 74 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_IWDG */
N
N#ifdef _NVIC
N  #include "stm32f10x_nvic.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_nvic.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_nvic.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      NVIC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_NVIC_H
N#define __STM32F10x_NVIC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* NVIC Init Structure definition */
Ntypedef struct
N{
N  u8 NVIC_IRQChannel;
N  u8 NVIC_IRQChannelPreemptionPriority;
N  u8 NVIC_IRQChannelSubPriority;
N  FunctionalState NVIC_IRQChannelCmd;
N} NVIC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* IRQ Channels --------------------------------------------------------------*/
N#define WWDG_IRQChannel              ((u8)0x00)  /* Window WatchDog Interrupt */
N#define PVD_IRQChannel               ((u8)0x01)  /* PVD through EXTI Line detection Interrupt */
N#define TAMPER_IRQChannel            ((u8)0x02)  /* Tamper Interrupt */
N#define RTC_IRQChannel               ((u8)0x03)  /* RTC global Interrupt */
N#define FLASH_IRQChannel             ((u8)0x04)  /* FLASH global Interrupt */
N#define RCC_IRQChannel               ((u8)0x05)  /* RCC global Interrupt */
N#define EXTI0_IRQChannel             ((u8)0x06)  /* EXTI Line0 Interrupt */
N#define EXTI1_IRQChannel             ((u8)0x07)  /* EXTI Line1 Interrupt */
N#define EXTI2_IRQChannel             ((u8)0x08)  /* EXTI Line2 Interrupt */
N#define EXTI3_IRQChannel             ((u8)0x09)  /* EXTI Line3 Interrupt */
N#define EXTI4_IRQChannel             ((u8)0x0A)  /* EXTI Line4 Interrupt */
N#define DMA1_Channel1_IRQChannel     ((u8)0x0B)  /* DMA1 Channel 1 global Interrupt */
N#define DMA1_Channel2_IRQChannel     ((u8)0x0C)  /* DMA1 Channel 2 global Interrupt */
N#define DMA1_Channel3_IRQChannel     ((u8)0x0D)  /* DMA1 Channel 3 global Interrupt */
N#define DMA1_Channel4_IRQChannel     ((u8)0x0E)  /* DMA1 Channel 4 global Interrupt */
N#define DMA1_Channel5_IRQChannel     ((u8)0x0F)  /* DMA1 Channel 5 global Interrupt */
N#define DMA1_Channel6_IRQChannel     ((u8)0x10)  /* DMA1 Channel 6 global Interrupt */
N#define DMA1_Channel7_IRQChannel     ((u8)0x11)  /* DMA1 Channel 7 global Interrupt */
N#define ADC1_2_IRQChannel            ((u8)0x12)  /* ADC1 et ADC2 global Interrupt */
N#define USB_HP_CAN_TX_IRQChannel     ((u8)0x13)  /* USB High Priority or CAN TX Interrupts */
N#define USB_LP_CAN_RX0_IRQChannel    ((u8)0x14)  /* USB Low Priority or CAN RX0 Interrupts */
N#define CAN_RX1_IRQChannel           ((u8)0x15)  /* CAN RX1 Interrupt */
N#define CAN_SCE_IRQChannel           ((u8)0x16)  /* CAN SCE Interrupt */
N#define EXTI9_5_IRQChannel           ((u8)0x17)  /* External Line[9:5] Interrupts */
N#define TIM1_BRK_IRQChannel          ((u8)0x18)  /* TIM1 Break Interrupt */
N#define TIM1_UP_IRQChannel           ((u8)0x19)  /* TIM1 Update Interrupt */
N#define TIM1_TRG_COM_IRQChannel      ((u8)0x1A)  /* TIM1 Trigger and Commutation Interrupt */
N#define TIM1_CC_IRQChannel           ((u8)0x1B)  /* TIM1 Capture Compare Interrupt */
N#define TIM2_IRQChannel              ((u8)0x1C)  /* TIM2 global Interrupt */
N#define TIM3_IRQChannel              ((u8)0x1D)  /* TIM3 global Interrupt */
N#define TIM4_IRQChannel              ((u8)0x1E)  /* TIM4 global Interrupt */
N#define I2C1_EV_IRQChannel           ((u8)0x1F)  /* I2C1 Event Interrupt */
N#define I2C1_ER_IRQChannel           ((u8)0x20)  /* I2C1 Error Interrupt */
N#define I2C2_EV_IRQChannel           ((u8)0x21)  /* I2C2 Event Interrupt */
N#define I2C2_ER_IRQChannel           ((u8)0x22)  /* I2C2 Error Interrupt */
N#define SPI1_IRQChannel              ((u8)0x23)  /* SPI1 global Interrupt */
N#define SPI2_IRQChannel              ((u8)0x24)  /* SPI2 global Interrupt */
N#define USART1_IRQChannel            ((u8)0x25)  /* USART1 global Interrupt */
N#define USART2_IRQChannel            ((u8)0x26)  /* USART2 global Interrupt */
N#define USART3_IRQChannel            ((u8)0x27)  /* USART3 global Interrupt */
N#define EXTI15_10_IRQChannel         ((u8)0x28)  /* External Line[15:10] Interrupts */
N#define RTCAlarm_IRQChannel          ((u8)0x29)  /* RTC Alarm through EXTI Line Interrupt */
N#define USBWakeUp_IRQChannel         ((u8)0x2A)  /* USB WakeUp from suspend through EXTI Line Interrupt */
N#define TIM8_BRK_IRQChannel          ((u8)0x2B)  /* TIM8 Break Interrupt */
N#define TIM8_UP_IRQChannel           ((u8)0x2C)  /* TIM8 Update Interrupt */
N#define TIM8_TRG_COM_IRQChannel      ((u8)0x2D)  /* TIM8 Trigger and Commutation Interrupt */
N#define TIM8_CC_IRQChannel           ((u8)0x2E)  /* TIM8 Capture Compare Interrupt */
N#define ADC3_IRQChannel              ((u8)0x2F)  /* ADC3 global Interrupt */
N#define FSMC_IRQChannel              ((u8)0x30)  /* FSMC global Interrupt */
N#define SDIO_IRQChannel              ((u8)0x31)  /* SDIO global Interrupt */
N#define TIM5_IRQChannel              ((u8)0x32)  /* TIM5 global Interrupt */
N#define SPI3_IRQChannel              ((u8)0x33)  /* SPI3 global Interrupt */
N#define UART4_IRQChannel             ((u8)0x34)  /* UART4 global Interrupt */
N#define UART5_IRQChannel             ((u8)0x35)  /* UART5 global Interrupt */
N#define TIM6_IRQChannel              ((u8)0x36)  /* TIM6 global Interrupt */
N#define TIM7_IRQChannel              ((u8)0x37)  /* TIM7 global Interrupt */
N#define DMA2_Channel1_IRQChannel     ((u8)0x38)  /* DMA2 Channel 1 global Interrupt */
N#define DMA2_Channel2_IRQChannel     ((u8)0x39)  /* DMA2 Channel 2 global Interrupt */
N#define DMA2_Channel3_IRQChannel     ((u8)0x3A)  /* DMA2 Channel 3 global Interrupt */
N#define DMA2_Channel4_5_IRQChannel   ((u8)0x3B)  /* DMA2 Channel 4 and DMA2 Channel 5 global Interrupt */
N
N
N#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) || \
N                                      ((CHANNEL) == PVD_IRQChannel) || \
N                                      ((CHANNEL) == TAMPER_IRQChannel) || \
N                                      ((CHANNEL) == RTC_IRQChannel) || \
N                                      ((CHANNEL) == FLASH_IRQChannel) || \
N                                      ((CHANNEL) == RCC_IRQChannel) || \
N                                      ((CHANNEL) == EXTI0_IRQChannel) || \
N                                      ((CHANNEL) == EXTI1_IRQChannel) || \
N                                      ((CHANNEL) == EXTI2_IRQChannel) || \
N                                      ((CHANNEL) == EXTI3_IRQChannel) || \
N                                      ((CHANNEL) == EXTI4_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel1_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel2_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel3_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel4_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel5_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel6_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel7_IRQChannel) || \
N                                      ((CHANNEL) == ADC1_2_IRQChannel) || \
N                                      ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) || \
N                                      ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) || \
N                                      ((CHANNEL) == CAN_RX1_IRQChannel) || \
N                                      ((CHANNEL) == CAN_SCE_IRQChannel) || \
N                                      ((CHANNEL) == EXTI9_5_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_BRK_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_UP_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_TRG_COM_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_CC_IRQChannel) || \
N                                      ((CHANNEL) == TIM2_IRQChannel) || \
N                                      ((CHANNEL) == TIM3_IRQChannel) || \
N                                      ((CHANNEL) == TIM4_IRQChannel) || \
N                                      ((CHANNEL) == I2C1_EV_IRQChannel) || \
N                                      ((CHANNEL) == I2C1_ER_IRQChannel) || \
N                                      ((CHANNEL) == I2C2_EV_IRQChannel) || \
N                                      ((CHANNEL) == I2C2_ER_IRQChannel) || \
N                                      ((CHANNEL) == SPI1_IRQChannel) || \
N                                      ((CHANNEL) == SPI2_IRQChannel) || \
N                                      ((CHANNEL) == USART1_IRQChannel) || \
N                                      ((CHANNEL) == USART2_IRQChannel) || \
N                                      ((CHANNEL) == USART3_IRQChannel) || \
N                                      ((CHANNEL) == EXTI15_10_IRQChannel) || \
N                                      ((CHANNEL) == RTCAlarm_IRQChannel) || \
N                                      ((CHANNEL) == USBWakeUp_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_BRK_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_UP_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_TRG_COM_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_CC_IRQChannel) || \
N                                      ((CHANNEL) == ADC3_IRQChannel) || \
N                                      ((CHANNEL) == FSMC_IRQChannel) || \
N                                      ((CHANNEL) == SDIO_IRQChannel) || \
N                                      ((CHANNEL) == TIM5_IRQChannel) || \
N                                      ((CHANNEL) == SPI3_IRQChannel) || \
N                                      ((CHANNEL) == UART4_IRQChannel) || \
N                                      ((CHANNEL) == UART5_IRQChannel) || \
N                                      ((CHANNEL) == TIM6_IRQChannel) || \
N                                      ((CHANNEL) == TIM7_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel1_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel2_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel3_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
X#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) ||                                       ((CHANNEL) == PVD_IRQChannel) ||                                       ((CHANNEL) == TAMPER_IRQChannel) ||                                       ((CHANNEL) == RTC_IRQChannel) ||                                       ((CHANNEL) == FLASH_IRQChannel) ||                                       ((CHANNEL) == RCC_IRQChannel) ||                                       ((CHANNEL) == EXTI0_IRQChannel) ||                                       ((CHANNEL) == EXTI1_IRQChannel) ||                                       ((CHANNEL) == EXTI2_IRQChannel) ||                                       ((CHANNEL) == EXTI3_IRQChannel) ||                                       ((CHANNEL) == EXTI4_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel1_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel2_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel3_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel4_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel5_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel6_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel7_IRQChannel) ||                                       ((CHANNEL) == ADC1_2_IRQChannel) ||                                       ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) ||                                       ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) ||                                       ((CHANNEL) == CAN_RX1_IRQChannel) ||                                       ((CHANNEL) == CAN_SCE_IRQChannel) ||                                       ((CHANNEL) == EXTI9_5_IRQChannel) ||                                       ((CHANNEL) == TIM1_BRK_IRQChannel) ||                                       ((CHANNEL) == TIM1_UP_IRQChannel) ||                                       ((CHANNEL) == TIM1_TRG_COM_IRQChannel) ||                                       ((CHANNEL) == TIM1_CC_IRQChannel) ||                                       ((CHANNEL) == TIM2_IRQChannel) ||                                       ((CHANNEL) == TIM3_IRQChannel) ||                                       ((CHANNEL) == TIM4_IRQChannel) ||                                       ((CHANNEL) == I2C1_EV_IRQChannel) ||                                       ((CHANNEL) == I2C1_ER_IRQChannel) ||                                       ((CHANNEL) == I2C2_EV_IRQChannel) ||                                       ((CHANNEL) == I2C2_ER_IRQChannel) ||                                       ((CHANNEL) == SPI1_IRQChannel) ||                                       ((CHANNEL) == SPI2_IRQChannel) ||                                       ((CHANNEL) == USART1_IRQChannel) ||                                       ((CHANNEL) == USART2_IRQChannel) ||                                       ((CHANNEL) == USART3_IRQChannel) ||                                       ((CHANNEL) == EXTI15_10_IRQChannel) ||                                       ((CHANNEL) == RTCAlarm_IRQChannel) ||                                       ((CHANNEL) == USBWakeUp_IRQChannel) ||                                       ((CHANNEL) == TIM8_BRK_IRQChannel) ||                                       ((CHANNEL) == TIM8_UP_IRQChannel) ||                                       ((CHANNEL) == TIM8_TRG_COM_IRQChannel) ||                                       ((CHANNEL) == TIM8_CC_IRQChannel) ||                                       ((CHANNEL) == ADC3_IRQChannel) ||                                       ((CHANNEL) == FSMC_IRQChannel) ||                                       ((CHANNEL) == SDIO_IRQChannel) ||                                       ((CHANNEL) == TIM5_IRQChannel) ||                                       ((CHANNEL) == SPI3_IRQChannel) ||                                       ((CHANNEL) == UART4_IRQChannel) ||                                       ((CHANNEL) == UART5_IRQChannel) ||                                       ((CHANNEL) == TIM6_IRQChannel) ||                                       ((CHANNEL) == TIM7_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel1_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel2_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel3_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
N
N
N/* System Handlers -----------------------------------------------------------*/
N#define SystemHandler_NMI            ((u32)0x00001F) /* NMI Handler */
N#define SystemHandler_HardFault      ((u32)0x000000) /* Hard Fault Handler */
N#define SystemHandler_MemoryManage   ((u32)0x043430) /* Memory Manage Handler */
N#define SystemHandler_BusFault       ((u32)0x547931) /* Bus Fault Handler */
N#define SystemHandler_UsageFault     ((u32)0x24C232) /* Usage Fault Handler */
N#define SystemHandler_SVCall         ((u32)0x01FF40) /* SVCall Handler */
N#define SystemHandler_DebugMonitor   ((u32)0x0A0080) /* Debug Monitor Handler */
N#define SystemHandler_PSV            ((u32)0x02829C) /* PSV Handler */
N#define SystemHandler_SysTick        ((u32)0x02C39A) /* SysTick Handler */
N
N#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                           ((HANDLER) == SystemHandler_BusFault) || \
N                                           ((HANDLER) == SystemHandler_UsageFault))
X#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                            ((HANDLER) == SystemHandler_BusFault) ||                                            ((HANDLER) == SystemHandler_UsageFault))
N
N#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                             ((HANDLER) == SystemHandler_BusFault) || \
N                                             ((HANDLER) == SystemHandler_UsageFault) || \
N                                             ((HANDLER) == SystemHandler_SVCall) || \
N                                             ((HANDLER) == SystemHandler_DebugMonitor) || \
N                                             ((HANDLER) == SystemHandler_PSV) || \
N                                             ((HANDLER) == SystemHandler_SysTick))
X#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                              ((HANDLER) == SystemHandler_BusFault) ||                                              ((HANDLER) == SystemHandler_UsageFault) ||                                              ((HANDLER) == SystemHandler_SVCall) ||                                              ((HANDLER) == SystemHandler_DebugMonitor) ||                                              ((HANDLER) == SystemHandler_PSV) ||                                              ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                                ((HANDLER) == SystemHandler_BusFault) || \
N                                                ((HANDLER) == SystemHandler_SVCall))
X#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                 ((HANDLER) == SystemHandler_BusFault) ||                                                 ((HANDLER) == SystemHandler_SVCall))
N
N#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) || \
N                                                ((HANDLER) == SystemHandler_PSV) || \
N                                                ((HANDLER) == SystemHandler_SysTick))
X#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) ||                                                 ((HANDLER) == SystemHandler_PSV) ||                                                 ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) || \
N                                          ((HANDLER) == SystemHandler_SysTick))
X#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) ||                                           ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                               ((HANDLER) == SystemHandler_BusFault) || \
N                                               ((HANDLER) == SystemHandler_UsageFault) || \
N                                               ((HANDLER) == SystemHandler_SVCall) || \
N                                               ((HANDLER) == SystemHandler_DebugMonitor) || \
N                                               ((HANDLER) == SystemHandler_PSV) || \
N                                               ((HANDLER) == SystemHandler_SysTick))
X#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                ((HANDLER) == SystemHandler_BusFault) ||                                                ((HANDLER) == SystemHandler_UsageFault) ||                                                ((HANDLER) == SystemHandler_SVCall) ||                                                ((HANDLER) == SystemHandler_DebugMonitor) ||                                                ((HANDLER) == SystemHandler_PSV) ||                                                ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) || \
N                                                 ((HANDLER) == SystemHandler_MemoryManage) || \
N                                                 ((HANDLER) == SystemHandler_BusFault) || \
N                                                 ((HANDLER) == SystemHandler_UsageFault) || \
N                                                 ((HANDLER) == SystemHandler_DebugMonitor)) 
X#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) ||                                                  ((HANDLER) == SystemHandler_MemoryManage) ||                                                  ((HANDLER) == SystemHandler_BusFault) ||                                                  ((HANDLER) == SystemHandler_UsageFault) ||                                                  ((HANDLER) == SystemHandler_DebugMonitor)) 
N
N#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                                  ((HANDLER) == SystemHandler_BusFault))
X#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                   ((HANDLER) == SystemHandler_BusFault))
N
N
N/* Vector Table Base ---------------------------------------------------------*/
N#define NVIC_VectTab_RAM             ((u32)0x20000000)
N#define NVIC_VectTab_FLASH           ((u32)0x08000000)
N
N#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
N                                  ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) ||                                   ((VECTTAB) == NVIC_VectTab_FLASH))
N
N/* System Low Power ----------------------------------------------------------*/
N#define NVIC_LP_SEVONPEND            ((u8)0x10)
N#define NVIC_LP_SLEEPDEEP            ((u8)0x04)
N#define NVIC_LP_SLEEPONEXIT          ((u8)0x02)
N
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N
N/* Preemption Priority Group -------------------------------------------------*/
N#define NVIC_PriorityGroup_0         ((u32)0x700) /* 0 bits for pre-emption priority
N                                                     4 bits for subpriority */
N#define NVIC_PriorityGroup_1         ((u32)0x600) /* 1 bits for pre-emption priority
N                                                     3 bits for subpriority */
N#define NVIC_PriorityGroup_2         ((u32)0x500) /* 2 bits for pre-emption priority
N                                                     2 bits for subpriority */
N#define NVIC_PriorityGroup_3         ((u32)0x400) /* 3 bits for pre-emption priority
N                                                     1 bits for subpriority */
N#define NVIC_PriorityGroup_4         ((u32)0x300) /* 4 bits for pre-emption priority
N                                                     0 bits for subpriority */
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
N                                       ((GROUP) == NVIC_PriorityGroup_1) || \
N                                       ((GROUP) == NVIC_PriorityGroup_2) || \
N                                       ((GROUP) == NVIC_PriorityGroup_3) || \
N                                       ((GROUP) == NVIC_PriorityGroup_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) ||                                        ((GROUP) == NVIC_PriorityGroup_1) ||                                        ((GROUP) == NVIC_PriorityGroup_2) ||                                        ((GROUP) == NVIC_PriorityGroup_3) ||                                        ((GROUP) == NVIC_PriorityGroup_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x0007FFFF)
N#define IS_NVIC_BASE_PRI(PRI)   ((PRI) < 0x10)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid NVIC_DeInit(void);
Nvoid NVIC_SCBDeInit(void);
Nvoid NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SETPRIMASK(void);
Nvoid NVIC_RESETPRIMASK(void);
Nvoid NVIC_SETFAULTMASK(void);
Nvoid NVIC_RESETFAULTMASK(void);
Nvoid NVIC_BASEPRICONFIG(u32 NewPriority);
Nu32 NVIC_GetBASEPRI(void);
Nu16 NVIC_GetCurrentPendingIRQChannel(void);
NITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel);
Nvoid NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel);
Nvoid NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel);
Nu16 NVIC_GetCurrentActiveHandler(void);
NITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel);
Nu32 NVIC_GetCPUID(void);
Nvoid NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset);
Nvoid NVIC_GenerateSystemReset(void);
Nvoid NVIC_GenerateCoreReset(void);
Nvoid NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState);
Nvoid NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState);
Nvoid NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
N                                      u8 SystemHandlerSubPriority);
NITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler);
Nvoid NVIC_SetSystemHandlerPendingBit(u32 SystemHandler);
Nvoid NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler);
NITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler);
Nu32 NVIC_GetFaultHandlerSources(u32 SystemHandler);
Nu32 NVIC_GetFaultAddress(u32 SystemHandler);
N
N#endif /* __STM32F10x_NVIC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 78 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_NVIC */
N
N#ifdef _PWR
N  #include "stm32f10x_pwr.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_pwr.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_pwr.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      PWR firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_PWR_H
N#define __STM32F10x_PWR_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* PVD detection level */
N#define PWR_PVDLevel_2V2          ((u32)0x00000000)
N#define PWR_PVDLevel_2V3          ((u32)0x00000020)
N#define PWR_PVDLevel_2V4          ((u32)0x00000040)
N#define PWR_PVDLevel_2V5          ((u32)0x00000060)
N#define PWR_PVDLevel_2V6          ((u32)0x00000080)
N#define PWR_PVDLevel_2V7          ((u32)0x000000A0)
N#define PWR_PVDLevel_2V8          ((u32)0x000000C0)
N#define PWR_PVDLevel_2V9          ((u32)0x000000E0)
N
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)||                                  ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)||                                  ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)||                                  ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
N
N/* Regulator state is STOP mode */
N#define PWR_Regulator_ON          ((u32)0x00000000)
N#define PWR_Regulator_LowPower    ((u32)0x00000001)
N
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
N                                     ((REGULATOR) == PWR_Regulator_LowPower))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) ||                                      ((REGULATOR) == PWR_Regulator_LowPower))
N
N/* STOP mode entry */
N#define PWR_STOPEntry_WFI         ((u8)0x01)
N#define PWR_STOPEntry_WFE         ((u8)0x02)
N
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
N 
N/* PWR Flag */
N#define PWR_FLAG_WU               ((u32)0x00000001)
N#define PWR_FLAG_SB               ((u32)0x00000002)
N#define PWR_FLAG_PVDO             ((u32)0x00000004)
N
N#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
N                               ((FLAG) == PWR_FLAG_PVDO))
X#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) ||                                ((FLAG) == PWR_FLAG_PVDO))
N#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid PWR_DeInit(void);
Nvoid PWR_BackupAccessCmd(FunctionalState NewState);
Nvoid PWR_PVDCmd(FunctionalState NewState);
Nvoid PWR_PVDLevelConfig(u32 PWR_PVDLevel);
Nvoid PWR_WakeUpPinCmd(FunctionalState NewState);
Nvoid PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry);
Nvoid PWR_EnterSTANDBYMode(void);
NFlagStatus PWR_GetFlagStatus(u32 PWR_FLAG);
Nvoid PWR_ClearFlag(u32 PWR_FLAG);
N
N#endif /* __STM32F10x_PWR_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 82 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_PWR */
N
N#ifdef _RCC
N  #include "stm32f10x_rcc.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_rcc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_rcc.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      RCC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RCC_H
N#define __STM32F10x_RCC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
Ntypedef struct
N{
N  u32 SYSCLK_Frequency;
N  u32 HCLK_Frequency;
N  u32 PCLK1_Frequency;
N  u32 PCLK2_Frequency;
N  u32 ADCCLK_Frequency;
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* HSE configuration */
N#define RCC_HSE_OFF                      ((u32)0x00000000)
N#define RCC_HSE_ON                       ((u32)0x00010000)
N#define RCC_HSE_Bypass                   ((u32)0x00040000)
N
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/* PLL entry clock source */
N#define RCC_PLLSource_HSI_Div2           ((u32)0x00000000)
N#define RCC_PLLSource_HSE_Div1           ((u32)0x00010000)
N#define RCC_PLLSource_HSE_Div2           ((u32)0x00030000)
N
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div1) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div2))
N
N/* PLL multiplication factor */
N#define RCC_PLLMul_2                     ((u32)0x00000000)
N#define RCC_PLLMul_3                     ((u32)0x00040000)
N#define RCC_PLLMul_4                     ((u32)0x00080000)
N#define RCC_PLLMul_5                     ((u32)0x000C0000)
N#define RCC_PLLMul_6                     ((u32)0x00100000)
N#define RCC_PLLMul_7                     ((u32)0x00140000)
N#define RCC_PLLMul_8                     ((u32)0x00180000)
N#define RCC_PLLMul_9                     ((u32)0x001C0000)
N#define RCC_PLLMul_10                    ((u32)0x00200000)
N#define RCC_PLLMul_11                    ((u32)0x00240000)
N#define RCC_PLLMul_12                    ((u32)0x00280000)
N#define RCC_PLLMul_13                    ((u32)0x002C0000)
N#define RCC_PLLMul_14                    ((u32)0x00300000)
N#define RCC_PLLMul_15                    ((u32)0x00340000)
N#define RCC_PLLMul_16                    ((u32)0x00380000)
N
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
N
N/* System clock source */
N#define RCC_SYSCLKSource_HSI             ((u32)0x00000000)
N#define RCC_SYSCLKSource_HSE             ((u32)0x00000001)
N#define RCC_SYSCLKSource_PLLCLK          ((u32)0x00000002)
N
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N
N/* AHB clock source */
N#define RCC_SYSCLK_Div1                  ((u32)0x00000000)
N#define RCC_SYSCLK_Div2                  ((u32)0x00000080)
N#define RCC_SYSCLK_Div4                  ((u32)0x00000090)
N#define RCC_SYSCLK_Div8                  ((u32)0x000000A0)
N#define RCC_SYSCLK_Div16                 ((u32)0x000000B0)
N#define RCC_SYSCLK_Div64                 ((u32)0x000000C0)
N#define RCC_SYSCLK_Div128                ((u32)0x000000D0)
N#define RCC_SYSCLK_Div256                ((u32)0x000000E0)
N#define RCC_SYSCLK_Div512                ((u32)0x000000F0)
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N
N/* APB1/APB2 clock source */
N#define RCC_HCLK_Div1                    ((u32)0x00000000)
N#define RCC_HCLK_Div2                    ((u32)0x00000400)
N#define RCC_HCLK_Div4                    ((u32)0x00000500)
N#define RCC_HCLK_Div8                    ((u32)0x00000600)
N#define RCC_HCLK_Div16                   ((u32)0x00000700)
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N
N/* RCC Interrupt source */
N#define RCC_IT_LSIRDY                    ((u8)0x01)
N#define RCC_IT_LSERDY                    ((u8)0x02)
N#define RCC_IT_HSIRDY                    ((u8)0x04)
N#define RCC_IT_HSERDY                    ((u8)0x08)
N#define RCC_IT_PLLRDY                    ((u8)0x10)
N#define RCC_IT_CSS                       ((u8)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (u8)0xE0) == 0x00) && ((IT) != 0x00))
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
N#define IS_RCC_CLEAR_IT(IT) ((((IT) & (u8)0x60) == 0x00) && ((IT) != 0x00))
N
N/* USB clock source */
N#define RCC_USBCLKSource_PLLCLK_1Div5    ((u8)0x00)
N#define RCC_USBCLKSource_PLLCLK_Div1     ((u8)0x01)
N
N#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
N                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
X#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) ||                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
N
N/* ADC clock source */
N#define RCC_PCLK2_Div2                   ((u32)0x00000000)
N#define RCC_PCLK2_Div4                   ((u32)0x00004000)
N#define RCC_PCLK2_Div6                   ((u32)0x00008000)
N#define RCC_PCLK2_Div8                   ((u32)0x0000C000)
N
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
N                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) ||                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
N
N/* LSE configuration */
N#define RCC_LSE_OFF                      ((u8)0x00)
N#define RCC_LSE_ON                       ((u8)0x01)
N#define RCC_LSE_Bypass                   ((u8)0x04)
N
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N
N/* RTC clock source */
N#define RCC_RTCCLKSource_LSE             ((u32)0x00000100)
N#define RCC_RTCCLKSource_LSI             ((u32)0x00000200)
N#define RCC_RTCCLKSource_HSE_Div128      ((u32)0x00000300)
N
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
N
N/* AHB peripheral */
N#define RCC_AHBPeriph_DMA1               ((u32)0x00000001)
N#define RCC_AHBPeriph_DMA2               ((u32)0x00000002)
N#define RCC_AHBPeriph_SRAM               ((u32)0x00000004)
N#define RCC_AHBPeriph_FLITF              ((u32)0x00000010)
N#define RCC_AHBPeriph_CRC                ((u32)0x00000040)
N#define RCC_AHBPeriph_FSMC               ((u32)0x00000100)
N#define RCC_AHBPeriph_SDIO               ((u32)0x00000400)
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB2 peripheral */
N#define RCC_APB2Periph_AFIO              ((u32)0x00000001)
N#define RCC_APB2Periph_GPIOA             ((u32)0x00000004)
N#define RCC_APB2Periph_GPIOB             ((u32)0x00000008)
N#define RCC_APB2Periph_GPIOC             ((u32)0x00000010)
N#define RCC_APB2Periph_GPIOD             ((u32)0x00000020)
N#define RCC_APB2Periph_GPIOE             ((u32)0x00000040)
N#define RCC_APB2Periph_GPIOF             ((u32)0x00000080)
N#define RCC_APB2Periph_GPIOG             ((u32)0x00000100)
N#define RCC_APB2Periph_ADC1              ((u32)0x00000200)
N#define RCC_APB2Periph_ADC2              ((u32)0x00000400)
N#define RCC_APB2Periph_TIM1              ((u32)0x00000800)
N#define RCC_APB2Periph_SPI1              ((u32)0x00001000)
N#define RCC_APB2Periph_TIM8              ((u32)0x00002000)
N#define RCC_APB2Periph_USART1            ((u32)0x00004000)
N#define RCC_APB2Periph_ADC3              ((u32)0x00008000)
N#define RCC_APB2Periph_ALL               ((u32)0x0000FFFD)
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFF0002) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB1 peripheral */
N#define RCC_APB1Periph_TIM2              ((u32)0x00000001)
N#define RCC_APB1Periph_TIM3              ((u32)0x00000002)
N#define RCC_APB1Periph_TIM4              ((u32)0x00000004)
N#define RCC_APB1Periph_TIM5              ((u32)0x00000008)
N#define RCC_APB1Periph_TIM6              ((u32)0x00000010)
N#define RCC_APB1Periph_TIM7              ((u32)0x00000020)
N#define RCC_APB1Periph_WWDG              ((u32)0x00000800)
N#define RCC_APB1Periph_SPI2              ((u32)0x00004000)
N#define RCC_APB1Periph_SPI3              ((u32)0x00008000)
N#define RCC_APB1Periph_USART2            ((u32)0x00020000)
N#define RCC_APB1Periph_USART3            ((u32)0x00040000)
N#define RCC_APB1Periph_UART4             ((u32)0x00080000)
N#define RCC_APB1Periph_UART5             ((u32)0x00100000)
N#define RCC_APB1Periph_I2C1              ((u32)0x00200000)
N#define RCC_APB1Periph_I2C2              ((u32)0x00400000)
N#define RCC_APB1Periph_USB               ((u32)0x00800000)
N#define RCC_APB1Periph_CAN               ((u32)0x02000000)
N#define RCC_APB1Periph_BKP               ((u32)0x08000000)
N#define RCC_APB1Periph_PWR               ((u32)0x10000000)
N#define RCC_APB1Periph_DAC               ((u32)0x20000000)
N#define RCC_APB1Periph_ALL               ((u32)0x3AFEC83F)
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0xC50137C0) == 0x00) && ((PERIPH) != 0x00))
N
N/* Clock source to output on MCO pin */
N#define RCC_MCO_NoClock                  ((u8)0x00)
N#define RCC_MCO_SYSCLK                   ((u8)0x04)
N#define RCC_MCO_HSI                      ((u8)0x05)
N#define RCC_MCO_HSE                      ((u8)0x06)
N#define RCC_MCO_PLLCLK_Div2              ((u8)0x07)
N
N#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
N                         ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
N                         ((MCO) == RCC_MCO_PLLCLK_Div2))
X#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) ||                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) ||                          ((MCO) == RCC_MCO_PLLCLK_Div2))
N
N/* RCC Flag */
N#define RCC_FLAG_HSIRDY                  ((u8)0x20)
N#define RCC_FLAG_HSERDY                  ((u8)0x31)
N#define RCC_FLAG_PLLRDY                  ((u8)0x39)
N#define RCC_FLAG_LSERDY                  ((u8)0x41)
N#define RCC_FLAG_LSIRDY                  ((u8)0x61)
N#define RCC_FLAG_PINRST                  ((u8)0x7A)
N#define RCC_FLAG_PORRST                  ((u8)0x7B)
N#define RCC_FLAG_SFTRST                  ((u8)0x7C)
N#define RCC_FLAG_IWDGRST                 ((u8)0x7D)
N#define RCC_FLAG_WWDGRST                 ((u8)0x7E)
N#define RCC_FLAG_LPWRRST                 ((u8)0x7F)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
N                           ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
N                           ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
N                           ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
N                           ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
N                           ((FLAG) == RCC_FLAG_LPWRRST))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) ||                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) ||                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)||                            ((FLAG) == RCC_FLAG_LPWRRST))
N
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid RCC_DeInit(void);
Nvoid RCC_HSEConfig(u32 RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_SYSCLKConfig(u32 RCC_SYSCLKSource);
Nu8 RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(u32 RCC_SYSCLK);
Nvoid RCC_PCLK1Config(u32 RCC_HCLK);
Nvoid RCC_PCLK2Config(u32 RCC_HCLK);
Nvoid RCC_ITConfig(u8 RCC_IT, FunctionalState NewState);
Nvoid RCC_USBCLKConfig(u32 RCC_USBCLKSource);
Nvoid RCC_ADCCLKConfig(u32 RCC_PCLK2);
Nvoid RCC_LSEConfig(u8 RCC_LSE);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_RTCCLKConfig(u32 RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
Nvoid RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_MCOConfig(u8 RCC_MCO);
NFlagStatus RCC_GetFlagStatus(u8 RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(u8 RCC_IT);
Nvoid RCC_ClearITPendingBit(u8 RCC_IT);
N
N#endif /* __STM32F10x_RCC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 86 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_RCC */
N
N#ifdef _RTC
N  #include "stm32f10x_rtc.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_rtc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_rtc.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      RTC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RTC_H
N#define __STM32F10x_RTC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* RTC interrupts define -----------------------------------------------------*/
N#define RTC_IT_OW            ((u16)0x0004)  /* Overflow interrupt */
N#define RTC_IT_ALR           ((u16)0x0002)  /* Alarm interrupt */
N#define RTC_IT_SEC           ((u16)0x0001)  /* Second interrupt */
N
N#define IS_RTC_IT(IT) ((((IT) & (u16)0xFFF8) == 0x00) && ((IT) != 0x00))
N
N#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) || \
N                           ((IT) == RTC_IT_SEC))
X#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) ||                            ((IT) == RTC_IT_SEC))
N                                                                     
N/* RTC interrupts flags ------------------------------------------------------*/
N#define RTC_FLAG_RTOFF       ((u16)0x0020)  /* RTC Operation OFF flag */
N#define RTC_FLAG_RSF         ((u16)0x0008)  /* Registers Synchronized flag */
N#define RTC_FLAG_OW          ((u16)0x0004)  /* Overflow flag */
N#define RTC_FLAG_ALR         ((u16)0x0002)  /* Alarm flag */
N#define RTC_FLAG_SEC         ((u16)0x0001)  /* Second flag */
N
N#define IS_RTC_CLEAR_FLAG(FLAG) ((((FLAG) & (u16)0xFFF0) == 0x00) && ((FLAG) != 0x00))
N
N#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) || \
N                               ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) || \
N                               ((FLAG) == RTC_FLAG_SEC))
X#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) ||                                ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) ||                                ((FLAG) == RTC_FLAG_SEC))
N
N#define IS_RTC_PRESCALER(PRESCALER) ((PRESCALER) <= 0xFFFFF)
N                           
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid RTC_ITConfig(u16 RTC_IT, FunctionalState NewState);
Nvoid RTC_EnterConfigMode(void);
Nvoid RTC_ExitConfigMode(void);
Nu32  RTC_GetCounter(void);
Nvoid RTC_SetCounter(u32 CounterValue);
Nvoid RTC_SetPrescaler(u32 PrescalerValue);
Nvoid RTC_SetAlarm(u32 AlarmValue);
Nu32  RTC_GetDivider(void);
Nvoid RTC_WaitForLastTask(void);
Nvoid RTC_WaitForSynchro(void);
NFlagStatus RTC_GetFlagStatus(u16 RTC_FLAG);
Nvoid RTC_ClearFlag(u16 RTC_FLAG);
NITStatus RTC_GetITStatus(u16 RTC_IT);
Nvoid RTC_ClearITPendingBit(u16 RTC_IT);
N
N#endif /* __STM32F10x_RTC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 90 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_RTC */
N
N#ifdef _SDIO
N  #include "stm32f10x_sdio.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_sdio.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_sdio.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      SDIO firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_SDIO_H
N#define __STM32F10x_SDIO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
Ntypedef struct
N{
N  u8 SDIO_ClockDiv;
N  u32 SDIO_ClockEdge;
N  u32 SDIO_ClockBypass;
N  u32 SDIO_ClockPowerSave;
N  u32 SDIO_BusWide;
N  u32 SDIO_HardwareFlowControl;
N} SDIO_InitTypeDef;
N
Ntypedef struct
N{
N  u32 SDIO_Argument;
N  u32 SDIO_CmdIndex;
N  u32 SDIO_Response;
N  u32 SDIO_Wait;
N  u32 SDIO_CPSM;
N} SDIO_CmdInitTypeDef;
N
Ntypedef struct
N{
N  u32 SDIO_DataTimeOut;
N  u32 SDIO_DataLength;
N  u32 SDIO_DataBlockSize;
N  u32 SDIO_TransferDir;
N  u32 SDIO_TransferMode;
N  u32 SDIO_DPSM;
N} SDIO_DataInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* SDIO Clock Edge -----------------------------------------------------------*/
N#define SDIO_ClockEdge_Rising               ((u32)0x00000000)
N#define SDIO_ClockEdge_Falling              ((u32)0x00002000)
N
N#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
N                                  ((EDGE) == SDIO_ClockEdge_Falling))
X#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) ||                                   ((EDGE) == SDIO_ClockEdge_Falling))
N/* SDIO Clock Bypass ----------------------------------------------------------*/                                  
N#define SDIO_ClockBypass_Disable             ((u32)0x00000000)
N#define SDIO_ClockBypass_Enable              ((u32)0x00000400)    
N
N#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
N                                     ((BYPASS) == SDIO_ClockBypass_Enable))                             
X#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) ||                                      ((BYPASS) == SDIO_ClockBypass_Enable))                             
N
N/* SDIO Clock Power Save  ----------------------------------------------------*/ 
N#define SDIO_ClockPowerSave_Disable         ((u32)0x00000000)
N#define SDIO_ClockPowerSave_Enable          ((u32)0x00000200) 
N
N#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
N                                        ((SAVE) == SDIO_ClockPowerSave_Enable))
X#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) ||                                         ((SAVE) == SDIO_ClockPowerSave_Enable))
N
N/* SDIO Bus Wide -------------------------------------------------------------*/
N#define SDIO_BusWide_1b                     ((u32)0x00000000)
N#define SDIO_BusWide_4b                     ((u32)0x00000800)
N#define SDIO_BusWide_8b                     ((u32)0x00001000)
N
N#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
N                                ((WIDE) == SDIO_BusWide_8b))
X#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) ||                                 ((WIDE) == SDIO_BusWide_8b))
N                                
N/* SDIO Hardware Flow Control  -----------------------------------------------*/ 
N#define SDIO_HardwareFlowControl_Disable    ((u32)0x00000000)
N#define SDIO_HardwareFlowControl_Enable     ((u32)0x00004000)
N
N#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
N                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))
X#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) ||                                                 ((CONTROL) == SDIO_HardwareFlowControl_Enable))
N                                  
N/* SDIO Power State ----------------------------------------------------------*/
N#define SDIO_PowerState_OFF                 ((u32)0x00000000)
N#define SDIO_PowerState_ON                  ((u32)0x00000003)
N
N#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON)) 
N
N/* SDIO Interrupt soucres ----------------------------------------------------*/
N#define SDIO_IT_CCRCFAIL                    ((u32)0x00000001)
N#define SDIO_IT_DCRCFAIL                    ((u32)0x00000002)
N#define SDIO_IT_CTIMEOUT                    ((u32)0x00000004)
N#define SDIO_IT_DTIMEOUT                    ((u32)0x00000008)
N#define SDIO_IT_TXUNDERR                    ((u32)0x00000010)
N#define SDIO_IT_RXOVERR                     ((u32)0x00000020)
N#define SDIO_IT_CMDREND                     ((u32)0x00000040)
N#define SDIO_IT_CMDSENT                     ((u32)0x00000080)
N#define SDIO_IT_DATAEND                     ((u32)0x00000100)
N#define SDIO_IT_STBITERR                    ((u32)0x00000200)
N#define SDIO_IT_DBCKEND                     ((u32)0x00000400)
N#define SDIO_IT_CMDACT                      ((u32)0x00000800)
N#define SDIO_IT_TXACT                       ((u32)0x00001000)
N#define SDIO_IT_RXACT                       ((u32)0x00002000)
N#define SDIO_IT_TXFIFOHE                    ((u32)0x00004000)
N#define SDIO_IT_RXFIFOHF                    ((u32)0x00008000)
N#define SDIO_IT_TXFIFOF                     ((u32)0x00010000)
N#define SDIO_IT_RXFIFOF                     ((u32)0x00020000)
N#define SDIO_IT_TXFIFOE                     ((u32)0x00040000)
N#define SDIO_IT_RXFIFOE                     ((u32)0x00080000)
N#define SDIO_IT_TXDAVL                      ((u32)0x00100000)
N#define SDIO_IT_RXDAVL                      ((u32)0x00200000)
N#define SDIO_IT_SDIOIT                      ((u32)0x00400000)
N#define SDIO_IT_CEATAEND                    ((u32)0x00800000)
N
N#define IS_SDIO_IT(IT) ((((IT) & (u32)0xFF000000) == 0x00) && ((IT) != (u32)0x00))
N
N/* SDIO Command Index  -------------------------------------------------------*/
N#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
N
N/* SDIO Response Type --------------------------------------------------------*/
N#define SDIO_Response_No                    ((u32)0x00000000)
N#define SDIO_Response_Short                 ((u32)0x00000040)
N#define SDIO_Response_Long                  ((u32)0x000000C0)
N
N#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
N                                    ((RESPONSE) == SDIO_Response_Short) || \
N                                    ((RESPONSE) == SDIO_Response_Long))
X#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) ||                                     ((RESPONSE) == SDIO_Response_Short) ||                                     ((RESPONSE) == SDIO_Response_Long))
N
N/* SDIO Wait Interrupt State -------------------------------------------------*/
N#define SDIO_Wait_No                        ((u32)0x00000000) /* SDIO No Wait, TimeOut is enabled */
N#define SDIO_Wait_IT                        ((u32)0x00000100) /* SDIO Wait Interrupt Request */
N#define SDIO_Wait_Pend                      ((u32)0x00000200) /* SDIO Wait End of transfer */
N
N#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
N                            ((WAIT) == SDIO_Wait_Pend))
X#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) ||                             ((WAIT) == SDIO_Wait_Pend))
N
N/* SDIO CPSM State -----------------------------------------------------------*/
N#define SDIO_CPSM_Disable                    ((u32)0x00000000)
N#define SDIO_CPSM_Enable                     ((u32)0x00000400)
N
N#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
N
N/* SDIO Response Registers ---------------------------------------------------*/
N#define SDIO_RESP1                          ((u32)0x00000000)
N#define SDIO_RESP2                          ((u32)0x00000004)
N#define SDIO_RESP3                          ((u32)0x00000008)
N#define SDIO_RESP4                          ((u32)0x0000000C)
N
N#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
N                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
X#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) ||                             ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
N
N/* SDIO Data Length ----------------------------------------------------------*/
N#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
N
N/* SDIO Data Block Size ------------------------------------------------------*/
N#define SDIO_DataBlockSize_1b               ((u32)0x00000000)
N#define SDIO_DataBlockSize_2b               ((u32)0x00000010)
N#define SDIO_DataBlockSize_4b               ((u32)0x00000020)
N#define SDIO_DataBlockSize_8b               ((u32)0x00000030)
N#define SDIO_DataBlockSize_16b              ((u32)0x00000040)
N#define SDIO_DataBlockSize_32b              ((u32)0x00000050)
N#define SDIO_DataBlockSize_64b              ((u32)0x00000060)
N#define SDIO_DataBlockSize_128b             ((u32)0x00000070)
N#define SDIO_DataBlockSize_256b             ((u32)0x00000080)
N#define SDIO_DataBlockSize_512b             ((u32)0x00000090)
N#define SDIO_DataBlockSize_1024b            ((u32)0x000000A0)
N#define SDIO_DataBlockSize_2048b            ((u32)0x000000B0)
N#define SDIO_DataBlockSize_4096b            ((u32)0x000000C0)
N#define SDIO_DataBlockSize_8192b            ((u32)0x000000D0)
N#define SDIO_DataBlockSize_16384b           ((u32)0x000000E0)
N
N#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_2b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_4b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_8b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_16b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_32b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_64b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_128b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_256b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_512b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \
N                                  ((SIZE) == SDIO_DataBlockSize_16384b)) 
X#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) ||                                   ((SIZE) == SDIO_DataBlockSize_2b) ||                                   ((SIZE) == SDIO_DataBlockSize_4b) ||                                   ((SIZE) == SDIO_DataBlockSize_8b) ||                                   ((SIZE) == SDIO_DataBlockSize_16b) ||                                   ((SIZE) == SDIO_DataBlockSize_32b) ||                                   ((SIZE) == SDIO_DataBlockSize_64b) ||                                   ((SIZE) == SDIO_DataBlockSize_128b) ||                                   ((SIZE) == SDIO_DataBlockSize_256b) ||                                   ((SIZE) == SDIO_DataBlockSize_512b) ||                                   ((SIZE) == SDIO_DataBlockSize_1024b) ||                                   ((SIZE) == SDIO_DataBlockSize_2048b) ||                                   ((SIZE) == SDIO_DataBlockSize_4096b) ||                                   ((SIZE) == SDIO_DataBlockSize_8192b) ||                                   ((SIZE) == SDIO_DataBlockSize_16384b)) 
N
N/* SDIO Transfer Direction ---------------------------------------------------*/
N#define SDIO_TransferDir_ToCard             ((u32)0x00000000)
N#define SDIO_TransferDir_ToSDIO             ((u32)0x00000002)
N
N#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
N                                   ((DIR) == SDIO_TransferDir_ToSDIO))  
X#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) ||                                    ((DIR) == SDIO_TransferDir_ToSDIO))  
N
N/* SDIO Transfer Type --------------------------------------------------------*/
N#define SDIO_TransferMode_Block             ((u32)0x00000000)
N#define SDIO_TransferMode_Stream            ((u32)0x00000004)
N
N#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
N                                     ((MODE) == SDIO_TransferMode_Block))                                
X#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) ||                                      ((MODE) == SDIO_TransferMode_Block))                                
N
N/* SDIO DPSM State -----------------------------------------------------------*/
N#define SDIO_DPSM_Disable                    ((u32)0x00000000)
N#define SDIO_DPSM_Enable                     ((u32)0x00000001)
N
N#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
N
N/* SDIO Flags ----------------------------------------------------------------*/
N#define SDIO_FLAG_CCRCFAIL                  ((u32)0x00000001)
N#define SDIO_FLAG_DCRCFAIL                  ((u32)0x00000002)
N#define SDIO_FLAG_CTIMEOUT                  ((u32)0x00000004)
N#define SDIO_FLAG_DTIMEOUT                  ((u32)0x00000008)
N#define SDIO_FLAG_TXUNDERR                  ((u32)0x00000010)
N#define SDIO_FLAG_RXOVERR                   ((u32)0x00000020)
N#define SDIO_FLAG_CMDREND                   ((u32)0x00000040)
N#define SDIO_FLAG_CMDSENT                   ((u32)0x00000080)
N#define SDIO_FLAG_DATAEND                   ((u32)0x00000100)
N#define SDIO_FLAG_STBITERR                  ((u32)0x00000200)
N#define SDIO_FLAG_DBCKEND                   ((u32)0x00000400)
N#define SDIO_FLAG_CMDACT                    ((u32)0x00000800)
N#define SDIO_FLAG_TXACT                     ((u32)0x00001000)
N#define SDIO_FLAG_RXACT                     ((u32)0x00002000)
N#define SDIO_FLAG_TXFIFOHE                  ((u32)0x00004000)
N#define SDIO_FLAG_RXFIFOHF                  ((u32)0x00008000)
N#define SDIO_FLAG_TXFIFOF                   ((u32)0x00010000)
N#define SDIO_FLAG_RXFIFOF                   ((u32)0x00020000)
N#define SDIO_FLAG_TXFIFOE                   ((u32)0x00040000)
N#define SDIO_FLAG_RXFIFOE                   ((u32)0x00080000)
N#define SDIO_FLAG_TXDAVL                    ((u32)0x00100000)
N#define SDIO_FLAG_RXDAVL                    ((u32)0x00200000)
N#define SDIO_FLAG_SDIOIT                    ((u32)0x00400000)
N#define SDIO_FLAG_CEATAEND                  ((u32)0x00800000)
N
N#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
N                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
N                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
N                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \
N                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \
N                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \
N                            ((FLAG)  == SDIO_FLAG_CMDREND) || \
N                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \
N                            ((FLAG)  == SDIO_FLAG_DATAEND) || \
N                            ((FLAG)  == SDIO_FLAG_STBITERR) || \
N                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \
N                            ((FLAG)  == SDIO_FLAG_CMDACT) || \
N                            ((FLAG)  == SDIO_FLAG_TXACT) || \
N                            ((FLAG)  == SDIO_FLAG_RXACT) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \
N                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \
N                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \
N                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \
N                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \
N                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \
N                            ((FLAG)  == SDIO_FLAG_CEATAEND))
X#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) ||                             ((FLAG)  == SDIO_FLAG_DCRCFAIL) ||                             ((FLAG)  == SDIO_FLAG_CTIMEOUT) ||                             ((FLAG)  == SDIO_FLAG_DTIMEOUT) ||                             ((FLAG)  == SDIO_FLAG_TXUNDERR) ||                             ((FLAG)  == SDIO_FLAG_RXOVERR) ||                             ((FLAG)  == SDIO_FLAG_CMDREND) ||                             ((FLAG)  == SDIO_FLAG_CMDSENT) ||                             ((FLAG)  == SDIO_FLAG_DATAEND) ||                             ((FLAG)  == SDIO_FLAG_STBITERR) ||                             ((FLAG)  == SDIO_FLAG_DBCKEND) ||                             ((FLAG)  == SDIO_FLAG_CMDACT) ||                             ((FLAG)  == SDIO_FLAG_TXACT) ||                             ((FLAG)  == SDIO_FLAG_RXACT) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOHE) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOHF) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOF) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOF) ||                             ((FLAG)  == SDIO_FLAG_TXFIFOE) ||                             ((FLAG)  == SDIO_FLAG_RXFIFOE) ||                             ((FLAG)  == SDIO_FLAG_TXDAVL) ||                             ((FLAG)  == SDIO_FLAG_RXDAVL) ||                             ((FLAG)  == SDIO_FLAG_SDIOIT) ||                             ((FLAG)  == SDIO_FLAG_CEATAEND))
N
N#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (u32)0xFF3FF800) == 0x00) && ((FLAG) != (u32)0x00))
N
N#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
N                            ((IT)  == SDIO_IT_DCRCFAIL) || \
N                            ((IT)  == SDIO_IT_CTIMEOUT) || \
N                            ((IT)  == SDIO_IT_DTIMEOUT) || \
N                            ((IT)  == SDIO_IT_TXUNDERR) || \
N                            ((IT)  == SDIO_IT_RXOVERR) || \
N                            ((IT)  == SDIO_IT_CMDREND) || \
N                            ((IT)  == SDIO_IT_CMDSENT) || \
N                            ((IT)  == SDIO_IT_DATAEND) || \
N                            ((IT)  == SDIO_IT_STBITERR) || \
N                            ((IT)  == SDIO_IT_DBCKEND) || \
N                            ((IT)  == SDIO_IT_CMDACT) || \
N                            ((IT)  == SDIO_IT_TXACT) || \
N                            ((IT)  == SDIO_IT_RXACT) || \
N                            ((IT)  == SDIO_IT_TXFIFOHE) || \
N                            ((IT)  == SDIO_IT_RXFIFOHF) || \
N                            ((IT)  == SDIO_IT_TXFIFOF) || \
N                            ((IT)  == SDIO_IT_RXFIFOF) || \
N                            ((IT)  == SDIO_IT_TXFIFOE) || \
N                            ((IT)  == SDIO_IT_RXFIFOE) || \
N                            ((IT)  == SDIO_IT_TXDAVL) || \
N                            ((IT)  == SDIO_IT_RXDAVL) || \
N                            ((IT)  == SDIO_IT_SDIOIT) || \
N                            ((IT)  == SDIO_IT_CEATAEND))
X#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) ||                             ((IT)  == SDIO_IT_DCRCFAIL) ||                             ((IT)  == SDIO_IT_CTIMEOUT) ||                             ((IT)  == SDIO_IT_DTIMEOUT) ||                             ((IT)  == SDIO_IT_TXUNDERR) ||                             ((IT)  == SDIO_IT_RXOVERR) ||                             ((IT)  == SDIO_IT_CMDREND) ||                             ((IT)  == SDIO_IT_CMDSENT) ||                             ((IT)  == SDIO_IT_DATAEND) ||                             ((IT)  == SDIO_IT_STBITERR) ||                             ((IT)  == SDIO_IT_DBCKEND) ||                             ((IT)  == SDIO_IT_CMDACT) ||                             ((IT)  == SDIO_IT_TXACT) ||                             ((IT)  == SDIO_IT_RXACT) ||                             ((IT)  == SDIO_IT_TXFIFOHE) ||                             ((IT)  == SDIO_IT_RXFIFOHF) ||                             ((IT)  == SDIO_IT_TXFIFOF) ||                             ((IT)  == SDIO_IT_RXFIFOF) ||                             ((IT)  == SDIO_IT_TXFIFOE) ||                             ((IT)  == SDIO_IT_RXFIFOE) ||                             ((IT)  == SDIO_IT_TXDAVL) ||                             ((IT)  == SDIO_IT_RXDAVL) ||                             ((IT)  == SDIO_IT_SDIOIT) ||                             ((IT)  == SDIO_IT_CEATAEND))
N
N#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (u32)0xFF3FF800) == 0x00) && ((IT) != (u32)0x00))
N                                                        
N/* SDIO Read Wait Mode -------------------------------------------------------*/
N#define SDIO_ReadWaitMode_CLK               ((u32)0x00000000)
N#define SDIO_ReadWaitMode_DATA2             ((u32)0x00000001)
N
N#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
N                                     ((MODE) == SDIO_ReadWaitMode_DATA2))  
X#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) ||                                      ((MODE) == SDIO_ReadWaitMode_DATA2))  
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid SDIO_DeInit(void);
Nvoid SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
Nvoid SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
Nvoid SDIO_ClockCmd(FunctionalState NewState);
Nvoid SDIO_SetPowerState(u32 SDIO_PowerState);
Nu32 SDIO_GetPowerState(void);
Nvoid SDIO_ITConfig(u32 SDIO_IT, FunctionalState NewState);
Nvoid SDIO_DMACmd(FunctionalState NewState);
Nvoid SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
Nvoid SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
Nu8 SDIO_GetCommandResponse(void);
Nu32 SDIO_GetResponse(u32 SDIO_RESP);
Nvoid SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
Nvoid SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
Nu32 SDIO_GetDataCounter(void);
Nu32 SDIO_ReadData(void);
Nvoid SDIO_WriteData(u32 Data);
Nu32 SDIO_GetFIFOCount(void);
Nvoid SDIO_StartSDIOReadWait(FunctionalState NewState);
Nvoid SDIO_StopSDIOReadWait(FunctionalState NewState);
Nvoid SDIO_SetSDIOReadWaitMode(u32 SDIO_ReadWaitMode);
Nvoid SDIO_SetSDIOOperation(FunctionalState NewState);
Nvoid SDIO_SendSDIOSuspendCmd(FunctionalState NewState);
Nvoid SDIO_CommandCompletionCmd(FunctionalState NewState);
Nvoid SDIO_CEATAITCmd(FunctionalState NewState);
Nvoid SDIO_SendCEATACmd(FunctionalState NewState);
NFlagStatus SDIO_GetFlagStatus(u32 SDIO_FLAG);
Nvoid SDIO_ClearFlag(u32 SDIO_FLAG);
NITStatus SDIO_GetITStatus(u32 SDIO_IT);
Nvoid SDIO_ClearITPendingBit(u32 SDIO_IT);
N
N#endif /* __STM32F10x_SDIO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 94 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_SDIO */
N
N#ifdef _SPI
N  #include "stm32f10x_spi.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_spi.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_spi.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      SPI firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_SPI_H
N#define __STM32F10x_SPI_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* SPI Init structure definition */
Ntypedef struct
N{
N  u16 SPI_Direction;
N  u16 SPI_Mode;
N  u16 SPI_DataSize;
N  u16 SPI_CPOL;
N  u16 SPI_CPHA;
N  u16 SPI_NSS;
N  u16 SPI_BaudRatePrescaler;
N  u16 SPI_FirstBit;
N  u16 SPI_CRCPolynomial;
N}SPI_InitTypeDef;
N
N/* I2S Init structure definition */
Ntypedef struct
N{
N  u16 I2S_Mode;
N  u16 I2S_Standard;
N  u16 I2S_DataFormat;
N  u16 I2S_MCLKOutput;
N  u16 I2S_AudioFreq;
N  u16 I2S_CPOL;
N}I2S_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N#define IS_SPI_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == SPI1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == SPI2_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == SPI3_BASE))
X#define IS_SPI_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == SPI1_BASE) ||                                    ((*(u32*)&(PERIPH)) == SPI2_BASE) ||                                    ((*(u32*)&(PERIPH)) == SPI3_BASE))
N
N#define IS_SPI_23_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == SPI2_BASE) || \
N                                  ((*(u32*)&(PERIPH)) == SPI3_BASE))
X#define IS_SPI_23_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == SPI2_BASE) ||                                   ((*(u32*)&(PERIPH)) == SPI3_BASE))
N
N/* SPI data direction mode */
N#define SPI_Direction_2Lines_FullDuplex ((u16)0x0000)
N#define SPI_Direction_2Lines_RxOnly     ((u16)0x0400)
N#define SPI_Direction_1Line_Rx          ((u16)0x8000)
N#define SPI_Direction_1Line_Tx          ((u16)0xC000)
N
N#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
N                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
N                                     ((MODE) == SPI_Direction_1Line_Rx) || \
N                                     ((MODE) == SPI_Direction_1Line_Tx))
X#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) ||                                      ((MODE) == SPI_Direction_2Lines_RxOnly) ||                                      ((MODE) == SPI_Direction_1Line_Rx) ||                                      ((MODE) == SPI_Direction_1Line_Tx))
N
N/* SPI master/slave mode */
N#define SPI_Mode_Master                 ((u16)0x0104)
N#define SPI_Mode_Slave                  ((u16)0x0000)
N
N#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
N                           ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) ||                            ((MODE) == SPI_Mode_Slave))
N
N/* SPI data size */
N#define SPI_DataSize_16b                ((u16)0x0800)
N#define SPI_DataSize_8b                 ((u16)0x0000)
N
N#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
N                                   ((DATASIZE) == SPI_DataSize_8b))
X#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) ||                                    ((DATASIZE) == SPI_DataSize_8b))
N
N/* SPI Clock Polarity */
N#define SPI_CPOL_Low                    ((u16)0x0000)
N#define SPI_CPOL_High                   ((u16)0x0002)
N
N#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
N                           ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) ||                            ((CPOL) == SPI_CPOL_High))
N
N/* SPI Clock Phase */
N#define SPI_CPHA_1Edge                  ((u16)0x0000)
N#define SPI_CPHA_2Edge                  ((u16)0x0001)
N
N#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
N                           ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) ||                            ((CPHA) == SPI_CPHA_2Edge))
N
N/* SPI Slave Select management */
N#define SPI_NSS_Soft                    ((u16)0x0200)
N#define SPI_NSS_Hard                    ((u16)0x0000)
N
N#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
N                         ((NSS) == SPI_NSS_Hard))                         
X#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) ||                          ((NSS) == SPI_NSS_Hard))                         
N
N/* SPI BaudRate Prescaler  */
N#define SPI_BaudRatePrescaler_2         ((u16)0x0000)
N#define SPI_BaudRatePrescaler_4         ((u16)0x0008)
N#define SPI_BaudRatePrescaler_8         ((u16)0x0010)
N#define SPI_BaudRatePrescaler_16        ((u16)0x0018)
N#define SPI_BaudRatePrescaler_32        ((u16)0x0020)
N#define SPI_BaudRatePrescaler_64        ((u16)0x0028)
N#define SPI_BaudRatePrescaler_128       ((u16)0x0030)
N#define SPI_BaudRatePrescaler_256       ((u16)0x0038)
N
N#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
X#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_4) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_8) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_16) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_32) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_64) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_128) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_256))
N
N/* SPI MSB/LSB transmission */
N#define SPI_FirstBit_MSB                ((u16)0x0000)
N#define SPI_FirstBit_LSB                ((u16)0x0080)
N
N#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
N                               ((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) ||                                ((BIT) == SPI_FirstBit_LSB))
N
N/* I2S Mode */
N#define I2S_Mode_SlaveTx                ((u16)0x0000)
N#define I2S_Mode_SlaveRx                ((u16)0x0100)
N#define I2S_Mode_MasterTx               ((u16)0x0200)
N#define I2S_Mode_MasterRx               ((u16)0x0300)
N
N#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
N                           ((MODE) == I2S_Mode_SlaveRx) || \
N                           ((MODE) == I2S_Mode_MasterTx) || \
N                           ((MODE) == I2S_Mode_MasterRx) )
X#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) ||                            ((MODE) == I2S_Mode_SlaveRx) ||                            ((MODE) == I2S_Mode_MasterTx) ||                            ((MODE) == I2S_Mode_MasterRx) )
N
N/* I2S Standard */
N#define I2S_Standard_Phillips           ((u16)0x0000)
N#define I2S_Standard_MSB                ((u16)0x0010)
N#define I2S_Standard_LSB                ((u16)0x0020)
N#define I2S_Standard_PCMShort           ((u16)0x0030)
N#define I2S_Standard_PCMLong            ((u16)0x00B0)
N
N#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
N                                   ((STANDARD) == I2S_Standard_MSB) || \
N                                   ((STANDARD) == I2S_Standard_LSB) || \
N                                   ((STANDARD) == I2S_Standard_PCMShort) || \
N                                   ((STANDARD) == I2S_Standard_PCMLong))
X#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) ||                                    ((STANDARD) == I2S_Standard_MSB) ||                                    ((STANDARD) == I2S_Standard_LSB) ||                                    ((STANDARD) == I2S_Standard_PCMShort) ||                                    ((STANDARD) == I2S_Standard_PCMLong))
N
N/* I2S Data Format */
N#define I2S_DataFormat_16b              ((u16)0x0000)
N#define I2S_DataFormat_16bextended      ((u16)0x0001)
N#define I2S_DataFormat_24b              ((u16)0x0003)
N#define I2S_DataFormat_32b              ((u16)0x0005)
N
N#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
N                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
N                                    ((FORMAT) == I2S_DataFormat_24b) || \
N                                    ((FORMAT) == I2S_DataFormat_32b))
X#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) ||                                     ((FORMAT) == I2S_DataFormat_16bextended) ||                                     ((FORMAT) == I2S_DataFormat_24b) ||                                     ((FORMAT) == I2S_DataFormat_32b))
N
N/* I2S MCLK Output */ 
N#define I2S_MCLKOutput_Enable           ((u16)0x0200)
N#define I2S_MCLKOutput_Disable          ((u16)0x0000)
N
N#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
N                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
X#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) ||                                     ((OUTPUT) == I2S_MCLKOutput_Disable))
N
N/* I2S Audio Frequency */
N#define I2S_AudioFreq_48k                ((u16)48000)
N#define I2S_AudioFreq_44k                ((u16)44100)
N#define I2S_AudioFreq_22k                ((u16)22050)
N#define I2S_AudioFreq_16k                ((u16)16000)
N#define I2S_AudioFreq_8k                 ((u16)8000)
N#define I2S_AudioFreq_Default            ((u16)2)
N
N#define IS_I2S_AUDIO_FREQ(FREQ) (((FREQ) == I2S_AudioFreq_48k) || \
N                                 ((FREQ) == I2S_AudioFreq_44k) || \
N                                 ((FREQ) == I2S_AudioFreq_22k) || \
N                                 ((FREQ) == I2S_AudioFreq_16k) || \
N                                 ((FREQ) == I2S_AudioFreq_8k)  || \
N                                 ((FREQ) == I2S_AudioFreq_Default))
X#define IS_I2S_AUDIO_FREQ(FREQ) (((FREQ) == I2S_AudioFreq_48k) ||                                  ((FREQ) == I2S_AudioFreq_44k) ||                                  ((FREQ) == I2S_AudioFreq_22k) ||                                  ((FREQ) == I2S_AudioFreq_16k) ||                                  ((FREQ) == I2S_AudioFreq_8k)  ||                                  ((FREQ) == I2S_AudioFreq_Default))
N
N/* I2S Clock Polarity */
N#define I2S_CPOL_Low                    ((u16)0x0000)
N#define I2S_CPOL_High                   ((u16)0x0008)
N
N#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
N                           ((CPOL) == I2S_CPOL_High))
X#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) ||                            ((CPOL) == I2S_CPOL_High))
N
N/* SPI_I2S DMA transfer requests */
N#define SPI_I2S_DMAReq_Tx               ((u16)0x0002)
N#define SPI_I2S_DMAReq_Rx               ((u16)0x0001)
N
N#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (u16)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
N
N/* SPI NSS internal software mangement */
N#define SPI_NSSInternalSoft_Set         ((u16)0x0100)
N#define SPI_NSSInternalSoft_Reset       ((u16)0xFEFF)
N
N#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
N                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
X#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) ||                                        ((INTERNAL) == SPI_NSSInternalSoft_Reset))
N
N/* SPI CRC Transmit/Receive */
N#define SPI_CRC_Tx                      ((u8)0x00)
N#define SPI_CRC_Rx                      ((u8)0x01)
N
N#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
N
N/* SPI direction transmit/receive */
N#define SPI_Direction_Rx                ((u16)0xBFFF)
N#define SPI_Direction_Tx                ((u16)0x4000)
N
N#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
N                                     ((DIRECTION) == SPI_Direction_Tx))
X#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) ||                                      ((DIRECTION) == SPI_Direction_Tx))
N
N/* SPI_I2S interrupts definition */
N#define SPI_I2S_IT_TXE                  ((u8)0x71)
N#define SPI_I2S_IT_RXNE                 ((u8)0x60)
N#define SPI_I2S_IT_ERR                  ((u8)0x50)
N
N#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
N                                 ((IT) == SPI_I2S_IT_RXNE) || \
N                                 ((IT) == SPI_I2S_IT_ERR))
X#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) ||                                  ((IT) == SPI_I2S_IT_RXNE) ||                                  ((IT) == SPI_I2S_IT_ERR))
N
N#define SPI_I2S_IT_OVR                  ((u8)0x56)
N#define SPI_IT_MODF                     ((u8)0x55)
N#define SPI_IT_CRCERR                   ((u8)0x54)
N#define I2S_IT_UDR                      ((u8)0x53)
N
N#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_I2S_IT_OVR) || \
N                                 ((IT) == SPI_IT_MODF) || \
N                                 ((IT) == SPI_IT_CRCERR) || \
N                                 ((IT) == I2S_IT_UDR))
X#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_I2S_IT_OVR) ||                                  ((IT) == SPI_IT_MODF) ||                                  ((IT) == SPI_IT_CRCERR) ||                                  ((IT) == I2S_IT_UDR))
N
N#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
N                               ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) || \
N                               ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
X#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) ||                                ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) ||                                ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
N
N/* SPI_I2S flags definition */
N#define SPI_I2S_FLAG_RXNE               ((u16)0x0001)
N#define SPI_I2S_FLAG_TXE                ((u16)0x0002)
N#define I2S_FLAG_CHSIDE                 ((u16)0x0004)
N#define I2S_FLAG_UDR                    ((u16)0x0008)
N#define SPI_FLAG_CRCERR                 ((u16)0x0010)
N#define SPI_FLAG_MODF                   ((u16)0x0020)
N#define SPI_I2S_FLAG_OVR                ((u16)0x0040)
N#define SPI_I2S_FLAG_BSY                ((u16)0x0080)
N
N#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_OVR) || ((FLAG) == SPI_FLAG_MODF) || \
N                                     ((FLAG) == SPI_FLAG_CRCERR) || ((FLAG) == I2S_FLAG_UDR))
X#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_OVR) || ((FLAG) == SPI_FLAG_MODF) ||                                      ((FLAG) == SPI_FLAG_CRCERR) || ((FLAG) == I2S_FLAG_UDR))
N#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
N                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
N                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
N                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
X#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) ||                                    ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) ||                                    ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) ||                                    ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
N
N/* SPI CRC polynomial --------------------------------------------------------*/
N#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx);
Nvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState);
Nvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState);
Nvoid SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data);
Nu16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
Nvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft);
Nvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize);
Nvoid SPI_TransmitCRC(SPI_TypeDef* SPIx);
Nvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
Nu16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC);
Nu16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
Nvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction);
NFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG);
Nvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG);
NITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT);
Nvoid SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT);
N
N#endif /*__STM32F10x_SPI_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 98 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_SPI */
N
N#ifdef _SysTick
N  #include "stm32f10x_systick.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_systick.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_systick.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      SysTick firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_SYSTICK_H
N#define __STM32F10x_SYSTICK_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* SysTick clock source */
N#define SysTick_CLKSource_HCLK_Div8    ((u32)0xFFFFFFFB)
N#define SysTick_CLKSource_HCLK         ((u32)0x00000004)
N
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
N                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) ||                                        ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
N
N/* SysTick counter state */
N#define SysTick_Counter_Disable        ((u32)0xFFFFFFFE)
N#define SysTick_Counter_Enable         ((u32)0x00000001)
N#define SysTick_Counter_Clear          ((u32)0x00000000)
N
N#define IS_SYSTICK_COUNTER(COUNTER) (((COUNTER) == SysTick_Counter_Disable) || \
N                                     ((COUNTER) == SysTick_Counter_Enable)  || \
N                                     ((COUNTER) == SysTick_Counter_Clear))
X#define IS_SYSTICK_COUNTER(COUNTER) (((COUNTER) == SysTick_Counter_Disable) ||                                      ((COUNTER) == SysTick_Counter_Enable)  ||                                      ((COUNTER) == SysTick_Counter_Clear))
N
N/* SysTick Flag */
N#define SysTick_FLAG_COUNT             ((u32)0x00000010)
N#define SysTick_FLAG_SKEW              ((u32)0x0000001E)
N#define SysTick_FLAG_NOREF             ((u32)0x0000001F)
N
N#define IS_SYSTICK_FLAG(FLAG) (((FLAG) == SysTick_FLAG_COUNT) || \
N                               ((FLAG) == SysTick_FLAG_SKEW)  || \
N                               ((FLAG) == SysTick_FLAG_NOREF))
X#define IS_SYSTICK_FLAG(FLAG) (((FLAG) == SysTick_FLAG_COUNT) ||                                ((FLAG) == SysTick_FLAG_SKEW)  ||                                ((FLAG) == SysTick_FLAG_NOREF))
N
N#define IS_SYSTICK_RELOAD(RELOAD) (((RELOAD) > 0) && ((RELOAD) <= 0xFFFFFF))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid SysTick_CLKSourceConfig(u32 SysTick_CLKSource);
Nvoid SysTick_SetReload(u32 Reload);
Nvoid SysTick_CounterCmd(u32 SysTick_Counter);
Nvoid SysTick_ITConfig(FunctionalState NewState);
Nu32 SysTick_GetCounter(void);
NFlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG);
N
N#endif /* __STM32F10x_SYSTICK_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 102 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_SysTick */
N
N#ifdef _TIM
N  #include "stm32f10x_tim.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_tim.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_tim.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the 
N*                      TIM firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TIM_H
N#define __STM32F10x_TIM_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N
N/* TIM Time Base Init structure definition */
Ntypedef struct
N{
N  u16 TIM_Prescaler;
N  u16 TIM_CounterMode;
N  u16 TIM_Period;
N  u16 TIM_ClockDivision;
N  u8 TIM_RepetitionCounter;
N} TIM_TimeBaseInitTypeDef;
N
N/* TIM Output Compare Init structure definition */
Ntypedef struct
N{
N  u16 TIM_OCMode;
N  u16 TIM_OutputState;
N  u16 TIM_OutputNState;
N  u16 TIM_Pulse;
N  u16 TIM_OCPolarity;
N  u16 TIM_OCNPolarity;
N  u16 TIM_OCIdleState;
N  u16 TIM_OCNIdleState;
N} TIM_OCInitTypeDef;
N
N/* TIM Input Capture Init structure definition */
Ntypedef struct
N{
N  u16 TIM_Channel;
N  u16 TIM_ICPolarity;
N  u16 TIM_ICSelection;
N  u16 TIM_ICPrescaler;
N  u16 TIM_ICFilter;
N} TIM_ICInitTypeDef;
N
N/* BDTR structure definition */
Ntypedef struct
N{
N  u16 TIM_OSSRState;
N  u16 TIM_OSSIState;
N  u16 TIM_LOCKLevel; 
N  u16 TIM_DeadTime;
N  u16 TIM_Break;
N  u16 TIM_BreakPolarity;
N  u16 TIM_AutomaticOutput;
N} TIM_BDTRInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/                             
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM2_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM4_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM5_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM6_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM7_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM2_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM4_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM5_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM6_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM7_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N#define IS_TIM_18_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                  ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_18_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                   ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N#define IS_TIM_123458_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM2_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM4_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM5_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_123458_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM2_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM4_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM5_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N/* TIM Output Compare and PWM modes -----------------------------------------*/
N#define TIM_OCMode_Timing                  ((u16)0x0000)
N#define TIM_OCMode_Active                  ((u16)0x0010)
N#define TIM_OCMode_Inactive                ((u16)0x0020)
N#define TIM_OCMode_Toggle                  ((u16)0x0030)
N#define TIM_OCMode_PWM1                    ((u16)0x0060)
N#define TIM_OCMode_PWM2                    ((u16)0x0070)
N
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/* TIM One Pulse Mode -------------------------------------------------------*/
N#define TIM_OPMode_Single                  ((u16)0x0008)
N#define TIM_OPMode_Repetitive              ((u16)0x0000)
N
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N
N/* TIM Channel -------------------------------------------------------------*/
N#define TIM_Channel_1                      ((u16)0x0000)
N#define TIM_Channel_2                      ((u16)0x0004)
N#define TIM_Channel_3                      ((u16)0x0008)
N#define TIM_Channel_4                      ((u16)0x000C)
N
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N
N#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                               ((CHANNEL) == TIM_Channel_2) || \
N                                               ((CHANNEL) == TIM_Channel_3))
X#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                                ((CHANNEL) == TIM_Channel_2) ||                                                ((CHANNEL) == TIM_Channel_3))
N/* TIM Clock Division CKD --------------------------------------------------*/
N#define TIM_CKD_DIV1                       ((u16)0x0000)
N#define TIM_CKD_DIV2                       ((u16)0x0100)
N#define TIM_CKD_DIV4                       ((u16)0x0200)
N
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N
N/* TIM Counter Mode --------------------------------------------------------*/
N#define TIM_CounterMode_Up                 ((u16)0x0000)
N#define TIM_CounterMode_Down               ((u16)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((u16)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((u16)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((u16)0x0060)
N
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N
N/* TIM Output Compare Polarity ---------------------------------------------*/
N#define TIM_OCPolarity_High                ((u16)0x0000)
N#define TIM_OCPolarity_Low                 ((u16)0x0002)
N
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N
N/* TIM Output Compare N Polarity -------------------------------------------*/
N#define TIM_OCNPolarity_High               ((u16)0x0000)
N#define TIM_OCNPolarity_Low                ((u16)0x0008)
N
N#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
N                                       ((POLARITY) == TIM_OCNPolarity_Low))
X#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) ||                                        ((POLARITY) == TIM_OCNPolarity_Low))
N
N/* TIM Output Compare states -----------------------------------------------*/
N#define TIM_OutputState_Disable            ((u16)0x0000)
N#define TIM_OutputState_Enable             ((u16)0x0001)
N
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N
N/* TIM Output Compare N States ---------------------------------------------*/
N#define TIM_OutputNState_Disable           ((u16)0x0000)
N#define TIM_OutputNState_Enable            ((u16)0x0004)
N
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
N                                     ((STATE) == TIM_OutputNState_Enable))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) ||                                      ((STATE) == TIM_OutputNState_Enable))
N
N/* TIM Capture Compare States -----------------------------------------------*/
N#define TIM_CCx_Enable                      ((u16)0x0001)
N#define TIM_CCx_Disable                     ((u16)0x0000)
N
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N
N/* TIM Capture Compare N States --------------------------------------------*/
N#define TIM_CCxN_Enable                     ((u16)0x0004)
N#define TIM_CCxN_Disable                    ((u16)0x0000)                                     
N
N#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
N                           ((CCXN) == TIM_CCxN_Disable))
X#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) ||                            ((CCXN) == TIM_CCxN_Disable))
N
N/* Break Input enable/disable -----------------------------------------------*/
N#define TIM_Break_Enable                   ((u16)0x1000)
N#define TIM_Break_Disable                  ((u16)0x0000)
N
N#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
N                                   ((STATE) == TIM_Break_Disable))
X#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) ||                                    ((STATE) == TIM_Break_Disable))
N
N/* Break Polarity -----------------------------------------------------------*/
N#define TIM_BreakPolarity_Low              ((u16)0x0000)
N#define TIM_BreakPolarity_High             ((u16)0x2000)
N
N#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
N                                         ((POLARITY) == TIM_BreakPolarity_High))
X#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) ||                                          ((POLARITY) == TIM_BreakPolarity_High))
N
N/* TIM AOE Bit Set/Reset ---------------------------------------------------*/
N#define TIM_AutomaticOutput_Enable         ((u16)0x4000)
N#define TIM_AutomaticOutput_Disable        ((u16)0x0000)
N
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
N                                              ((STATE) == TIM_AutomaticOutput_Disable))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) ||                                               ((STATE) == TIM_AutomaticOutput_Disable))
N/* Lock levels --------------------------------------------------------------*/
N#define TIM_LOCKLevel_OFF                  ((u16)0x0000)
N#define TIM_LOCKLevel_1                    ((u16)0x0100)
N#define TIM_LOCKLevel_2                    ((u16)0x0200)
N#define TIM_LOCKLevel_3                    ((u16)0x0300)
N
N#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
N                                  ((LEVEL) == TIM_LOCKLevel_1) || \
N                                  ((LEVEL) == TIM_LOCKLevel_2) || \
N                                  ((LEVEL) == TIM_LOCKLevel_3))
X#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) ||                                   ((LEVEL) == TIM_LOCKLevel_1) ||                                   ((LEVEL) == TIM_LOCKLevel_2) ||                                   ((LEVEL) == TIM_LOCKLevel_3))
N
N/* OSSI: Off-State Selection for Idle mode states ---------------------------*/
N#define TIM_OSSIState_Enable               ((u16)0x0400)
N#define TIM_OSSIState_Disable              ((u16)0x0000)
N
N#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
N                                  ((STATE) == TIM_OSSIState_Disable))
X#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) ||                                   ((STATE) == TIM_OSSIState_Disable))
N
N/* OSSR: Off-State Selection for Run mode states ----------------------------*/
N#define TIM_OSSRState_Enable               ((u16)0x0800)
N#define TIM_OSSRState_Disable              ((u16)0x0000)
N
N#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
N                                  ((STATE) == TIM_OSSRState_Disable))
X#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) ||                                   ((STATE) == TIM_OSSRState_Disable))
N
N/* TIM Output Compare Idle State -------------------------------------------*/
N#define TIM_OCIdleState_Set                ((u16)0x0100)
N#define TIM_OCIdleState_Reset              ((u16)0x0000)
N
N#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
N                                    ((STATE) == TIM_OCIdleState_Reset))
X#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) ||                                     ((STATE) == TIM_OCIdleState_Reset))
N
N/* TIM Output Compare N Idle State -----------------------------------------*/
N#define TIM_OCNIdleState_Set               ((u16)0x0200)
N#define TIM_OCNIdleState_Reset             ((u16)0x0000)
N
N#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
N                                     ((STATE) == TIM_OCNIdleState_Reset))
X#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) ||                                      ((STATE) == TIM_OCNIdleState_Reset))
N
N/* TIM Input Capture Polarity ----------------------------------------------*/
N#define  TIM_ICPolarity_Rising             ((u16)0x0000)
N#define  TIM_ICPolarity_Falling            ((u16)0x0002)
N
N#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                      ((POLARITY) == TIM_ICPolarity_Falling))
X#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                       ((POLARITY) == TIM_ICPolarity_Falling))
N
N/* TIM Input Capture Selection ---------------------------------------------*/
N#define TIM_ICSelection_DirectTI           ((u16)0x0001)
N#define TIM_ICSelection_IndirectTI         ((u16)0x0002)
N#define TIM_ICSelection_TRC                ((u16)0x0003)
N
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N
N/* TIM Input Capture Prescaler ---------------------------------------------*/
N#define TIM_ICPSC_DIV1                     ((u16)0x0000)
N#define TIM_ICPSC_DIV2                     ((u16)0x0004)
N#define TIM_ICPSC_DIV4                     ((u16)0x0008)
N#define TIM_ICPSC_DIV8                     ((u16)0x000C)
N
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))                                          
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))                                          
N
N/* TIM interrupt sources ---------------------------------------------------*/
N#define TIM_IT_Update                      ((u16)0x0001)
N#define TIM_IT_CC1                         ((u16)0x0002)
N#define TIM_IT_CC2                         ((u16)0x0004)
N#define TIM_IT_CC3                         ((u16)0x0008)
N#define TIM_IT_CC4                         ((u16)0x0010)
N#define TIM_IT_COM                         ((u16)0x0020)
N#define TIM_IT_Trigger                     ((u16)0x0040)
N#define TIM_IT_Break                       ((u16)0x0080)
N
N#define IS_TIM_IT(IT) ((((IT) & (u16)0xFF00) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_PERIPH_IT(PERIPH, TIM_IT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFFA0) == 0x0000) && ((TIM_IT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFF00) == 0x0000) && ((TIM_IT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFFFE) == 0x0000) && ((TIM_IT) != 0x0000)))
X#define IS_TIM_PERIPH_IT(PERIPH, TIM_IT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((TIM_IT) & (u16)0xFFA0) == 0x0000) && ((TIM_IT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((TIM_IT) & (u16)0xFF00) == 0x0000) && ((TIM_IT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((TIM_IT) & (u16)0xFFFE) == 0x0000) && ((TIM_IT) != 0x0000)))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_COM) || \
N                           ((IT) == TIM_IT_Trigger) || \
N                           ((IT) == TIM_IT_Break))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_COM) ||                            ((IT) == TIM_IT_Trigger) ||                            ((IT) == TIM_IT_Break))
N
N/* TIM DMA Base address ----------------------------------------------------*/
N#define TIM_DMABase_CR1                    ((u16)0x0000)
N#define TIM_DMABase_CR2                    ((u16)0x0001)
N#define TIM_DMABase_SMCR                   ((u16)0x0002)
N#define TIM_DMABase_DIER                   ((u16)0x0003)
N#define TIM_DMABase_SR                     ((u16)0x0004)
N#define TIM_DMABase_EGR                    ((u16)0x0005)
N#define TIM_DMABase_CCMR1                  ((u16)0x0006)
N#define TIM_DMABase_CCMR2                  ((u16)0x0007)
N#define TIM_DMABase_CCER                   ((u16)0x0008)
N#define TIM_DMABase_CNT                    ((u16)0x0009)
N#define TIM_DMABase_PSC                    ((u16)0x000A)
N#define TIM_DMABase_ARR                    ((u16)0x000B)
N#define TIM_DMABase_RCR                    ((u16)0x000C)
N#define TIM_DMABase_CCR1                   ((u16)0x000D)
N#define TIM_DMABase_CCR2                   ((u16)0x000E)
N#define TIM_DMABase_CCR3                   ((u16)0x000F)
N#define TIM_DMABase_CCR4                   ((u16)0x0010)
N#define TIM_DMABase_BDTR                   ((u16)0x0011)
N#define TIM_DMABase_DCR                    ((u16)0x0012)
N
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_RCR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_BDTR) || \
N                               ((BASE) == TIM_DMABase_DCR))
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_RCR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_BDTR) ||                                ((BASE) == TIM_DMABase_DCR))
N
N/* TIM DMA Burst Length ----------------------------------------------------*/
N#define TIM_DMABurstLength_1Byte           ((u16)0x0000)
N#define TIM_DMABurstLength_2Bytes          ((u16)0x0100)
N#define TIM_DMABurstLength_3Bytes          ((u16)0x0200)
N#define TIM_DMABurstLength_4Bytes          ((u16)0x0300)
N#define TIM_DMABurstLength_5Bytes          ((u16)0x0400)
N#define TIM_DMABurstLength_6Bytes          ((u16)0x0500)
N#define TIM_DMABurstLength_7Bytes          ((u16)0x0600)
N#define TIM_DMABurstLength_8Bytes          ((u16)0x0700)
N#define TIM_DMABurstLength_9Bytes          ((u16)0x0800)
N#define TIM_DMABurstLength_10Bytes         ((u16)0x0900)
N#define TIM_DMABurstLength_11Bytes         ((u16)0x0A00)
N#define TIM_DMABurstLength_12Bytes         ((u16)0x0B00)
N#define TIM_DMABurstLength_13Bytes         ((u16)0x0C00)
N#define TIM_DMABurstLength_14Bytes         ((u16)0x0D00)
N#define TIM_DMABurstLength_15Bytes         ((u16)0x0E00)
N#define TIM_DMABurstLength_16Bytes         ((u16)0x0F00)
N#define TIM_DMABurstLength_17Bytes         ((u16)0x1000)
N#define TIM_DMABurstLength_18Bytes         ((u16)0x1100)
N
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Byte) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Bytes))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Byte) ||                                    ((LENGTH) == TIM_DMABurstLength_2Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_3Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_4Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_5Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_6Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_7Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_8Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_9Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_10Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_11Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_12Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_13Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_14Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_15Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_16Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_17Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_18Bytes))
N
N/* TIM DMA sources ---------------------------------------------------------*/
N#define TIM_DMA_Update                     ((u16)0x0100)
N#define TIM_DMA_CC1                        ((u16)0x0200)
N#define TIM_DMA_CC2                        ((u16)0x0400)
N#define TIM_DMA_CC3                        ((u16)0x0800)
N#define TIM_DMA_CC4                        ((u16)0x1000)
N#define TIM_DMA_COM                        ((u16)0x2000)
N#define TIM_DMA_Trigger                    ((u16)0x4000)
N
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N#define IS_TIM_PERIPH_DMA(PERIPH, SOURCE) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((SOURCE) & (u16)0xA0FF) == 0x0000) && ((SOURCE) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((SOURCE) & (u16)0xFEFF) == 0x0000) && ((SOURCE) != 0x0000)))
X#define IS_TIM_PERIPH_DMA(PERIPH, SOURCE) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((SOURCE) & (u16)0xA0FF) == 0x0000) && ((SOURCE) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((SOURCE) & (u16)0xFEFF) == 0x0000) && ((SOURCE) != 0x0000)))
N
N/* TIM External Trigger Prescaler ------------------------------------------*/
N#define TIM_ExtTRGPSC_OFF                  ((u16)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((u16)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((u16)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((u16)0x3000)
N
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N
N/* TIM Internal Trigger Selection ------------------------------------------*/
N#define TIM_TS_ITR0                        ((u16)0x0000)
N#define TIM_TS_ITR1                        ((u16)0x0010)
N#define TIM_TS_ITR2                        ((u16)0x0020)
N#define TIM_TS_ITR3                        ((u16)0x0030)
N#define TIM_TS_TI1F_ED                     ((u16)0x0040)
N#define TIM_TS_TI1FP1                      ((u16)0x0050)
N#define TIM_TS_TI2FP2                      ((u16)0x0060)
N#define TIM_TS_ETRF                        ((u16)0x0070)
N
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N
N/* TIM TIx External Clock Source -------------------------------------------*/
N#define TIM_TIxExternalCLK1Source_TI1      ((u16)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((u16)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((u16)0x0040)
N
N#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
X#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
N
N/* TIM External Trigger Polarity -------------------------------------------*/
N#define TIM_ExtTRGPolarity_Inverted        ((u16)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((u16)0x0000)
N
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N
N/* TIM Prescaler Reload Mode -----------------------------------------------*/
N#define TIM_PSCReloadMode_Update           ((u16)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((u16)0x0001)
N
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N
N/* TIM Forced Action -------------------------------------------------------*/
N#define TIM_ForcedAction_Active            ((u16)0x0050)
N#define TIM_ForcedAction_InActive          ((u16)0x0040)
N
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N
N/* TIM Encoder Mode --------------------------------------------------------*/ 
N#define TIM_EncoderMode_TI1                ((u16)0x0001)
N#define TIM_EncoderMode_TI2                ((u16)0x0002)
N#define TIM_EncoderMode_TI12               ((u16)0x0003)
N
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N
N/* TIM Event Source --------------------------------------------------------*/
N#define TIM_EventSource_Update             ((u16)0x0001)
N#define TIM_EventSource_CC1                ((u16)0x0002)
N#define TIM_EventSource_CC2                ((u16)0x0004)
N#define TIM_EventSource_CC3                ((u16)0x0008)
N#define TIM_EventSource_CC4                ((u16)0x0010)
N#define TIM_EventSource_COM                ((u16)0x0020)
N#define TIM_EventSource_Trigger            ((u16)0x0040)
N#define TIM_EventSource_Break              ((u16)0x0080)
N
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (u16)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
N
N#define IS_TIM_PERIPH_EVENT(PERIPH, EVENT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((EVENT) & (u16)0xFFA0) == 0x0000) && ((EVENT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((EVENT) & (u16)0xFF00) == 0x0000) && ((EVENT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((EVENT) & (u16)0xFFFE) == 0x0000) && ((EVENT) != 0x0000)))
X#define IS_TIM_PERIPH_EVENT(PERIPH, EVENT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((EVENT) & (u16)0xFFA0) == 0x0000) && ((EVENT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((EVENT) & (u16)0xFF00) == 0x0000) && ((EVENT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((EVENT) & (u16)0xFFFE) == 0x0000) && ((EVENT) != 0x0000)))
N
N/* TIM Update Source --------------------------------------------------------*/
N#define TIM_UpdateSource_Global            ((u16)0x0000)
N#define TIM_UpdateSource_Regular           ((u16)0x0001)
N
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N
N/* TIM Ouput Compare Preload State ------------------------------------------*/
N#define TIM_OCPreload_Enable               ((u16)0x0008)
N#define TIM_OCPreload_Disable              ((u16)0x0000)
N
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N
N/* TIM Ouput Compare Fast State ---------------------------------------------*/
N#define TIM_OCFast_Enable                  ((u16)0x0004)
N#define TIM_OCFast_Disable                 ((u16)0x0000)
N
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/* TIM Ouput Compare Clear State --------------------------------------------*/
N#define TIM_OCClear_Enable                 ((u16)0x0080)
N#define TIM_OCClear_Disable                ((u16)0x0000)
N
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))                                     
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))                                     
N
N/* TIM Trigger Output Source ------------------------------------------------*/ 
N#define TIM_TRGOSource_Reset               ((u16)0x0000)
N#define TIM_TRGOSource_Enable              ((u16)0x0010)
N#define TIM_TRGOSource_Update              ((u16)0x0020)
N#define TIM_TRGOSource_OC1                 ((u16)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((u16)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((u16)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((u16)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((u16)0x0070)
N
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N
N#define IS_TIM_PERIPH_TRGO(PERIPH, TRGO)  (((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Reset)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Enable)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Update)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC1)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC1Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC2Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC3Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC4Ref)))
X#define IS_TIM_PERIPH_TRGO(PERIPH, TRGO)  (((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Reset)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Enable)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Update)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC1)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC1Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC2Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC3Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC4Ref)))
N
N/* TIM Slave Mode ----------------------------------------------------------*/
N#define TIM_SlaveMode_Reset                ((u16)0x0004)
N#define TIM_SlaveMode_Gated                ((u16)0x0005)
N#define TIM_SlaveMode_Trigger              ((u16)0x0006)
N#define TIM_SlaveMode_External1            ((u16)0x0007)
N
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N
N/* TIM Master Slave Mode ---------------------------------------------------*/
N#define TIM_MasterSlaveMode_Enable         ((u16)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((u16)0x0000)
N
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N
N/* TIM Flags ---------------------------------------------------------------*/
N#define TIM_FLAG_Update                    ((u16)0x0001)
N#define TIM_FLAG_CC1                       ((u16)0x0002)
N#define TIM_FLAG_CC2                       ((u16)0x0004)
N#define TIM_FLAG_CC3                       ((u16)0x0008)
N#define TIM_FLAG_CC4                       ((u16)0x0010)
N#define TIM_FLAG_COM                       ((u16)0x0020)
N#define TIM_FLAG_Trigger                   ((u16)0x0040)
N#define TIM_FLAG_Break                     ((u16)0x0080)
N#define TIM_FLAG_CC1OF                     ((u16)0x0200)
N#define TIM_FLAG_CC2OF                     ((u16)0x0400)
N#define TIM_FLAG_CC3OF                     ((u16)0x0800)
N#define TIM_FLAG_CC4OF                     ((u16)0x1000)
N
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_COM) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_Break) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_COM) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_Break) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N
N#define IS_TIM_CLEAR_FLAG(PERIPH, TIM_FLAG) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xE1A0) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xFFFE) == 0x0000) && ((TIM_FLAG) != 0x0000)))
X#define IS_TIM_CLEAR_FLAG(PERIPH, TIM_FLAG) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((TIM_FLAG) & (u16)0xE1A0) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((TIM_FLAG) & (u16)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((TIM_FLAG) & (u16)0xFFFE) == 0x0000) && ((TIM_FLAG) != 0x0000)))
N
N#define IS_TIM_PERIPH_FLAG(PERIPH, TIM_FLAG)  (((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||\
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_CC1) || ((TIM_FLAG) == TIM_FLAG_CC2) ||\
N                                                 ((TIM_FLAG) == TIM_FLAG_CC3) || ((TIM_FLAG) == TIM_FLAG_CC4) || \
N                                                 ((TIM_FLAG) == TIM_FLAG_Trigger))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||\
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE)|| ((*(u32*)&(PERIPH))==TIM8_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM7_BASE) || ((*(u32*)&(PERIPH))==TIM6_BASE)) && \
N                                                 (((TIM_FLAG) == TIM_FLAG_Update))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH)) == TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_COM) || ((TIM_FLAG) == TIM_FLAG_Break))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_CC1OF) || ((TIM_FLAG) == TIM_FLAG_CC2OF) ||\
N                                                 ((TIM_FLAG) == TIM_FLAG_CC3OF) || ((TIM_FLAG) == TIM_FLAG_CC4OF))))             
X#define IS_TIM_PERIPH_FLAG(PERIPH, TIM_FLAG)  (((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_CC1) || ((TIM_FLAG) == TIM_FLAG_CC2) ||                                                 ((TIM_FLAG) == TIM_FLAG_CC3) || ((TIM_FLAG) == TIM_FLAG_CC4) ||                                                  ((TIM_FLAG) == TIM_FLAG_Trigger))) ||                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                  ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                 ((*(u32*)&(PERIPH))==TIM1_BASE)|| ((*(u32*)&(PERIPH))==TIM8_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM7_BASE) || ((*(u32*)&(PERIPH))==TIM6_BASE)) &&                                                  (((TIM_FLAG) == TIM_FLAG_Update))) ||                                                 ((((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH)) == TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_COM) || ((TIM_FLAG) == TIM_FLAG_Break))) ||                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                  ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_CC1OF) || ((TIM_FLAG) == TIM_FLAG_CC2OF) ||                                                 ((TIM_FLAG) == TIM_FLAG_CC3OF) || ((TIM_FLAG) == TIM_FLAG_CC4OF))))             
N                                                                                            
N/* TIM Input Capture Filer Value ---------------------------------------------*/
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N
N/* TIM External Trigger Filter -----------------------------------------------*/
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)                              
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState);
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
N                                u16 TIM_ICPolarity, u16 ICFilter);                                
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
N                             u16 ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
N                             u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
N                   u16 ExtTRGFilter);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode);
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource);
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
N                                u16 TIM_IC1Polarity, u16 TIM_IC2Polarity);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx);
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD);
Nu16 TIM_GetCapture1(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture2(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture3(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture4(TIM_TypeDef* TIMx);
Nu16 TIM_GetCounter(TIM_TypeDef* TIMx);
Nu16 TIM_GetPrescaler(TIM_TypeDef* TIMx);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT);
N                                                                                                             
N#endif /*__STM32F10x_TIM_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
N
N
N
N
N
N
N
N
L 106 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_TIM */
N
N#ifdef _USART
N  #include "stm32f10x_usart.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_usart.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_usart.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      USART firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_USART_H
N#define __STM32F10x_USART_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* USART Init Structure definition */
Ntypedef struct
N{
N  u32 USART_BaudRate;
N  u16 USART_WordLength;
N  u16 USART_StopBits;
N  u16 USART_Parity;
N  u16 USART_Mode;
N  u16 USART_HardwareFlowControl;  
N} USART_InitTypeDef;
N
N/* USART Clock Init Structure definition */
Ntypedef struct
N{
N  u16 USART_Clock;
N  u16 USART_CPOL;
N  u16 USART_CPHA;
N  u16 USART_LastBit;
N} USART_ClockInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N#define IS_USART_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == USART2_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == USART3_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == UART4_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == UART5_BASE))
X#define IS_USART_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) ||                                      ((*(u32*)&(PERIPH)) == USART2_BASE) ||                                      ((*(u32*)&(PERIPH)) == USART3_BASE) ||                                      ((*(u32*)&(PERIPH)) == UART4_BASE) ||                                      ((*(u32*)&(PERIPH)) == UART5_BASE))
N
N#define IS_USART_123_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == USART2_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == USART3_BASE))
X#define IS_USART_123_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) ||                                      ((*(u32*)&(PERIPH)) == USART2_BASE) ||                                      ((*(u32*)&(PERIPH)) == USART3_BASE))
N
N#define IS_USART_1234_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == USART2_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == USART3_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == UART4_BASE))
X#define IS_USART_1234_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) ||                                       ((*(u32*)&(PERIPH)) == USART2_BASE) ||                                       ((*(u32*)&(PERIPH)) == USART3_BASE) ||                                       ((*(u32*)&(PERIPH)) == UART4_BASE))
N
N/* USART Word Length ---------------------------------------------------------*/
N#define USART_WordLength_8b                  ((u16)0x0000)
N#define USART_WordLength_9b                  ((u16)0x1000)
N                                    
N#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
N                                      ((LENGTH) == USART_WordLength_9b))
X#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) ||                                       ((LENGTH) == USART_WordLength_9b))
N
N/* USART Stop Bits -----------------------------------------------------------*/
N#define USART_StopBits_1                     ((u16)0x0000)
N#define USART_StopBits_0_5                   ((u16)0x1000)
N#define USART_StopBits_2                     ((u16)0x2000)
N#define USART_StopBits_1_5                   ((u16)0x3000)
N
N#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
N                                     ((STOPBITS) == USART_StopBits_0_5) || \
N                                     ((STOPBITS) == USART_StopBits_2) || \
N                                     ((STOPBITS) == USART_StopBits_1_5))
X#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) ||                                      ((STOPBITS) == USART_StopBits_0_5) ||                                      ((STOPBITS) == USART_StopBits_2) ||                                      ((STOPBITS) == USART_StopBits_1_5))
N/* USART Parity --------------------------------------------------------------*/
N#define USART_Parity_No                      ((u16)0x0000)
N#define USART_Parity_Even                    ((u16)0x0400)
N#define USART_Parity_Odd                     ((u16)0x0600) 
N
N#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
N                                 ((PARITY) == USART_Parity_Even) || \
N                                 ((PARITY) == USART_Parity_Odd))
X#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) ||                                  ((PARITY) == USART_Parity_Even) ||                                  ((PARITY) == USART_Parity_Odd))
N
N/* USART Mode ----------------------------------------------------------------*/
N#define USART_Mode_Rx                        ((u16)0x0004)
N#define USART_Mode_Tx                        ((u16)0x0008)
N
N#define IS_USART_MODE(MODE) ((((MODE) & (u16)0xFFF3) == 0x00) && ((MODE) != (u16)0x00))
N
N/* USART Hardware Flow Control -----------------------------------------------*/
N#define USART_HardwareFlowControl_None       ((u16)0x0000)
N#define USART_HardwareFlowControl_RTS        ((u16)0x0100)
N#define USART_HardwareFlowControl_CTS        ((u16)0x0200)
N#define USART_HardwareFlowControl_RTS_CTS    ((u16)0x0300)
N
N#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == USART_HardwareFlowControl_None) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
X#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == USART_HardwareFlowControl_None) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS) ||                                ((CONTROL) == USART_HardwareFlowControl_CTS) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
N
N#define IS_USART_PERIPH_HFC(PERIPH, HFC) ((((*(u32*)&(PERIPH)) != UART4_BASE) && \
N                                          ((*(u32*)&(PERIPH)) != UART5_BASE)) \
N                                          || ((HFC) == USART_HardwareFlowControl_None))                                
X#define IS_USART_PERIPH_HFC(PERIPH, HFC) ((((*(u32*)&(PERIPH)) != UART4_BASE) &&                                           ((*(u32*)&(PERIPH)) != UART5_BASE))                                           || ((HFC) == USART_HardwareFlowControl_None))                                
N
N/* USART Clock ---------------------------------------------------------------*/
N#define USART_Clock_Disable                  ((u16)0x0000)
N#define USART_Clock_Enable                   ((u16)0x0800)
N
N#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
N                               ((CLOCK) == USART_Clock_Enable))
X#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) ||                                ((CLOCK) == USART_Clock_Enable))
N
N/* USART Clock Polarity ------------------------------------------------------*/
N#define USART_CPOL_Low                       ((u16)0x0000)
N#define USART_CPOL_High                      ((u16)0x0400)
N
N#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
N                               
N/* USART Clock Phase ---------------------------------------------------------*/
N#define USART_CPHA_1Edge                     ((u16)0x0000)
N#define USART_CPHA_2Edge                     ((u16)0x0200)
N#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
N
N/* USART Last Bit ------------------------------------------------------------*/
N#define USART_LastBit_Disable                ((u16)0x0000)
N#define USART_LastBit_Enable                 ((u16)0x0100)
N
N#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
N                                   ((LASTBIT) == USART_LastBit_Enable))
X#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) ||                                    ((LASTBIT) == USART_LastBit_Enable))
N
N/* USART Interrupt definition ------------------------------------------------*/
N#define USART_IT_PE                          ((u16)0x0028)
N#define USART_IT_TXE                         ((u16)0x0727)
N#define USART_IT_TC                          ((u16)0x0626)
N#define USART_IT_RXNE                        ((u16)0x0525)
N#define USART_IT_IDLE                        ((u16)0x0424)
N#define USART_IT_LBD                         ((u16)0x0846)
N#define USART_IT_CTS                         ((u16)0x096A)
N#define USART_IT_ERR                         ((u16)0x0060)
N#define USART_IT_ORE                         ((u16)0x0360)
N#define USART_IT_NE                          ((u16)0x0260)
N#define USART_IT_FE                          ((u16)0x0160)
N
N#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                               ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                               ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                               ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
X#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
N
N#define IS_USART_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                         ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                         ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                         ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
N                         ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
X#define IS_USART_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                          ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                          ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                          ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) ||                          ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
N
N#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TC) || \
N                               ((IT) == USART_IT_RXNE) || ((IT) == USART_IT_IDLE) || \
N                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS) ||  \
N                               ((IT) == USART_IT_ORE) || ((IT) == USART_IT_NE) || \
N                               ((IT) == USART_IT_FE))
X#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TC) ||                                ((IT) == USART_IT_RXNE) || ((IT) == USART_IT_IDLE) ||                                ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS) ||                                 ((IT) == USART_IT_ORE) || ((IT) == USART_IT_NE) ||                                ((IT) == USART_IT_FE))
N
N#define IS_USART_PERIPH_IT(PERIPH, USART_IT) ((((*(u32*)&(PERIPH)) != UART4_BASE) && \
N                                              ((*(u32*)&(PERIPH)) != UART5_BASE)) \
N                                              || ((USART_IT) != USART_IT_CTS))                                                                           
X#define IS_USART_PERIPH_IT(PERIPH, USART_IT) ((((*(u32*)&(PERIPH)) != UART4_BASE) &&                                               ((*(u32*)&(PERIPH)) != UART5_BASE))                                               || ((USART_IT) != USART_IT_CTS))                                                                           
N
N/* USART DMA Requests --------------------------------------------------------*/
N#define USART_DMAReq_Tx                      ((u16)0x0080)
N#define USART_DMAReq_Rx                      ((u16)0x0040)
N
N#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (u16)0xFF3F) == 0x00) && ((DMAREQ) != (u16)0x00))
N
N/* USART WakeUp methods ------------------------------------------------------*/
N#define USART_WakeUp_IdleLine                ((u16)0x0000)
N#define USART_WakeUp_AddressMark             ((u16)0x0800)
N
N#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
N                                 ((WAKEUP) == USART_WakeUp_AddressMark))
X#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) ||                                  ((WAKEUP) == USART_WakeUp_AddressMark))
N
N/* USART LIN Break Detection Length ------------------------------------------*/
N#define USART_LINBreakDetectLength_10b      ((u16)0x0000)
N#define USART_LINBreakDetectLength_11b      ((u16)0x0020)
N
N#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
N                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
N                                ((LENGTH) == USART_LINBreakDetectLength_11b))
X#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH)                                (((LENGTH) == USART_LINBreakDetectLength_10b) ||                                 ((LENGTH) == USART_LINBreakDetectLength_11b))
N
N/* USART IrDA Low Power ------------------------------------------------------*/
N#define USART_IrDAMode_LowPower              ((u16)0x0004)
N#define USART_IrDAMode_Normal                ((u16)0x0000)
N
N#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
N                                  ((MODE) == USART_IrDAMode_Normal))
X#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) ||                                   ((MODE) == USART_IrDAMode_Normal))
N
N/* USART Flags ---------------------------------------------------------------*/
N#define USART_FLAG_CTS                       ((u16)0x0200)
N#define USART_FLAG_LBD                       ((u16)0x0100)
N#define USART_FLAG_TXE                       ((u16)0x0080)
N#define USART_FLAG_TC                        ((u16)0x0040)
N#define USART_FLAG_RXNE                      ((u16)0x0020)
N#define USART_FLAG_IDLE                      ((u16)0x0010)
N#define USART_FLAG_ORE                       ((u16)0x0008)
N#define USART_FLAG_NE                        ((u16)0x0004)
N#define USART_FLAG_FE                        ((u16)0x0002)
N#define USART_FLAG_PE                        ((u16)0x0001)
N
N#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
N                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
N                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
N                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
N                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
X#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) ||                              ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) ||                              ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) ||                              ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) ||                              ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
N                              
N#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (u16)0xFC80) == 0x00) && ((FLAG) != (u16)0x00))
N
N#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(u32*)&(PERIPH)) != UART4_BASE) &&\
N                                                  ((*(u32*)&(PERIPH)) != UART5_BASE)) \
N                                                  || ((USART_FLAG) != USART_FLAG_CTS)) 
X#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(u32*)&(PERIPH)) != UART4_BASE) &&                                                  ((*(u32*)&(PERIPH)) != UART5_BASE))                                                   || ((USART_FLAG) != USART_FLAG_CTS)) 
N
N#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x0044AA21))
N#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
N#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid USART_DeInit(USART_TypeDef* USARTx);
Nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
Nvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct);
Nvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState);
Nvoid USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState);
Nvoid USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address);
Nvoid USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp);
Nvoid USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength);
Nvoid USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SendData(USART_TypeDef* USARTx, u16 Data);
Nu16 USART_ReceiveData(USART_TypeDef* USARTx);
Nvoid USART_SendBreak(USART_TypeDef* USARTx);
Nvoid USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime);
Nvoid USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler);
Nvoid USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode);
Nvoid USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
NFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG);
Nvoid USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG);
NITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT);
Nvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT);
N
N#endif /* __STM32F10x_USART_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 110 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_USART */
N
N#ifdef _WWDG
N  #include "stm32f10x_wwdg.h"
L 1 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_wwdg.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_wwdg.h
N* Author             : MCD Application Team
N* Version            : V2.0.1
N* Date               : 06/13/2008
N* Description        : This file contains all the functions prototypes for the
N*                      WWDG firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_WWDG_H
N#define __STM32F10x_WWDG_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* WWDG Prescaler */
N#define WWDG_Prescaler_1    ((u32)0x00000000)
N#define WWDG_Prescaler_2    ((u32)0x00000080)
N#define WWDG_Prescaler_4    ((u32)0x00000100)
N#define WWDG_Prescaler_8    ((u32)0x00000180)
N
N#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
N                                      ((PRESCALER) == WWDG_Prescaler_2) || \
N                                      ((PRESCALER) == WWDG_Prescaler_4) || \
N                                      ((PRESCALER) == WWDG_Prescaler_8))
X#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) ||                                       ((PRESCALER) == WWDG_Prescaler_2) ||                                       ((PRESCALER) == WWDG_Prescaler_4) ||                                       ((PRESCALER) == WWDG_Prescaler_8))
N
N#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
N
N#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid WWDG_DeInit(void);
Nvoid WWDG_SetPrescaler(u32 WWDG_Prescaler);
Nvoid WWDG_SetWindowValue(u8 WindowValue);
Nvoid WWDG_EnableIT(void);
Nvoid WWDG_SetCounter(u8 Counter);
Nvoid WWDG_Enable(u8 Counter);
NFlagStatus WWDG_GetFlagStatus(void);
Nvoid WWDG_ClearFlag(void);
N
N#endif /* __STM32F10x_WWDG_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 114 "C:\Keil\ARM\INC\ST\STM32F10x\stm32f10x_lib.h" 2
N#endif /*_WWDG */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid debug(void);
N
N#endif /* __STM32F10x_LIB_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 10 "main.c" 2
N#include <stdio.h>
L 1 "C:\Keil\ARM\RV31\INC\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 137287 $
N * Checkin $Date: 2008-08-27 13:36:52 +0100 (Wed, 27 Aug 2008) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
L 11 "main.c" 2
N#include <rtl.h>
L 1 "C:\Keil\ARM\RV31\INC\rtl.h" 1
N/*----------------------------------------------------------------------------
N *      RL-ARM - A P I 
N *----------------------------------------------------------------------------
N *      Name:    RTL.H 
N *      Purpose: Application Programming Interface. 
N *      Rev.:    V4.20
N *----------------------------------------------------------------------------
N *      This code is part of the RealView Run-Time Library.
N *      Copyright (c) 2004-2011 KEIL - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __RTL_H__
N#define __RTL_H__
N
N/* RL-ARM version number. */
N#define __RL_ARM_VER    420
N 
N#define __task          __declspec(noreturn)
N
N#ifndef NULL
S #ifdef __cplusplus              // EC++
S  #define NULL          0
S #else
S  #define NULL          ((void *) 0)
S #endif
N#endif
N
N#ifndef EOF
S #define EOF            -1
N#endif
N
N#ifndef __size_t
N #define __size_t       1
N typedef unsigned int   size_t;
N#endif
N
Ntypedef signed char     S8;
Ntypedef unsigned char   U8;
Ntypedef short           S16;
Ntypedef unsigned short  U16;
Ntypedef int             S32;
Ntypedef unsigned int    U32;
Ntypedef long long       S64;
Ntypedef unsigned long long U64;
Ntypedef unsigned char   BIT;
Ntypedef unsigned int    BOOL;
N
N#ifndef __TRUE
N #define __TRUE         1
N#endif
N#ifndef __FALSE
N #define __FALSE        0
N#endif
N
N#ifdef __BIG_ENDIAN
S #define U32_LE(v) (__rev(v))
S #define U16_LE(v) (__rev(v) >> 16) 
S #define U32_BE(v)       (v)
S #define U16_BE(v)       (v)
N#else
N #define U32_BE(v) (__rev(v))
N #define U16_BE(v) (__rev(v) >> 16) 
N #define U32_LE(v)       (v)
N #define U16_LE(v)       (v)
N#endif
N
N/*----------------------------------------------------------------------------
N *                             RTX Kernel API
N *---------------------------------------------------------------------------*/
N
N#ifdef __cplusplus               // EC++
Sextern "C"  {
N#endif
N
N/* Definition of Semaphore type */
Ntypedef U32 OS_SEM[2];
N
N/* Definition of Mailbox type */
N#define os_mbx_declare(name,cnt)    U32 name [4 + cnt]
Ntypedef U32 OS_MBX[];
N
N/* Definition of Mutex type */
Ntypedef U32 OS_MUT[3];
N
N/* Task Identification number. */
Ntypedef U32 OS_TID;
N
N/* Function return of system calls returning an object identification */
Ntypedef void *OS_ID;
N
N/* Function return of system calls indicating an event or completion state */
Ntypedef U32 OS_RESULT;
N
N/* Return codes */
N#define OS_R_TMO        0x01
N#define OS_R_EVT        0x02
N#define OS_R_SEM        0x03
N#define OS_R_MBX        0x04
N#define OS_R_MUT        0x05
N
N#define OS_R_OK         0x00
N#define OS_R_NOK        0xff
N
N#define OS_TCB_SIZE     48
N#define OS_TMR_SIZE     8
N
N/* Error Codes */
N#define OS_ERR_STK_OVF  1
N#define OS_ERR_FIFO_OVF 2
N#define OS_ERR_MBX_OVF  3
N
N#if !(defined(__TARGET_ARCH_6S_M) || defined(__TARGET_ARCH_7_M) || defined(__TARGET_ARCH_7E_M))
X#if !(0L || 1L || 0L)
S
S/*----------------------------------------------------------------------------
S *      Functions ARM
S *---------------------------------------------------------------------------*/
S
S/* Task Management */
S#define os_sys_init(tsk)              os_sys_init0(tsk,0,NULL)
S#define os_sys_init_prio(tsk,prio)    os_sys_init0(tsk,prio,NULL)
S#define os_sys_init_user(tsk,prio,stk,size)                                   \
S                                      os_sys_init0(tsk,prio|(size<<8),stk)
X#define os_sys_init_user(tsk,prio,stk,size)                                                                         os_sys_init0(tsk,prio|(size<<8),stk)
S#define os_tsk_create(tsk,prio)       os_tsk_create0(tsk,prio,NULL,NULL)
S#define os_tsk_create_user(tsk,prio,stk,size)                                 \
S                                      os_tsk_create0(tsk,prio|(size<<8),stk,NULL)
X#define os_tsk_create_user(tsk,prio,stk,size)                                                                       os_tsk_create0(tsk,prio|(size<<8),stk,NULL)
S#define os_tsk_create_ex(tsk,prio,argv) os_tsk_create_ex0(tsk,prio,NULL,argv)
S#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                         \
S                                      os_tsk_create_ex0(tsk,prio|(size<<8),stk,argv)
X#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                                                               os_tsk_create_ex0(tsk,prio|(size<<8),stk,argv)
S#define os_tsk_delete_self()          os_tsk_delete(0)
S#define os_tsk_prio_self(prio)        os_tsk_prio(0,prio)
S#define isr_tsk_get()                 os_tsk_self()
S
Sextern void      os_sys_init0 (void (*task)(void), U32 prio_stksz, void *stk);
Sextern OS_TID    os_tsk_create0 (void (*task)(void), U32 prio_stksz, 
S                                 void *stk, void *argv);
Sextern OS_TID    os_tsk_create_ex0 (void (*task)(void *), U32 prio_stksz, 
S                                    void *stk, void *argv);
Sextern OS_TID    os_tsk_self (void);
Sextern void      os_tsk_pass (void);
Sextern OS_RESULT os_tsk_prio (OS_TID task_id, U8 new_prio);
Sextern OS_RESULT os_tsk_delete (OS_TID task_id);
S
S/* Event flag Management */
S#define os_evt_wait_or(wflags,tmo)      os_evt_wait(wflags,tmo,__FALSE)
S#define os_evt_wait_and(wflags,tmo)     os_evt_wait(wflags,tmo,__TRUE)
S
Sextern OS_RESULT os_evt_wait (U16 wait_flags, U16 timeout, BOOL and_wait);
Sextern void      os_evt_set (U16 event_flags, OS_TID task_id);
Sextern void      os_evt_clr (U16 clear_flags, OS_TID task_id);
Sextern void      isr_evt_set (U16 event_flags, OS_TID task_id);
Sextern U16       os_evt_get (void);
S
S/* Semaphore Management */
Sextern void      os_sem_init (OS_ID semaphore, U16 token_count);
Sextern OS_RESULT os_sem_send (OS_ID semaphore);
Sextern OS_RESULT os_sem_wait (OS_ID semaphore, U16 timeout);
Sextern void      isr_sem_send (OS_ID semaphore);
S
S/* Mailbox Management */
S#define isr_mbx_check(mbx)              os_mbx_check(mbx)
S
Sextern void      os_mbx_init (OS_ID mailbox, U16 mbx_size);
Sextern OS_RESULT os_mbx_send (OS_ID mailbox, void *message_ptr, U16 timeout);
Sextern OS_RESULT os_mbx_wait (OS_ID mailbox, void  **message, U16 timeout);
Sextern OS_RESULT os_mbx_check (OS_ID mailbox);
Sextern void      isr_mbx_send (OS_ID mailbox, void *message_ptr);
Sextern OS_RESULT isr_mbx_receive (OS_ID mailbox, void **message);
S
S/* Mutex Management */
Sextern void      os_mut_init (OS_ID mutex);
Sextern OS_RESULT os_mut_release (OS_ID mutex);
Sextern OS_RESULT os_mut_wait (OS_ID mutex, U16 timeout);
S
S/* Time Management */
Sextern void      os_dly_wait (U16 delay_time);
Sextern void      os_itv_set (U16 interval_time);
Sextern void      os_itv_wait (void);
S
S/* User Timer Management */
Sextern OS_ID     os_tmr_create (U16 tcnt, U16 info);
Sextern OS_ID     os_tmr_kill (OS_ID timer);
S
S/* System Functions */
Sextern void      tsk_lock (void) __swi (5);
Sextern void      tsk_unlock (void);
S
S/* Fixed Memory Block Management Functions */
Sextern int       _init_box (void *box_mem, U32 box_size, U32 blk_size);
Sextern void     *_alloc_box (void *box_mem) __swi (1);
Sextern void     *_calloc_box (void *box_mem);
Sextern int       _free_box (void *box_mem, void *box) __swi (2);
S
N#else
N
N/*----------------------------------------------------------------------------
N *      Functions Cortex-M
N *---------------------------------------------------------------------------*/
N
N#define __SVC_0         __svc_indirect(0)
N
N/* Task Management */
Nextern void      os_set_env    (void);
Nextern void      rt_sys_init   (void (*task)(void), U8 priority, void *stk);
Nextern void      rt_tsk_pass   (void);
Nextern OS_TID    rt_tsk_self   (void);
Nextern OS_RESULT rt_tsk_prio   (OS_TID task_id, U8 new_prio);
Nextern OS_TID    rt_tsk_create (void (*task)(void), U8 priority, void *stk, void *argv);
Nextern OS_RESULT rt_tsk_delete (OS_TID task_id);
N
N#define os_sys_init(tsk)              os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,0,NULL)
X#define os_sys_init(tsk)              os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,0,NULL)
N#define os_sys_init_user(tsk,prio,stk,size)                                   \
N                                      os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,prio|(size<<8),stk)
X#define os_sys_init_user(tsk,prio,stk,size)                                                                         os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,prio|(size<<8),stk)
N#define os_sys_init_prio(tsk,prio)    os_set_env();                           \
N                                      _os_sys_init((U32)rt_sys_init,tsk,prio,NULL)
X#define os_sys_init_prio(tsk,prio)    os_set_env();                                                                 _os_sys_init((U32)rt_sys_init,tsk,prio,NULL)
N#define os_tsk_create(tsk,prio)       _os_tsk_create((U32)rt_tsk_create,tsk,prio,NULL,NULL)
N#define os_tsk_create_user(tsk,prio,stk,size)                                 \
N                                      _os_tsk_create((U32)rt_tsk_create,tsk,prio|(size<<8),stk,NULL)
X#define os_tsk_create_user(tsk,prio,stk,size)                                                                       _os_tsk_create((U32)rt_tsk_create,tsk,prio|(size<<8),stk,NULL)
N#define os_tsk_create_ex(tsk,prio,argv) _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio,NULL,argv)
N#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                         \
N                                      _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio|(size<<8),stk,argv)
X#define os_tsk_create_user_ex(tsk,prio,stk,size,argv)                                                               _os_tsk_create_ex((U32)rt_tsk_create,tsk,prio|(size<<8),stk,argv)
N#define os_tsk_self()                 _os_tsk_self((U32)rt_tsk_self)
N#define os_tsk_pass()                 _os_tsk_pass((U32)rt_tsk_pass)
N#define os_tsk_prio(task_id,new_prio) _os_tsk_prio((U32)rt_tsk_prio,task_id,new_prio)
N#define os_tsk_prio_self(prio)        _os_tsk_prio((U32)rt_tsk_prio,0,prio)
N#define os_tsk_delete(task_id)        _os_tsk_delete((U32)rt_tsk_delete,task_id)
N#define os_tsk_delete_self()          _os_tsk_delete((U32)rt_tsk_delete, 0)
N#define isr_tsk_get()                 rt_tsk_self()
N
Nextern void      _os_sys_init(U32 p, void (*task)(void), U32 prio_stksz,
N                                     void *stk)                        __SVC_0;
X                                     void *stk)                        __svc_indirect(0);
Nextern OS_TID    _os_tsk_create (U32 p, void (*task)(void), U32 prio_stksz,
N                                        void *stk, void *argv)         __SVC_0;
X                                        void *stk, void *argv)         __svc_indirect(0);
Nextern OS_TID    _os_tsk_create_ex (U32 p, void (*task)(void *), U32 prio_stksz,
N                                           void *stk, void *argv)      __SVC_0;
X                                           void *stk, void *argv)      __svc_indirect(0);
Nextern OS_TID    _os_tsk_self (U32 p)                                  __SVC_0;
Xextern OS_TID    _os_tsk_self (U32 p)                                  __svc_indirect(0);
Nextern void      _os_tsk_pass (U32 p)                                  __SVC_0;
Xextern void      _os_tsk_pass (U32 p)                                  __svc_indirect(0);
Nextern OS_RESULT _os_tsk_prio (U32 p, OS_TID task_id, U8 new_prio)     __SVC_0;
Xextern OS_RESULT _os_tsk_prio (U32 p, OS_TID task_id, U8 new_prio)     __svc_indirect(0);
Nextern OS_RESULT _os_tsk_delete (U32 p, OS_TID task_id)                __SVC_0;
Xextern OS_RESULT _os_tsk_delete (U32 p, OS_TID task_id)                __svc_indirect(0);
N
N/* Event flag Management */
Nextern OS_RESULT rt_evt_wait (U16 wait_flags,  U16 timeout, BOOL and_wait);
Nextern void      rt_evt_set  (U16 event_flags, OS_TID task_id);
Nextern void      rt_evt_clr  (U16 clear_flags, OS_TID task_id);
Nextern U16       rt_evt_get  (void);
N
N#define os_evt_wait_or(wflags,tmo)    _os_evt_wait((U32)rt_evt_wait,wflags,tmo,__FALSE)
N#define os_evt_wait_and(wflags,tmo)   _os_evt_wait((U32)rt_evt_wait,wflags,tmo,__TRUE)
N#define os_evt_set(evt_flags,task_id) _os_evt_set((U32)rt_evt_set,evt_flags,task_id)
N#define os_evt_clr(clr_flags,task_id) _os_evt_clr((U32)rt_evt_clr,clr_flags,task_id)
N#define os_evt_get()                  _os_evt_get((U32)rt_evt_get)
N
Nextern OS_RESULT _os_evt_wait(U32 p, U16 wait_flags, U16 timeout,
N                                     BOOL and_wait)                    __SVC_0;
X                                     BOOL and_wait)                    __svc_indirect(0);
Nextern void      _os_evt_set (U32 p, U16 event_flags, OS_TID task_id)  __SVC_0;
Xextern void      _os_evt_set (U32 p, U16 event_flags, OS_TID task_id)  __svc_indirect(0);
Nextern void      _os_evt_clr (U32 p, U16 clear_flags, OS_TID task_id)  __SVC_0;
Xextern void      _os_evt_clr (U32 p, U16 clear_flags, OS_TID task_id)  __svc_indirect(0);
Nextern U16       _os_evt_get (U32 p)                                   __SVC_0;
Xextern U16       _os_evt_get (U32 p)                                   __svc_indirect(0);
Nextern void      isr_evt_set (U16 event_flags, OS_TID task_id);
N
N/* Semaphore Management */
Nextern void      rt_sem_init (OS_ID semaphore, U16 token_count);
Nextern OS_RESULT rt_sem_send (OS_ID semaphore);
Nextern OS_RESULT rt_sem_wait (OS_ID semaphore, U16 timeout);
N
N#define os_sem_init(sem,t_count)     _os_sem_init((U32)rt_sem_init,sem,t_count)
N#define os_sem_send(sem)             _os_sem_send((U32)rt_sem_send,sem)
N#define os_sem_wait(sem,tmo)         _os_sem_wait((U32)rt_sem_wait,sem,tmo)
N
Nextern void      _os_sem_init (U32 p, OS_ID semaphore, 
N                                      U16 token_count)                 __SVC_0;
X                                      U16 token_count)                 __svc_indirect(0);
Nextern OS_RESULT _os_sem_send (U32 p, OS_ID semaphore)                 __SVC_0;
Xextern OS_RESULT _os_sem_send (U32 p, OS_ID semaphore)                 __svc_indirect(0);
Nextern OS_RESULT _os_sem_wait (U32 p, OS_ID semaphore, U16 timeout)    __SVC_0;
Xextern OS_RESULT _os_sem_wait (U32 p, OS_ID semaphore, U16 timeout)    __svc_indirect(0);
Nextern void      isr_sem_send (OS_ID semaphore);
N
N/* Mailbox Management */
Nextern void      rt_mbx_init  (OS_ID mailbox, U16 mbx_size);
Nextern OS_RESULT rt_mbx_send  (OS_ID mailbox, void *p_msg,    U16 timeout);
Nextern OS_RESULT rt_mbx_wait  (OS_ID mailbox, void **message, U16 timeout);
Nextern OS_RESULT rt_mbx_check (OS_ID mailbox);
N
N#define os_mbx_init(mbx,mbx_size)     _os_mbx_init((U32)rt_mbx_init,mbx,mbx_size)
N#define os_mbx_send(mbx,p_msg,tmo)    _os_mbx_send((U32)rt_mbx_send,mbx,p_msg,tmo)
N#define os_mbx_wait(mbx,message,tmo)  _os_mbx_wait((U32)rt_mbx_wait,mbx,message,tmo)
N#define os_mbx_check(mbx)             _os_mbx_check((U32)rt_mbx_check,mbx)
N#define isr_mbx_check(mbx)            rt_mbx_check(mbx)
N
Nextern void      _os_mbx_init (U32 p, OS_ID mailbox, U16 mbx_size)     __SVC_0;
Xextern void      _os_mbx_init (U32 p, OS_ID mailbox, U16 mbx_size)     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_send (U32 p, OS_ID mailbox, void *message_ptr,
N                                      U16 timeout)                     __SVC_0;
X                                      U16 timeout)                     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_wait (U32 p, OS_ID mailbox, void  **message,
N                                      U16 timeout)                     __SVC_0;
X                                      U16 timeout)                     __svc_indirect(0);
Nextern OS_RESULT _os_mbx_check (U32 p, OS_ID mailbox)                  __SVC_0;
Xextern OS_RESULT _os_mbx_check (U32 p, OS_ID mailbox)                  __svc_indirect(0);
Nextern void      isr_mbx_send (OS_ID mailbox, void *message_ptr);
Nextern OS_RESULT isr_mbx_receive (OS_ID mailbox, void **message);
N
N/* Mutex Management */
Nextern void      rt_mut_init    (OS_ID mutex);
Nextern OS_RESULT rt_mut_release (OS_ID mutex);
Nextern OS_RESULT rt_mut_wait    (OS_ID mutex, U16 timeout);
N
N#define os_mut_init(mutex)         _os_mut_init((U32)rt_mut_init,mutex)
N#define os_mut_release(mutex)      _os_mut_release((U32)rt_mut_release,mutex)
N#define os_mut_wait(mutex,timeout) _os_mut_wait((U32)rt_mut_wait,mutex,timeout)
N
Nextern void      _os_mut_init (U32 p, OS_ID mutex)                     __SVC_0;
Xextern void      _os_mut_init (U32 p, OS_ID mutex)                     __svc_indirect(0);
Nextern OS_RESULT _os_mut_release (U32 p, OS_ID mutex)                  __SVC_0;
Xextern OS_RESULT _os_mut_release (U32 p, OS_ID mutex)                  __svc_indirect(0);
Nextern OS_RESULT _os_mut_wait (U32 p, OS_ID mutex, U16 timeout)        __SVC_0;
Xextern OS_RESULT _os_mut_wait (U32 p, OS_ID mutex, U16 timeout)        __svc_indirect(0);
N
N/* Time Management */
Nextern void      rt_dly_wait (U16 delay_time);
Nextern void      rt_itv_set  (U16 interval_time);
Nextern void      rt_itv_wait (void);
N
N#define os_dly_wait(delay_time)    _os_dly_wait((U32)rt_dly_wait,delay_time)
N#define os_itv_set(interval_time)  _os_itv_set((U32)rt_itv_set,interval_time)
N#define os_itv_wait()              _os_itv_wait((U32)rt_itv_wait)
N
Nextern void      _os_dly_wait (U32 p, U16 delay_time)                  __SVC_0;
Xextern void      _os_dly_wait (U32 p, U16 delay_time)                  __svc_indirect(0);
Nextern void      _os_itv_set (U32 p, U16 interval_time)                __SVC_0;
Xextern void      _os_itv_set (U32 p, U16 interval_time)                __svc_indirect(0);
Nextern void      _os_itv_wait (U32 p)                                  __SVC_0;
Xextern void      _os_itv_wait (U32 p)                                  __svc_indirect(0);
N
N/* User Timer Management */
Nextern OS_ID     rt_tmr_create (U16 tcnt, U16 info);
Nextern OS_ID     rt_tmr_kill   (OS_ID timer);
N
N#define os_tmr_create(tcnt,info)   _os_tmr_create((U32)rt_tmr_create,tcnt,info)
N#define os_tmr_kill(timer)         _os_tmr_kill((U32)rt_tmr_kill,timer)
N
Nextern OS_ID     _os_tmr_create (U32 p, U16 tcnt, U16 info)            __SVC_0;
Xextern OS_ID     _os_tmr_create (U32 p, U16 tcnt, U16 info)            __svc_indirect(0);
Nextern OS_ID     _os_tmr_kill (U32 p, OS_ID timer)                     __SVC_0;
Xextern OS_ID     _os_tmr_kill (U32 p, OS_ID timer)                     __svc_indirect(0);
N
N/* System Functions */
Nextern void      rt_tsk_lock   (void);
Nextern void      rt_tsk_unlock (void);
N
N#define tsk_lock()                 _os_tsk_lock((U32)rt_tsk_lock)
N#define tsk_unlock()               _os_tsk_unlock((U32)rt_tsk_unlock)
N
Nextern void      _os_tsk_lock (U32 p)                                  __SVC_0;
Xextern void      _os_tsk_lock (U32 p)                                  __svc_indirect(0);
Nextern void      _os_tsk_unlock (U32 p)                                __SVC_0;
Xextern void      _os_tsk_unlock (U32 p)                                __svc_indirect(0);
N
N/* Fixed Memory Block Management Functions */
Nextern int       _init_box (void *box_mem, U32 box_size, U32 blk_size);
Nextern void     *_alloc_box (void *box_mem);
Nextern void     *_calloc_box (void *box_mem);
Nextern int       _free_box (void *box_mem, void *box);
N
N#endif
N
N#define BOX_ALIGN_8     0x80000000
N#define _declare_box(pool,size,cnt)   U32 pool[(((size)+3)/4)*(cnt) + 3]
N#define _declare_box8(pool,size,cnt)  U64 pool[(((size)+7)/8)*(cnt) + 2]
N#define _init_box8(pool,size,bsize)   _init_box (pool,size,bsize | BOX_ALIGN_8)
N
N/* For compatibility with older configurations.*/
N#define os_stk_overflow         os_error
N
N/*----------------------------------------------------------------------------
N *                        Flash File System API
N *---------------------------------------------------------------------------*/
N
Ntypedef struct {                        /* RL Time format (FFS, TCPnet)      */
N  U8  hr;                               /* Hours    [0..23]                  */
N  U8  min;                              /* Minutes  [0..59]                  */
N  U8  sec;                              /* Seconds  [0..59]                  */
N  U8  day;                              /* Day      [1..31]                  */
N  U8  mon;                              /* Month    [1..12]                  */
N  U16 year;                             /* Year     [1980..2107]             */
N} RL_TIME;
N
Ntypedef struct {                        /* Search info record                */
N  S8  name[256];                        /* Name                              */
N  U32 size;                             /* File size in bytes                */
N  U16 fileID;                           /* System Identification             */
N  U8  attrib;                           /* Attributes                        */
N  RL_TIME time;                         /* Create/Modify Time                */
N} FINFO;
N
Nextern int finit (const char *drive);
Nextern int funinit (const char *drive);
Nextern int fdelete (const char *filename);
Nextern int frename (const char *oldname, const char *newname);
Nextern int ffind (const char *pattern, FINFO *info);
Nextern U64 ffree (const char *drive);
Nextern int fformat (const char *drive);
Nextern int fanalyse (const char *drive);
Nextern int fcheck (const char *drive);
Nextern int fdefrag (const char *drive);
N
N/* The following macros provide for common functions */
N#define unlink(fn)      fdelete(fn);
N
N/*----------------------------------------------------------------------------
N *                             TCPnet API
N *---------------------------------------------------------------------------*/
N
N/* UDP Options */
N#define UDP_OPT_SEND_CS    0x01   /* Calculate Checksum for UDP send frames  */
N#define UDP_OPT_CHK_CS     0x02   /* Verify Checksum for received UDP frames */
N
N/* TCP Socket Types */
N#define TCP_TYPE_SERVER    0x01   /* Socket Type Server (open for listening) */
N#define TCP_TYPE_CLIENT    0x02   /* Socket Type Client (initiate connect)   */
N#define TCP_TYPE_DELAY_ACK 0x04   /* Socket Type Delayed Acknowledge         */
N#define TCP_TYPE_FLOW_CTRL 0x08   /* Socket Type Flow Control                */
N#define TCP_TYPE_KEEP_ALIVE 0x10  /* Socket Type Keep Alive                  */
N#define TCP_TYPE_CLIENT_SERVER (TCP_TYPE_SERVER | TCP_TYPE_CLIENT)
N
N/* TCP Callback Events */
N#define TCP_EVT_CONREQ     0      /* Connect request received event          */
N#define TCP_EVT_CONNECT    1      /* Connection established event            */
N#define TCP_EVT_CLOSE      2      /* Connection was properly closed          */
N#define TCP_EVT_ABORT      3      /* Connection is for some reason aborted   */
N#define TCP_EVT_ACK        4      /* Previously send data acknowledged       */
N#define TCP_EVT_DATA       5      /* Data received event                     */
N
N/* TCP States */
N#define TCP_STATE_FREE     0      /* Entry is free and unused                */
N#define TCP_STATE_CLOSED   1      /* Entry allocated, socket still closed    */
N#define TCP_STATE_LISTEN   2      /* Socket waiting for incoming connection  */
N#define TCP_STATE_SYN_REC  3      /* SYN frame received                      */
N#define TCP_STATE_SYN_SENT 4      /* SYN packet sent to establish a connect. */
N#define TCP_STATE_FINW1    5      /* Tcp_close started FIN packet was sent   */
N#define TCP_STATE_FINW2    6      /* Our FIN ack-ed, waiting for remote FIN  */
N#define TCP_STATE_CLOSING  7      /* Received FIN independently of our FIN   */
N#define TCP_STATE_LAST_ACK 8      /* Waiting for last ACK for our FIN        */
N#define TCP_STATE_TWAIT    9      /* Timed waiting for 2MSL                  */
N#define TCP_STATE_CONNECT  10     /* TCP Connection established              */
N
N/* DNS Callback Events */
N#define DNS_EVT_SUCCESS    0      /* Host name successfully resolved         */
N#define DNS_EVT_NONAME     1      /* DNS Error, no such name                 */
N#define DNS_EVT_TIMEOUT    2      /* Timeout resolving host                  */
N#define DNS_EVT_ERROR      3      /* Erroneous response packet               */
N
N/* DNS 'get_host_by_name()' result codes */
N#define DNS_RES_OK         0      /* Function finished OK                    */
N#define DNS_ERROR_BUSY     1      /* DNS Client busy, can't process request  */
N#define DNS_ERROR_LABEL    2      /* Host name Label too long                */
N#define DNS_ERROR_NAME     3      /* Host name loo long                      */
N#define DNS_ERROR_NOSRV    4      /* Prim. DNS server not specified (0.0.0.0)*/
N#define DNS_ERROR_UDPSEND  5      /* UDP Send frame error                    */
N
N/* SMTP Callback Events */
N#define SMTP_EVT_SUCCESS   0      /* Email successfully sent                 */
N#define SMTP_EVT_TIMEOUT   1      /* Timeout sending email                   */
N#define SMTP_EVT_ERROR     2      /* Error when sending email                */
N
N/* ARP Cache Entry types */
N#define ARP_FIXED_IP       0      /* Fixed IP adrs is refreshed after tout   */
N#define ARP_TEMP_IP        1      /* Temp adrs is removed after timeout      */
N
Nextern void init_TcpNet (void);
Nextern void main_TcpNet (void);
Nextern void timer_tick (void);
Nextern U8   udp_get_socket (U8 tos, U8 opt, 
N                            U16 (*listener)(U8 socket, U8 *remip, U16 port, U8 *buf, U16 len));
Nextern BOOL udp_release_socket (U8 socket);
Nextern BOOL udp_open (U8 socket, U16 locport);
Nextern BOOL udp_close (U8 socket);
Nextern BOOL udp_mcast_ttl (U8 socket, U8 ttl);
Nextern U8  *udp_get_buf (U16 size);
Nextern BOOL udp_send (U8 socket, U8 *remip, U16 remport, U8 *buf, U16 dlen);
Nextern U8   tcp_get_socket (U8 type, U8 tos, U16 tout,
N                            U16 (*listener)(U8 socket, U8 event, U8 *buf, U16 len));
Nextern BOOL tcp_release_socket (U8 socket);
Nextern BOOL tcp_listen (U8 socket, U16 locport);
Nextern BOOL tcp_connect (U8 socket, U8 *remip, U16 remport, U16 locport);
Nextern U8  *tcp_get_buf (U16 size);
Nextern U16  tcp_max_dsize (U8 socket);
Nextern BOOL tcp_check_send (U8 socket);
Nextern U8   tcp_get_state (U8 socket);
Nextern BOOL tcp_send (U8 socket, U8 *buf, U16 dlen);
Nextern BOOL tcp_close (U8 socket);
Nextern BOOL tcp_abort (U8 socket);
Nextern void tcp_reset_window (U8 socket);
Nextern BOOL arp_cache_ip (U8 *ipadr, U8 type);
Nextern void ppp_listen (char const *user, char const *passw);
Nextern void ppp_connect (char const *dialnum, char const *user, char const *passw);
Nextern void ppp_close (void);
Nextern BOOL ppp_is_up (void);
Nextern void slip_listen (void);
Nextern void slip_connect (char const *dialnum);
Nextern void slip_close (void);
Nextern BOOL slip_is_up (void);
Nextern U8   get_host_by_name (U8 *hostn, void (*cbfunc)(U8 event, U8 *host_ip));
Nextern BOOL smtp_connect (U8 *ipadr, U16 port, void (*cbfunc)(U8 event));
Nextern void dhcp_disable (void);
Nextern BOOL igmp_join (U8 *group_ip);
Nextern BOOL igmp_leave (U8 *group_ip);
Nextern BOOL snmp_trap (U8 *manager_ip, U8 gen_trap, U8 spec_trap, U16 *obj_list);
Nextern BOOL snmp_set_community (const char *community);
N#ifdef __cplusplus               // EC++
S}
N#endif
N
N/*----------------------------------------------------------------------------
N * end of file
N *---------------------------------------------------------------------------*/
N  
N#endif
N 
L 12 "main.c" 2
N
N
N
N/************************************************************************
N
N   Copyright 2008 Mark Pictor
N
NThis file is part of RS274NGC.
N
NRS274NGC is free software: you can redistribute it and/or modify
Nit under the terms of the GNU General Public License as published by
Nthe Free Software Foundation, either version 3 of the License, or
N(at your option) any later version.
N
NRS274NGC is distributed in the hope that it will be useful,
Nbut WITHOUT ANY WARRANTY; without even the implied warranty of
NMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
NGNU General Public License for more details.
N
NYou should have received a copy of the GNU General Public License
Nalong with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
NThis software is based on software that was produced by the National
NInstitute of Standards and Technology (NIST).
N
N************************************************************************/
N
N#include "rs274ngc.h"
L 1 "rs274ngc.h" 1
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N#ifndef RS274NGC_HH
N#define RS274NGC_HH
N
N   /*
N     rs274ngc.hh
N
N   Declarations for the rs274abc translator.
N
N   */
N
N   /**********************/
N   /* INCLUDE DIRECTIVES */
N   /**********************/
N
N#include <stdio.h>
N#include "canon.h"
L 1 "canon.h" 1
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N#ifndef CANON_HH
N#define CANON_HH
N
N   /* canon.hh
N
N   This is the header file that all applications that use the
N   canonical commands for three- to six-axis machining should include.
N
N   Three mutually orthogonal (in a right-handed system) X, Y, and Z axes
N   are always present. In addition, there may be zero to three rotational
N   axes: A (parallel to the X-axis), B (parallel to the Y-axis), and C
N   (parallel to the Z-axis).
N
N   In the functions that use rotational axes, the axis value is that of a
N   wrapped linear axis, in degrees.
N
N   It is assumed in these activities that the spindle tip is always at
N   some location called the "current location," and the controller always
N   knows where that is. It is also assumed that there is always a
N   "selected plane" which must be the XY-plane, the YZ-plane, or the
N   ZX-plane of the machine.
N
N   */
N
Ntypedef int CANON_PLANE;
N#define CANON_PLANE_XY 1
N#define CANON_PLANE_YZ 2
N#define CANON_PLANE_XZ 3
N
Ntypedef int CANON_UNITS;
N#define CANON_UNITS_INCHES 1
N#define CANON_UNITS_MM 2
N#define CANON_UNITS_CM 3
N
Ntypedef int CANON_MOTION_MODE;
N#define CANON_EXACT_STOP 1
N#define CANON_EXACT_PATH 2
N#define CANON_CONTINUOUS 3
N
Ntypedef int CANON_SPEED_FEED_MODE;
N#define CANON_SYNCHED 1
N#define CANON_INDEPENDENT 2
N
Ntypedef int CANON_DIRECTION;
N#define CANON_STOPPED 1
N#define CANON_CLOCKWISE 2
N#define CANON_COUNTERCLOCKWISE 3
N
Ntypedef int CANON_FEED_REFERENCE;
N#define CANON_WORKPIECE 1
N#define CANON_XYZ 2
N
Ntypedef int CANON_SIDE;
N#define CANON_SIDE_RIGHT 1
N#define CANON_SIDE_LEFT 2
N#define CANON_SIDE_OFF 3
N
Ntypedef int CANON_AXIS;
N#define CANON_AXIS_X 1
N#define CANON_AXIS_Y 2
N#define CANON_AXIS_Z 3
N#define CANON_AXIS_A 4
N#define CANON_AXIS_B 5
N#define CANON_AXIS_C 6
N
N   /* Currently using the typedefs above rather than the enums below
N   typedef enum {CANON_PLANE_XY, CANON_PLANE_YZ, CANON_PLANE_XZ} CANON_PLANE;
N   typedef enum {CANON_UNITS_INCHES, CANON_UNITS_MM, CANON_UNITS_CM} CANON_UNITS;
N   typedef enum {CANON_EXACT_STOP, CANON_EXACT_PATH, CANON_CONTINUOUS}
N   CANON_MOTION_MODE;
N   typedef enum {CANON_SYNCHED, CANON_INDEPENDENT} CANON_SPEED_FEED_MODE;
N   typedef enum {CANON_STOPPED, CANON_CLOCKWISE, CANON_COUNTERCLOCKWISE}
N   CANON_DIRECTION;
N   typedef enum {CANON_WORKPIECE, CANON_XYZ} CANON_FEED_REFERENCE;
N   typedef enum {CANON_SIDE_RIGHT, CANON_SIDE_LEFT, CANON_SIDE_OFF} CANON_SIDE;
N   typedef enum {CANON_AXIS_X, CANON_AXIS_Y, CANON_AXIS_Z, CANON_AXIS_A,
N   CANON_AXIS_B, CANON_AXIS_C} CANON_AXIS;
N   */
N
N/*
Nstruct CANON_VECTOR
N{
N    double x, y, z;
N    CANON_VECTOR() {}
N    CANON_VECTOR(double _x, double _y, double _z) 
N	{
N		x = _x; y = _y; z = _z;
N	}
N};
N
Nstruct CANON_POSITION
N{
N    CANON_POSITION() {}
N    CANON_POSITION(double _x, double _y, double _z
N    #ifdef AA
N        , double _a
N    #endif
N    #ifdef BB
N        , double _b
N    #endif
N    #ifdef CC
N        , double _c
N    #endif
N        )
N    {
N        x = _x; y = _y; z = _z;
N#ifdef AA
N        a = _a;
N#endif
N#ifdef BB
N        b = _b;
N#endif
N#ifdef CC
N        c = _c;
N#endif
N    }
N    double x, y, z
N    #ifdef AA
N        , a
N    #endif
N    #ifdef BB
N        , b
N    #endif
N    #ifdef CC
N        , c
N    #endif
N        ;
N};
N*/
N
N   /* Tools are numbered 1..CANON_TOOL_MAX, with tool 0 meaning no tool. */
N#define CANON_TOOL_MAX 128                        // max size of carousel handled
N#define CANON_TOOL_ENTRY_LEN 256                  // how long each file line can be
N
Ntypedef struct canon_tool_table
N{
N    int id;
N    double length;
N    double diameter;
N}CANON_TOOL_TABLE;
N
N   /* Initialization */
N
N   /* reads world model data into the canonical interface */
W "canon.h" 169 13 Deprecated declaration INIT_CANON - give arg types
Nextern void INIT_CANON();
N
N   /* Representation */
N
Nextern void SET_ORIGIN_OFFSETS(
Ndouble x, double y, double z
N#ifdef AA
S, double a
N#else
N#ifdef ALL_AXES
S, double a
N#endif
N#endif
N#ifdef BB
S, double b
N#else
N#ifdef ALL_AXES
S, double b
N#endif
N#endif
N#ifdef CC
S, double c
N#else
N#ifdef ALL_AXES
S, double c
N#endif
N#endif
N);
N
N   /* Offset the origin to the point with absolute coordinates x, y, z,
N   a, b, and c. Values of x, y, z, a, b, and c are real numbers. The units
N   are whatever length units are being used at the time this command is
N   given. */
N
Nextern void USE_LENGTH_UNITS(CANON_UNITS u);
N
N   /* Use the specified units for length. Conceptually, the units must
N   be either inches or millimeters. */
N
Nextern void SELECT_PLANE(CANON_PLANE pl);
N
N   /* Use the plane designated by selected_plane as the selected plane.
N   Conceptually, the selected_plane must be the XY-plane, the XZ-plane, or
N   the YZ-plane. */
N
N   /* Free Space Motion */
N
Nextern void SET_TRAVERSE_RATE(double rate);
N
N   /* Set the traverse rate that will be used when the spindle traverses. It
N   is expected that no cutting will occur while a traverse move is being
N   made. */
N
Nextern void STRAIGHT_TRAVERSE(
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N   /*
N
N   Move at traverse rate so that at any time during the move, all axes
N   have covered the same proportion of their required motion. The final
N   XYZ position is given by x, y, and z. If there is an a-axis, its final
N   position is given by a_position, and similarly for the b-axis and c-axis.
N   A more positive value of a rotational axis is in the counterclockwise
N   direction.
N
N   Clockwise or counterclockwise is from the point of view of the
N   workpiece. If the workpiece is fastened to a turntable, the turntable
N   will turn clockwise (from the point of view of the machinist or anyone
N   else not moving with respect to the machining center) in order to make
N   the tool move counterclockwise from the point of view of the
N   workpiece.
N
N   */
N
N   /* Machining Attributes */
N
Nextern void SET_FEED_RATE(double rate);
N
N   /* 
N
N   SET_FEED_RATE sets the feed rate that will be used when the spindle is
N   told to move at the currently set feed rate. The rate is either:
N   1. the rate of motion of the tool tip in the workpiece coordinate system,
N   which is used when the feed_reference mode is "CANON_WORKPIECE", or
N   2. the rate of motion of the tool tip in the XYZ axis system, ignoring
N   motion of other axes, which is used when the feed_reference mode is
N   "CANON_XYZ".
N
N   The units of the rate are:
N
N   1. If the feed_reference mode is CANON_WORKPIECE:
N   length units (inches or millimeters according to the setting of
N   CANON_UNITS) per minute along the programmed path as seen by the
N   workpiece.
N
N   2. If the feed_reference mode is CANON_XYZ:
N   A. For motion including one rotational axis only: degrees per minute.
N   B. For motion including two rotational axes only: degrees per minute
N   In this case, the rate applies to the axis with the larger angle
N   to cover, and the second rotational axis rotates so that it has
N   always completed the same proportion of its required motion as has
N   the rotational axis to which the feed rate applies.
N   C. For motion involving one or more of the XYZ axes (with or without
N   simultaneous rotational axis motion): length units (inches or
N   millimeters according to the setting of CANON_UNITS) per minute
N   along the programmed XYZ path.
N
N   */
N
Nextern void SET_FEED_REFERENCE(CANON_FEED_REFERENCE reference);
N
N   /*
N
N   This sets the feed_reference mode to either CANON_WORKPIECE or
N   CANON_XYZ.
N
N   The CANON_WORKPIECE mode is more natural and general, since the rate
N   at which the tool passes through the material must be controlled for
N   safe and effective machining. For machines with more than the three
N   standard XYZ axes, however, computing the feed rate may be
N   time-consuming because the trajectories that result from motion in
N   four or more axes may be complex. Computation of path lengths when
N   only XYZ motion is considered is quite simple for the two standard
N   motion types (straight lines and helical arcs).
N
N   Some programming languages (rs274kt, in particular) use CANON_XYZ
N   mode. In these languages, the task of dealing with the rate at which
N   the tool tip passes through material is pushed back on the NC-program
N   generator, where the computation of path lengths is (almost always in
N   1995) an off-line activity where speed of calculation is not critical.
N
N   In CANON_WORKPIECE mode, some motions cannot be carried out as fast as
N   the programmed feed rate would require because axis motions tend to
N   cancel each other. For example, an arc in the YZ-plane can exactly
N   cancel a rotation around the A-axis, so that the location of the tool
N   tip with respect to the workpiece does not change at all during the
N   motion; in this case, the motion should take no time, which is
N   impossible at any finite rate of axis motion. In such cases, the axes
N   should be moved as fast as possible consistent with accurate
N   machining.
N
N   It would be possible to omit the SET_FEED_REFERENCE command from the
N   canonical commands and operate always in one mode or the other,
N   letting the interpreter issue SET_FEED_RATE commands, if necessary to
N   compensate if the NC language being interpreted used the other mode.
N
N   This would create two disadvantages when the feed_reference mode
N   assumed by the canonical commands differed from that assumed by the NC
N   language being interpreted:
N
N   1. The output code could have a lot of SET_FEED_RATE commands not
N   found in the input code; this is a relatively minor consideration.
N
N   2. If the interpreter reads a program in language which uses the
N   CANON_XYZ mode and writes canonical commands in the CANON_WORKPIECE
N   mode, both the interpreter and the executor of the output canonical
N   commands would have to perform a lot of complex calculations. With the
N   SET_FEED_REFERENCE command available, both do only simple calculations
N   for the same motions.
N
N   */
N
Nextern void SET_MOTION_CONTROL_MODE(CANON_MOTION_MODE mode);
N
N   /*
N
N   This sets the motion control mode to one of: CANON_EXACT_STOP,
N   CANON_EXACT_PATH, or CANON_CONTINUOUS.
N
N   */
N
Nextern void SET_CUTTER_RADIUS_COMPENSATION(double radius);
N
N   /* Set the radius to use when performing cutter radius compensation. */
N
Nextern void START_CUTTER_RADIUS_COMPENSATION(int direction);
N
N   /* Conceptually, the direction must be left (meaning the cutter
N   stays to the left of the programmed path) or right. */
N
W "canon.h" 370 13 Deprecated declaration STOP_CUTTER_RADIUS_COMPENSATION - give arg types
Nextern void STOP_CUTTER_RADIUS_COMPENSATION();
N
N   /* Do not apply cutter radius compensation when executing spindle
N   translation commands. */
N
W "canon.h" 375 13 Deprecated declaration START_SPEED_FEED_SYNCH - give arg types
Nextern void START_SPEED_FEED_SYNCH();
W "canon.h" 376 13 Deprecated declaration STOP_SPEED_FEED_SYNCH - give arg types
Nextern void STOP_SPEED_FEED_SYNCH();
N
N   /* Machining Functions */
N
Nextern void ARC_FEED(
Ndouble first_end,
Ndouble second_end,
Ndouble first_axis,
Ndouble second_axis,
Nint rotation,
Ndouble axis_end_point
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Move in a helical arc from the current location at the existing feed
N   rate. The axis of the helix is parallel to the x, y, or z axis,
N   according to which one is perpendicular to the selected plane. The
N   helical arc may degenerate to a circular arc if there is no motion
N   parallel to the axis of the helix.
N
N   1. If the selected plane is the xy-plane:
N   A. first_end is the x-coordinate of the end of the arc.
N   B. second_end is the y-coordinate of the end of the arc.
N   C. first_axis is the x-coordinate of the axis (center) of the arc.
N   D. second_axis is the y-coordinate of the axis.
N   E. axis_end_point is the z-coordinate of the end of the arc.
N
N   2. If the selected plane is the yz-plane:
N   A. first_end is the y-coordinate of the end of the arc.
N   B. second_end is the z-coordinate of the end of the arc.
N   C. first_axis is the y-coordinate of the axis (center) of the arc.
N   D. second_axis is the z-coordinate of the axis.
N   E. axis_end_point is the x-coordinate of the end of the arc.
N
N   3. If the selected plane is the zx-plane:
N   A. first_end is the z-coordinate of the end of the arc.
N   B. second_end is the x-coordinate of the end of the arc.
N   C. first_axis is the z-coordinate of the axis (center) of the arc.
N   D. second_axis is the x-coordinate of the axis.
N   E. axis_end_point is the y-coordinate of the end of the arc.
N
N   If rotation is positive, the arc is traversed counterclockwise as
N   viewed from the positive end of the coordinate axis perpendicular to
N   the currently selected plane. If rotation is negative, the arc is
N   traversed clockwise. If rotation is 0, first_end and second_end must
N   be the same as the corresponding coordinates of the current point and
N   no arc is made (but there may be translation parallel to the axis
N   perpendicular to the selected plane and motion along the rotational axes).
N   If rotation is 1, more than 0 but not more than 360 degrees of arc
N   should be made. In general, if rotation is n, the amount of rotation
N   in the arc should be more than ([n-1] x 360) but not more than (n x
N   360).
N
N   The radius of the helix is determined by the distance from the current
N   location to the axis of helix or by the distance from the end location
N   to the axis of the helix. It is recommended that the executing system
N   verify that the two radii are the same (within some tolerance) at the
N   beginning of executing this function.
N
N   While the XYZ motion is going on, move the rotational axes so that
N   they have always covered the same proportion of their total motion as
N   a point moving along the arc has of its total motion.
N
N   */
N
Nextern void STRAIGHT_FEED(
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Move at existing feed rate so that at any time during the move,
N   all axes have covered the same proportion of their required motion.
N   The meanings of the parameters is the same as for STRAIGHT_TRAVERSE.*/
N
Nextern void STRAIGHT_PROBE (
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Perform a probing operation. This is a temporary addition to the
N   canonical machining functions and its semantics are not defined.
N   When the operation is finished, all axes should be back where they
N   started. */
N
W "canon.h" 520 13 Deprecated declaration STOP - give arg types
Nextern void STOP();
N
N   /* stop motion after current feed */
N
Nextern void DWELL(double seconds);
N
N   /* freeze x,y,z for a time */
N
N   /* Spindle Functions */
N
W "canon.h" 530 13 Deprecated declaration SPINDLE_RETRACT_TRAVERSE - give arg types
Nextern void SPINDLE_RETRACT_TRAVERSE();
N
N   /* Retract the spindle at traverse rate to the fully retracted position. */
N
W "canon.h" 534 13 Deprecated declaration START_SPINDLE_CLOCKWISE - give arg types
Nextern void START_SPINDLE_CLOCKWISE();
N
N   /* Turn the spindle clockwise at the currently set speed rate. If the
N   spindle is already turning that way, this command has no effect. */
N
W "canon.h" 539 13 Deprecated declaration START_SPINDLE_COUNTERCLOCKWISE - give arg types
Nextern void START_SPINDLE_COUNTERCLOCKWISE();
N
N   /* Turn the spindle counterclockwise at the currently set speed rate. If
N   the spindle is already turning that way, this command has no effect. */
N
Nextern void SET_SPINDLE_SPEED(double r);
N
N   /* Set the spindle speed that will be used when the spindle is turning.
N   This is usually given in rpm and refers to the rate of spindle
N   rotation. If the spindle is already turning and is at a different
N   speed, change to the speed given with this command. */
N
W "canon.h" 551 13 Deprecated declaration STOP_SPINDLE_TURNING - give arg types
Nextern void STOP_SPINDLE_TURNING();
N
N   /* Stop the spindle from turning. If the spindle is already stopped, this
N   command may be given, but it will have no effect. */
N
W "canon.h" 556 13 Deprecated declaration SPINDLE_RETRACT - give arg types
Nextern void SPINDLE_RETRACT();
Nextern void ORIENT_SPINDLE(double orientation, CANON_DIRECTION direction);
W "canon.h" 558 13 Deprecated declaration LOCK_SPINDLE_Z - give arg types
Nextern void LOCK_SPINDLE_Z();
W "canon.h" 559 13 Deprecated declaration USE_SPINDLE_FORCE - give arg types
Nextern void USE_SPINDLE_FORCE();
W "canon.h" 560 13 Deprecated declaration USE_NO_SPINDLE_FORCE - give arg types
Nextern void USE_NO_SPINDLE_FORCE();
N
N   /* Tool Functions */
Nextern void USE_TOOL_LENGTH_OFFSET(double length);
N
Nextern void CHANGE_TOOL(int slot);                /* slot is slot number */
N
N   /* It is assumed that each cutting tool in the machine is assigned to a
N   slot (intended to correspond to a slot number in a tool carousel).
N   This command results in the tool currently in the spindle (if any)
N   being returned to its slot, and the tool from the slot designated by
N   slot_number (if any) being inserted in the spindle.
N
N   If there is no tool in the slot designated by the slot argument, there
N   will be no tool in the spindle after this command is executed and no
N   error condition will result in the controller. Similarly, if there is
N   no tool in the spindle when this command is given, no tool will be
N   returned to the carousel and no error condition will result in the
N   controller, whether or not a tool was previously selected in the
N   program.
N
N   It is expected that when the machine tool controller is initialized,
N   the designated slot for a tool already in the spindle will be
N   established. This may be done in any manner deemed fit, including
N   (for, example) recording that information in a persistent, crash-proof
N   location so it is always available from the last time the machine was
N   run, or having the operator enter it. It is expected that the machine
N   tool controller will remember that information as long as it is
N   not re-initialized; in particular, it will be remembered between
N   programs.
N
N   For the purposes of this command, the tool includes the tool holder.
N
N   For machines which can carry out a select_tool command separately from
N   a change_tool command, the select_tool command must have been given
N   before the change_tool command, and the value of slot must be the slot
N   number of the selected tool. */
N
Nextern void SELECT_TOOL(int i);                   /* i is slot number */
N
N   /* Miscellaneous Functions */
N
Nextern void CLAMP_AXIS(CANON_AXIS axis);
N
N   /* Clamp the given axis. If the machining center does not have a clamp
N   for that axis, this command should result in an error condition in the
N   controller.
N
N   An attempt to move an axis while it is clamped should result in an
N   error condition in the controller. */
N
Nextern void COMMENT(char *s);
N
N   /* This function has no physical effect. If commands are being printed or
N   logged, the comment command is printed or logged, including the string
N   which is the value of comment_text. This serves to allow formal
N   comments at specific locations in programs or command files. */
N
W "canon.h" 618 13 Deprecated declaration DISABLE_FEED_OVERRIDE - give arg types
Nextern void DISABLE_FEED_OVERRIDE();
W "canon.h" 619 13 Deprecated declaration ENABLE_FEED_OVERRIDE - give arg types
Nextern void ENABLE_FEED_OVERRIDE();
W "canon.h" 620 13 Deprecated declaration DISABLE_SPEED_OVERRIDE - give arg types
Nextern void DISABLE_SPEED_OVERRIDE();
W "canon.h" 621 13 Deprecated declaration ENABLE_SPEED_OVERRIDE - give arg types
Nextern void ENABLE_SPEED_OVERRIDE();
W "canon.h" 622 13 Deprecated declaration FLOOD_OFF - give arg types
Nextern void FLOOD_OFF();
N   /* Turn flood coolant off. */
W "canon.h" 624 13 Deprecated declaration FLOOD_ON - give arg types
Nextern void FLOOD_ON();
N   /* Turn flood coolant on. */
N
Nextern void MESSAGE(char *s);
N
W "canon.h" 629 13 Deprecated declaration MIST_OFF - give arg types
Nextern void MIST_OFF();
N   /* Turn mist coolant off. */
N
W "canon.h" 632 13 Deprecated declaration MIST_ON - give arg types
Nextern void MIST_ON();
N   /* Turn mist coolant on. */
N
W "canon.h" 635 13 Deprecated declaration PALLET_SHUTTLE - give arg types
Nextern void PALLET_SHUTTLE();
N
N   /* If the machining center has a pallet shuttle mechanism (a mechanism
N   which switches the position of two pallets), this command should cause
N   that switch to be made. If either or both of the pallets are missing,
N   this will not result in an error condition in the controller.
N
N   If the machining center does not have a pallet shuttle, this command
N   should result in an error condition in the controller. */
N
W "canon.h" 645 13 Deprecated declaration TURN_PROBE_OFF - give arg types
Nextern void TURN_PROBE_OFF();
W "canon.h" 646 13 Deprecated declaration TURN_PROBE_ON - give arg types
Nextern void TURN_PROBE_ON();
N
Nextern void UNCLAMP_AXIS(CANON_AXIS axis);
N
N   /* Unclamp the given axis. If the machining center does not have a clamp
N   for that axis, this command should result in an error condition in the
N   controller. */
N
N   /* NURB Functions */
W "canon.h" 655 13 Deprecated declaration NURB_KNOT_VECTOR - give arg types
Nextern void NURB_KNOT_VECTOR();                   /* double knot values, -1.0 signals done */
Nextern void NURB_CONTROL_POINT(int i, double x, double y, double z, double w );
Nextern void NURB_FEED(double sStart, double sEnd);
N
N   /* Program Functions */
W "canon.h" 660 13 Deprecated declaration OPTIONAL_PROGRAM_STOP - give arg types
Nextern void OPTIONAL_PROGRAM_STOP();
N
N   /* If the machining center has an optional stop switch, and it is on
N   when this command is read from a program, stop executing the program
N   at this point, but be prepared to resume with the next line of the
N   program. If the machining center does not have an optional stop
N   switch, or commands are being executed with a stop after each one
N   already (such as when the interpreter is being used with keyboard
N   input), this command has no effect. */
N
W "canon.h" 670 13 Deprecated declaration PROGRAM_END - give arg types
Nextern void PROGRAM_END();
N   /* If a program is being read, stop executing the program and be prepared
N   to accept a new program or to be shut down. */
N
W "canon.h" 674 13 Deprecated declaration PROGRAM_STOP - give arg types
Nextern void PROGRAM_STOP();
N   /* If this command is read from a program, stop executing the program at
N   this point, but be prepared to resume with the next line of the
N   program. If commands are being executed with a stop after each one
N   already (such as when the interpreter is being used with keyboard
N   input), this command has no effect. */
N
N   /*************************************************************************/
N
N   /* Canonical "Give me information" functions for the interpreter to call
N
N   In general, returned values are valid only if any canonical do it commands
N   that may have been called for have been executed to completion. If a function
N   returns a valid value regardless of execution, that is noted in the comments
N   below.
N
N   */
N
N   /* The interpreter is not using this function
N   // Returns the system angular unit factor, in units / degree
N   extern double GET_EXTERNAL_ANGLE_UNIT_FACTOR();
N   */
N
N   // Returns the system feed rate
W "canon.h" 698 15 Deprecated declaration GET_EXTERNAL_FEED_RATE - give arg types
Nextern double GET_EXTERNAL_FEED_RATE();
N
N   // Returns the system value for flood coolant, zero = off, non-zero = on
W "canon.h" 701 12 Deprecated declaration GET_EXTERNAL_FLOOD - give arg types
Nextern int GET_EXTERNAL_FLOOD();
N
N   /* The interpreter is not using this function
N   // Returns the system length unit factor, in units / mm
N   extern double GET_EXTERNAL_LENGTH_UNIT_FACTOR();
N   */
N
N   // Returns the system length unit type
W "canon.h" 709 13 Deprecated declaration GET_EXTERNAL_LENGTH_UNIT_TYPE - give arg types
NCANON_UNITS GET_EXTERNAL_LENGTH_UNIT_TYPE();
N
N   // Returns the system value for mist coolant, zero = off, non-zero = on
W "canon.h" 712 12 Deprecated declaration GET_EXTERNAL_MIST - give arg types
Nextern int GET_EXTERNAL_MIST();
N
N   // Returns the current motion control mode
W "canon.h" 715 26 Deprecated declaration GET_EXTERNAL_MOTION_CONTROL_MODE - give arg types
Nextern CANON_MOTION_MODE GET_EXTERNAL_MOTION_CONTROL_MODE();
N
N   /* The interpreter is not using these six GET_EXTERNAL_ORIGIN functions
N
N   #ifdef AA
N   // returns the current a-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_A();
N   #endif
N
N   #ifdef BB
N   // returns the current b-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_B();
N   #endif
N
N   #ifdef CC
N   // returns the current c-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_C();
N   #endif
N
N   // returns the current x-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_X();
N
N   // returns the current y-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_Y();
N
N   // returns the current z-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_Z();
N
N   */
N
N   // returns nothing but copies the name of the parameter file into
N   // the filename array, stopping at max_size if the name is longer
N   // An empty string may be placed in filename.
Nextern void GET_EXTERNAL_PARAMETER_FILE_NAME(char * filename, unsigned int max_size);
N
N   // returns the currently active plane
W "canon.h" 751 20 Deprecated declaration GET_EXTERNAL_PLANE - give arg types
Nextern CANON_PLANE GET_EXTERNAL_PLANE();
N
N#ifdef AA
S   // returns the current a-axis position
Sextern double GET_EXTERNAL_POSITION_A();
N#endif
N
N#ifdef BB
S   // returns the current b-axis position
Sextern double GET_EXTERNAL_POSITION_B();
N#endif
N
N#ifdef CC
S   // returns the current c-axis position
Sextern double GET_EXTERNAL_POSITION_C();
N#endif
N
N   // returns the current x-axis position
W "canon.h" 769 15 Deprecated declaration GET_EXTERNAL_POSITION_X - give arg types
Nextern double GET_EXTERNAL_POSITION_X();
N
N   // returns the current y-axis position
W "canon.h" 772 15 Deprecated declaration GET_EXTERNAL_POSITION_Y - give arg types
Nextern double GET_EXTERNAL_POSITION_Y();
N
N   // returns the current z-axis position
W "canon.h" 775 15 Deprecated declaration GET_EXTERNAL_POSITION_Z - give arg types
Nextern double GET_EXTERNAL_POSITION_Z();
N
N#ifdef AA
S   // Returns the machine A-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_A();
N#endif
N
N#ifdef BB
S   // Returns the machine B-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_B();
N#endif
N
N#ifdef CC
S   // Returns the machine C-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_C();
N#endif
N
N   // Returns the machine X-axis position at the last probe trip.
W "canon.h" 793 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_X - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_X();
N
N   // Returns the machine Y-axis position at the last probe trip.
W "canon.h" 796 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_Y - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_Y();
N
N   // Returns the machine Z-axis position at the last probe trip.
W "canon.h" 799 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_Z - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_Z();
N
N   // Returns the value for any analog non-contact probing.
W "canon.h" 802 15 Deprecated declaration GET_EXTERNAL_PROBE_VALUE - give arg types
Nextern double GET_EXTERNAL_PROBE_VALUE();
N
N   // Returns zero if queue is not empty, non-zero if the queue is empty
N   // This always returns a valid value
W "canon.h" 806 12 Deprecated declaration GET_EXTERNAL_QUEUE_EMPTY - give arg types
Nextern int GET_EXTERNAL_QUEUE_EMPTY();
N
N   // Returns the system value for spindle speed in rpm
W "canon.h" 809 15 Deprecated declaration GET_EXTERNAL_SPEED - give arg types
Nextern double GET_EXTERNAL_SPEED();
N
N   // Returns the system value for direction of spindle turning
W "canon.h" 812 24 Deprecated declaration GET_EXTERNAL_SPINDLE - give arg types
Nextern CANON_DIRECTION GET_EXTERNAL_SPINDLE();
N
N   // returns current tool length offset
W "canon.h" 815 15 Deprecated declaration GET_EXTERNAL_TOOL_LENGTH_OFFSET - give arg types
Nextern double GET_EXTERNAL_TOOL_LENGTH_OFFSET();
N
N   // Returns number of slots in carousel
W "canon.h" 818 12 Deprecated declaration GET_EXTERNAL_TOOL_MAX - give arg types
Nextern int GET_EXTERNAL_TOOL_MAX();
N
N   // Returns the system value for the carousel slot in which the tool
N   // currently in the spindle belongs. Return value zero means there is no
N   // tool in the spindle.
W "canon.h" 823 12 Deprecated declaration GET_EXTERNAL_TOOL_SLOT - give arg types
Nextern int GET_EXTERNAL_TOOL_SLOT();
N
N   // Returns the CANON_TOOL_TABLE structure associated with the tool
N   // in the given pocket
Nextern CANON_TOOL_TABLE GET_EXTERNAL_TOOL_TABLE(int pocket);
N
N   // Returns the system traverse rate
W "canon.h" 830 15 Deprecated declaration GET_EXTERNAL_TRAVERSE_RATE - give arg types
Nextern double GET_EXTERNAL_TRAVERSE_RATE();
N#endif                                            /* ifndef CANON_HH */
L 41 "rs274ngc.h" 2
N
N   /**********************/
N   /*   COMPILER MACROS  */
N   /**********************/
N
N#define AND              &&
N#define IS               ==
N#define ISNT             !=
N#define MAX(x, y)        ((x) > (y) ? (x) : (y))
N#define NOT              !
N#define OR               ||
N#define SET_TO           =
N
N#ifndef TRUE
N#define TRUE             1
N#endif
N
N#ifndef FALSE
N#define FALSE            0
N#endif
N
N#define RS274NGC_TEXT_SIZE 256
N
N   /* numerical constants */
N#define TOLERANCE_INCH 0.0002
N#define TOLERANCE_MM 0.002
N#define TOLERANCE_CONCAVE_CORNER 0.01
N   /* angle threshold for concavity for
N                        cutter compensation, in radians */
N#define TINY 1e-12                                /* for arc_data_r */
N#define UNKNOWN 1e-20
N#define TWO_PI  6.2831853071795864
N
N#ifndef PI
N#define PI      3.1415926535897932
N#endif
N
N#ifndef PI2
N#define PI2     1.5707963267948966
N#endif
N
N   // array sizes
N#define RS274NGC_ACTIVE_G_CODES 12
N#define RS274NGC_ACTIVE_M_CODES 7
N#define RS274NGC_ACTIVE_SETTINGS 3
N
N   // name of parameter file for saving/restoring interpreter variables
N#define RS274NGC_PARAMETER_FILE_NAME_DEFAULT "rs274ngc.var"
N#define RS274NGC_PARAMETER_FILE_BACKUP_SUFFIX ".bak"
N
N   // max number of m codes on one line
N#define MAX_EMS  4
N
N   // English - Metric conversion (long number keeps error buildup down)
N#define MM_PER_INCH 25.4
N#define INCH_PER_MM 0.039370078740157477
N
N   // on-off switch settings
N#define OFF 0
N#define ON 1
N
N   // feed_mode
N#define UNITS_PER_MINUTE 0
N#define INVERSE_TIME 1
N
N   // cutter radius compensation mode, OFF already defined to 0
N   // not using CANON_SIDE since interpreter handles cutter radius comp
N#define RIGHT 1
N#define LEFT 2
N
N   // number of parameters in parameter table
N#define RS274NGC_MAX_PARAMETERS 5400
N
N   // unary operations
N   // These are not enums because the "&" operator is used in
N   // reading the operation names and is illegal with an enum
N
N#define ABS 1
N#define ACOS 2
N#define ASIN 3
N#define ATAN 4
N#define COS 5
N#define EXP 6
N#define FIX 7
N#define FUP 8
N#define LN 9
N#define ROUND 10
N#define SIN 11
N#define SQRT 12
N#define TAN 13
N
N   // binary operations
N#define NO_OPERATION 0
N#define DIVIDED_BY 1
N#define MODULO 2
N#define POWER 3
N#define TIMES 4
N#define AND2 5
N#define EXCLUSIVE_OR 6
N#define MINUS 7
N#define NON_EXCLUSIVE_OR 8
N#define PLUS 9
N#define RIGHT_BRACKET 10
N
N   // G Codes are symbolic to be dialect-independent in source code
N#define G_0      0
N#define G_1     10
N#define G_2     20
N#define G_3     30
N#define G_4     40
N#define G_10   100
N#define G_17   170
N#define G_18   180
N#define G_19   190
N#define G_20   200
N#define G_21   210
N#define G_28   280
N#define G_30   300
N#define G_38_2 382
N#define G_40   400
N#define G_41   410
N#define G_42   420
N#define G_43   430
N#define G_49   490
N#define G_53   530
N#define G_54   540
N#define G_55   550
N#define G_56   560
N#define G_57   570
N#define G_58   580
N#define G_59   590
N#define G_59_1 591
N#define G_59_2 592
N#define G_59_3 593
N#define G_61   610
N#define G_61_1 611
N#define G_64   640
N#define G_80   800
N#define G_81   810
N#define G_82   820
N#define G_83   830
N#define G_84   840
N#define G_85   850
N#define G_86   860
N#define G_87   870
N#define G_88   880
N#define G_89   890
N#define G_90   900
N#define G_91   910
N#define G_92   920
N#define G_92_1 921
N#define G_92_2 922
N#define G_92_3 923
N#define G_93   930
N#define G_94   940
N#define G_98   980
N#define G_99   990
N
N   /**********************/
N   /*      TYPEDEFS      */
N   /**********************/
N
N   /* distance_mode */
Ntypedef enum {MODE_ABSOLUTE, MODE_INCREMENTAL}
NDISTANCE_MODE;
N
N   /* retract_mode for cycles */
Ntypedef enum {R_PLANE, OLD_Z}
NRETRACT_MODE;
N
Ntypedef int ON_OFF;
N
Ntypedef struct block_struct
N{
N#ifdef AA
S    ON_OFF   a_flag;
S    double   a_number;
N#endif
N#ifdef BB
S    ON_OFF   b_flag;
S    double   b_number;
N#endif
N#ifdef CC
S    ON_OFF   c_flag;
S    double   c_number;
N#endif
N    char     comment[256];
N    int      d_number;
N    double   f_number;
N    int      g_modes[14];
N    int      h_number;
N    ON_OFF   i_flag;
N    double   i_number;
N    ON_OFF   j_flag;
N    double   j_number;
N    ON_OFF   k_flag;
N    double   k_number;
N    int      l_number;
N    int      line_number;
N    int      motion_to_be;
N    int      m_count;
N    int      m_modes[10];
N    double   p_number;
N    double   q_number;
N    ON_OFF   r_flag;
N    double   r_number;
N    double   s_number;
N    int      t_number;
N    ON_OFF   x_flag;
N    double   x_number;
N    ON_OFF   y_flag;
N    double   y_number;
N    ON_OFF   z_flag;
N    double   z_number;
N} block;
N
Ntypedef block * block_pointer;
N
N   /*
N
N   The current_x, current_y, and current_z are the location of the tool
N   in the current coordinate system. current_x and current_y differ from
N   program_x and program_y when cutter radius compensation is on.
N   current_z is the position of the tool tip in program coordinates when
N   tool length compensation is using the actual tool length; it is the
N   position of the spindle when tool length is zero.
N
N   In a setup, the axis_offset values are set by g92 and the origin_offset
N   values are set by g54 - g59.3. The net origin offset uses both values
N   and is not represented here
N
N   */
N
Ntypedef struct setup_struct
N{
N#ifdef AA
S    double AA_axis_offset;                        // A-axis g92 offset
S    double AA_current;                            // current A-axis position
S    double AA_origin_offset;                      // A-axis origin offset
N#endif
N#ifdef BB
S    double BB_axis_offset;                        // B-axis g92offset
S    double BB_current;                            // current B-axis position
S    double BB_origin_offset;                      // B-axis origin offset
N#endif
N#ifdef CC
S    double CC_axis_offset;                        // C-axis g92offset
S    double CC_current;                            // current C-axis position
S    double CC_origin_offset;                      // C-axis origin offset
N#endif
N    int active_g_codes
N        [RS274NGC_ACTIVE_G_CODES];                // array of active G codes
X        [12];                
N    int active_m_codes
N        [RS274NGC_ACTIVE_M_CODES];                // array of active M codes
X        [7];                
N    double active_settings
N        [RS274NGC_ACTIVE_SETTINGS];               // array of feed, speed, etc.
X        [3];               
N    double axis_offset_x;                         // X-axis g92 offset
N    double axis_offset_y;                         // Y-axis g92 offset
N    double axis_offset_z;                         // Z-axis g92 offset
N    block block1;                                 // parsed next block
N    char blocktext[RS274NGC_TEXT_SIZE];           // linetext downcased, white space gone
X    char blocktext[256];           
N    CANON_MOTION_MODE control_mode;               // exact path or cutting mode
N    int current_slot;                             // carousel slot number of current tool
N    double current_x;                             // current X-axis position
N    double current_y;                             // current Y-axis position
N    double current_z;                             // current Z-axis position
N    double cutter_comp_radius;                    // current cutter compensation radius
N    int cutter_comp_side;                         // current cutter compensation side
N    double cycle_cc;                              // cc-value (normal) for canned cycles
N    double cycle_i;                               // i-value for canned cycles
N    double cycle_j;                               // j-value for canned cycles
N    double cycle_k;                               // k-value for canned cycles
N    int cycle_l;                                  // l-value for canned cycles
N    double cycle_p;                               // p-value (dwell) for canned cycles
N    double cycle_q;                               // q-value for canned cycles
N    double cycle_r;                               // r-value for canned cycles
N    DISTANCE_MODE distance_mode;                  // absolute or incremental
N    int feed_mode;                                // G_93 (inverse time) or G_94 units/min
N    ON_OFF feed_override;                         // whether feed override is enabled
N    double feed_rate;                             // feed rate in current units/min
N    char filename[RS274NGC_TEXT_SIZE];            // name of currently open NC code file
X    char filename[256];            
N    FILE * file_pointer;                          // file pointer for open NC code file
N    ON_OFF flood;                                 // whether flood coolant is on
N    int length_offset_index;                      // for use with tool length offsets
N    CANON_UNITS length_units;                     // millimeters or inches
N    int line_length;                              // length of line last read
N    char linetext[RS274NGC_TEXT_SIZE];            // text of most recent line read
X    char linetext[256];            
N    ON_OFF mist;                                  // whether mist coolant is on
N    int motion_mode;                              // active G-code for motion
N    int origin_index;                             // active origin (1=G54 to 9=G59.3)
N    double origin_offset_x;                       // origin offset x
N    double origin_offset_y;                       // origin offset y
N    double origin_offset_z;                       // origin offset z
N    double parameters
N        [RS274NGC_MAX_PARAMETERS];                // system parameters
X        [5400];                
N    int parameter_occurrence;                     // parameter buffer index
N    int parameter_numbers[50];                    // parameter number buffer
N    double parameter_values[50];                  // parameter value buffer
N    ON_OFF percent_flag;                          // ON means first line was percent sign
N    CANON_PLANE plane;                            // active plane, XY-, YZ-, or XZ-plane
N    ON_OFF probe_flag;                            // flag indicating probing done
N    double program_x;                             // program x, used when cutter comp on
N    double program_y;                             // program y, used when cutter comp on
N    RETRACT_MODE retract_mode;                    // for cycles, old_z or r_plane
N    int selected_tool_slot;                       // tool slot selected but not active
N    int sequence_number;                          // sequence number of line last read
N    double speed;                                 // current spindle speed in rpm
N    CANON_SPEED_FEED_MODE speed_feed_mode;        // independent or synched
N    ON_OFF speed_override;                        // whether speed override is enabled
N    CANON_DIRECTION spindle_turning;              // direction spindle is turning
N    char stack[50][80];                           // stack of calls for error reporting
N    int stack_index;                              // index into the stack
N    double tool_length_offset;                    // current tool length offset
N    int tool_max;                                 // highest number tool slot in carousel
N    CANON_TOOL_TABLE tool_table
N        [CANON_TOOL_MAX + 1];                     // index is slot number
X        [128 + 1];                     
N    int tool_table_index;                         // tool index used with cutter comp
N    double traverse_rate;                         // rate for traverse motions
N} setup;
N
Ntypedef setup * setup_pointer;
N
N   // pointer to function that reads
Ntypedef int (*read_function_pointer) (char *, int *, block_pointer, double *);
N
N   /*************************************************************************/
N   /*
N
N   Interface functions to call to tell the interpreter what to do.
N   Return values indicate status of execution.
N   These functions may change the state of the interpreter.
N
N   */
N
N   // close the currently open NC code file
W "rs274ngc.h" 376 12 Deprecated declaration rs274ngc_close - give arg types
Nextern int rs274ngc_close();
N
N   // execute a line of NC code
W "rs274ngc.h" 379 12 Deprecated declaration rs274ngc_execute - give arg types
Nextern int rs274ngc_execute();
N
N   // stop running
W "rs274ngc.h" 382 12 Deprecated declaration rs274ngc_exit - give arg types
Nextern int rs274ngc_exit();
N
N   // get ready to run
W "rs274ngc.h" 385 12 Deprecated declaration rs274ngc_init - give arg types
Nextern int rs274ngc_init();
N
N   // load a tool table
W "rs274ngc.h" 388 12 Deprecated declaration rs274ngc_load_tool_table - give arg types
Nextern int rs274ngc_load_tool_table();
N
N   // open a file of NC code
Nextern int rs274ngc_open(const char *filename);
N
N   // read the mdi or the next line of the open NC code file
Nextern int rs274ngc_read(const char * mdi);
N
N   // reset yourself
W "rs274ngc.h" 397 12 Deprecated declaration rs274ngc_reset - give arg types
Nextern int rs274ngc_reset();
N
N   // restore interpreter variables from a file
Nextern int rs274ngc_restore_parameters(const char * filename);
N
N   // save interpreter variables to file
Nextern int rs274ngc_save_parameters(const char * filename,
Nconst double parameters[]);
N
N   // synchronize your internal model with the external world
W "rs274ngc.h" 407 12 Deprecated declaration rs274ngc_synch - give arg types
Nextern int rs274ngc_synch();
N
N   /*************************************************************************/
N   /* 
N
N   Interface functions to call to get information from the interpreter.
N   If a function has a return value, the return value contains the information.
N   If a function returns nothing, information is copied into one of the
N   arguments to the function. These functions do not change the state of
N   the interpreter.
N
N   */
N
N   // copy active G codes into array [0]..[11]
Nextern void rs274ngc_active_g_codes(int * codes);
N
N   // copy active M codes into array [0]..[6]
Nextern void rs274ngc_active_m_codes(int * codes);
N
N   // copy active F, S settings into array [0]..[2]
Nextern void rs274ngc_active_settings(double * settings);
N
N   // copy the text of the error message whose number is error_code into the
N   // error_text array, but stop at max_size if the text is longer.
Nextern void rs274ngc_error_text(int error_code, char * error_text,unsigned
Nint max_size);
N
N   // copy the name of the currently open file into the file_name array,
N   // but stop at max_size if the name is longer
Nextern void rs274ngc_file_name(char * file_name,unsigned int max_size);
N
N   // return the length of the most recently read line
W "rs274ngc.h" 439 12 Deprecated declaration rs274ngc_line_length - give arg types
Nextern int rs274ngc_line_length();
N
N   // copy the text of the most recently read line into the line_text array,
N   // but stop at max_size if the text is longer
Nextern void rs274ngc_line_text(char * line_text, int max_size);
N
N   // return the current sequence number (how many lines read)
W "rs274ngc.h" 446 12 Deprecated declaration rs274ngc_sequence_number - give arg types
Nextern int rs274ngc_sequence_number();
N
N   // copy the function name from the stack_index'th position of the
N   // function call stack at the time of the most recent error into
N   // the function name string, but stop at max_size if the name is longer
Nextern void rs274ngc_stack_name(int stack_index, char * function_name,
Nint max_size);
N#endif
L 40 "main.c" 2
N#include "rs274ngc_return.h"
L 1 "rs274ngc_return.h" 1
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N#ifndef RS274NGC_RETURN_H
N#define RS274NGC_RETURN_H
N
N#define RS274NGC_OK 0
N#define RS274NGC_EXIT 1
N#define RS274NGC_EXECUTE_FINISH 2
N#define RS274NGC_ENDFILE 3
N#define NCE_A_FILE_IS_ALREADY_OPEN 4
N#define NCE_ALL_AXES_MISSING_WITH_G92 5
N#define NCE_ALL_AXES_MISSING_WITH_MOTION_CODE 6
N#define NCE_ARC_RADIUS_TOO_SMALL_TO_REACH_END_POINT 7
N#define NCE_ARGUMENT_TO_ACOS_OUT_OF_RANGE 8
N#define NCE_ARGUMENT_TO_ASIN_OUT_OF_RANGE 9
N#define NCE_ATTEMPT_TO_DIVIDE_BY_ZERO 10
N#define NCE_ATTEMPT_TO_RAISE_NEGATIVE_TO_NON_INTEGER_POWER 11
N#define NCE_BAD_CHARACTER_USED 12
N#define NCE_BAD_FORMAT_UNSIGNED_INTEGER 13
N#define NCE_BAD_NUMBER_FORMAT 14
N#define NCE_BUG_BAD_G_CODE_MODAL_GROUP_0 15
N#define NCE_BUG_CODE_NOT_G0_OR_G1 16
N#define NCE_BUG_CODE_NOT_G17_G18_OR_G19 17
N#define NCE_BUG_CODE_NOT_G20_OR_G21 18
N#define NCE_BUG_CODE_NOT_G28_OR_G30 19
N#define NCE_BUG_CODE_NOT_G2_OR_G3 20
N#define NCE_BUG_CODE_NOT_G40_G41_OR_G42 21
N#define NCE_BUG_CODE_NOT_G43_OR_G49 22
N#define NCE_BUG_CODE_NOT_G4_G10_G28_G30_G53_OR_G92_SERIES 23
N#define NCE_BUG_CODE_NOT_G61_G61_1_OR_G64 24
N#define NCE_BUG_CODE_NOT_G90_OR_G91 25
N#define NCE_BUG_CODE_NOT_G93_OR_G94 26
N#define NCE_BUG_CODE_NOT_G98_OR_G99 27
N#define NCE_BUG_CODE_NOT_IN_G92_SERIES 28
N#define NCE_BUG_CODE_NOT_IN_RANGE_G54_TO_G593 29
N#define NCE_BUG_CODE_NOT_M0_M1_M2_M30_M60 30
N#define NCE_BUG_DISTANCE_MODE_NOT_G90_OR_G91 31
N#define NCE_BUG_FUNCTION_SHOULD_NOT_HAVE_BEEN_CALLED 32
N#define NCE_BUG_IN_TOOL_RADIUS_COMP 33
N#define NCE_BUG_PLANE_NOT_XY_YZ_OR_XZ 34
N#define NCE_BUG_SIDE_NOT_RIGHT_OR_LEFT 35
N#define NCE_BUG_UNKNOWN_MOTION_CODE 36
N#define NCE_BUG_UNKNOWN_OPERATION 37
N#define NCE_CANNOT_CHANGE_AXIS_OFFSETS_WITH_CUTTER_RADIUS_COMP 38
N#define NCE_CANNOT_CHANGE_UNITS_WITH_CUTTER_RADIUS_COMP 39
N#define NCE_CANNOT_CREATE_BACKUP_FILE 40
N#define NCE_CANNOT_DO_G1_WITH_ZERO_FEED_RATE 41
N#define NCE_CANNOT_DO_ZERO_REPEATS_OF_CYCLE 42
N#define NCE_CANNOT_MAKE_ARC_WITH_ZERO_FEED_RATE 43
N#define NCE_CANNOT_MOVE_ROTARY_AXES_DURING_PROBING 44
N#define NCE_CANNOT_OPEN_BACKUP_FILE 45
N#define NCE_CANNOT_OPEN_VARIABLE_FILE 46
N#define NCE_CANNOT_PROBE_IN_INVERSE_TIME_FEED_MODE 47
N#define NCE_CANNOT_PROBE_WITH_CUTTER_RADIUS_COMP_ON 48
N#define NCE_CANNOT_PROBE_WITH_ZERO_FEED_RATE 49
N#define NCE_CANNOT_PUT_A_B_IN_CANNED_CYCLE 50
N#define NCE_CANNOT_PUT_A_C_IN_CANNED_CYCLE 51
N#define NCE_CANNOT_PUT_AN_A_IN_CANNED_CYCLE 52
N#define NCE_CANNOT_TURN_CUTTER_RADIUS_COMP_ON_OUT_OF_XY_PLANE 53
N#define NCE_CANNOT_TURN_CUTTER_RADIUS_COMP_ON_WHEN_ON 54
N#define NCE_CANNOT_USE_A_WORD 55
N#define NCE_CANNOT_USE_AXIS_VALUES_WITH_G80 56
N#define NCE_CANNOT_USE_AXIS_VALUES_WITHOUT_A_G_CODE_THAT_USES_THEM 57
N#define NCE_CANNOT_USE_B_WORD 58
N#define NCE_CANNOT_USE_C_WORD 59
N#define NCE_CANNOT_USE_G28_OR_G30_WITH_CUTTER_RADIUS_COMP 60
N#define NCE_CANNOT_USE_G53_INCREMENTAL 61
N#define NCE_CANNOT_USE_G53_WITH_CUTTER_RADIUS_COMP 62
N#define NCE_CANNOT_USE_TWO_G_CODES_THAT_BOTH_USE_AXIS_VALUES 63
N#define NCE_CANNOT_USE_XZ_PLANE_WITH_CUTTER_RADIUS_COMP 64
N#define NCE_CANNOT_USE_YZ_PLANE_WITH_CUTTER_RADIUS_COMP 65
N#define NCE_COMMAND_TOO_LONG 66
N#define NCE_CONCAVE_CORNER_WITH_CUTTER_RADIUS_COMP 67
N#define NCE_COORDINATE_SYSTEM_INDEX_PARAMETER_5220_OUT_OF_RANGE 68
N#define NCE_CURRENT_POINT_SAME_AS_END_POINT_OF_ARC 69
N#define NCE_CUTTER_GOUGING_WITH_CUTTER_RADIUS_COMP 70
N#define NCE_D_WORD_WITH_NO_G41_OR_G42 71
N#define NCE_DWELL_TIME_MISSING_WITH_G4 72
N#define NCE_DWELL_TIME_P_WORD_MISSING_WITH_G82 73
N#define NCE_DWELL_TIME_P_WORD_MISSING_WITH_G86 74
N#define NCE_DWELL_TIME_P_WORD_MISSING_WITH_G88 75
N#define NCE_DWELL_TIME_P_WORD_MISSING_WITH_G89 76
N#define NCE_EQUAL_SIGN_MISSING_IN_PARAMETER_SETTING 77
N#define NCE_F_WORD_MISSING_WITH_INVERSE_TIME_ARC_MOVE 78
N#define NCE_F_WORD_MISSING_WITH_INVERSE_TIME_G1_MOVE 79
N#define NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN 80
N#define NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN_OR_PROGRAM_END 81
N#define NCE_FILE_NAME_TOO_LONG 82
N#define NCE_FILE_NOT_OPEN 83
N#define NCE_G_CODE_OUT_OF_RANGE 84
N#define NCE_H_WORD_WITH_NO_G43 85
N#define NCE_I_WORD_GIVEN_FOR_ARC_IN_YZ_PLANE 86
N#define NCE_I_WORD_MISSING_WITH_G87 87
N#define NCE_I_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT 88
N#define NCE_J_WORD_GIVEN_FOR_ARC_IN_XZ_PLANE 89
N#define NCE_J_WORD_MISSING_WITH_G87 90
N#define NCE_J_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT 91
N#define NCE_K_WORD_GIVEN_FOR_ARC_IN_XY_PLANE 92
N#define NCE_K_WORD_MISSING_WITH_G87 93
N#define NCE_K_WORD_WITH_NO_G2_OR_G3_OR_G87_TO_USE_IT 94
N#define NCE_L_WORD_WITH_NO_CANNED_CYCLE_OR_G10 95
N#define NCE_LEFT_BRACKET_MISSING_AFTER_SLASH_WITH_ATAN 96
N#define NCE_LEFT_BRACKET_MISSING_AFTER_UNARY_OPERATION_NAME 97
N#define NCE_LINE_NUMBER_GREATER_THAN_99999 98
N#define NCE_LINE_WITH_G10_DOES_NOT_HAVE_L2 99
N#define NCE_M_CODE_GREATER_THAN_99 100
N#define NCE_MIXED_RADIUS_IJK_FORMAT_FOR_ARC 101
N#define NCE_MULTIPLE_A_WORDS_ON_ONE_LINE 102
N#define NCE_MULTIPLE_B_WORDS_ON_ONE_LINE 103
N#define NCE_MULTIPLE_C_WORDS_ON_ONE_LINE 104
N#define NCE_MULTIPLE_D_WORDS_ON_ONE_LINE 105
N#define NCE_MULTIPLE_F_WORDS_ON_ONE_LINE 106
N#define NCE_MULTIPLE_H_WORDS_ON_ONE_LINE 107
N#define NCE_MULTIPLE_I_WORDS_ON_ONE_LINE 108
N#define NCE_MULTIPLE_J_WORDS_ON_ONE_LINE 109
N#define NCE_MULTIPLE_K_WORDS_ON_ONE_LINE 110
N#define NCE_MULTIPLE_L_WORDS_ON_ONE_LINE 111
N#define NCE_MULTIPLE_P_WORDS_ON_ONE_LINE 112
N#define NCE_MULTIPLE_Q_WORDS_ON_ONE_LINE 113
N#define NCE_MULTIPLE_R_WORDS_ON_ONE_LINE 114
N#define NCE_MULTIPLE_S_WORDS_ON_ONE_LINE 115
N#define NCE_MULTIPLE_T_WORDS_ON_ONE_LINE 116
N#define NCE_MULTIPLE_X_WORDS_ON_ONE_LINE 117
N#define NCE_MULTIPLE_Y_WORDS_ON_ONE_LINE 118
N#define NCE_MULTIPLE_Z_WORDS_ON_ONE_LINE 119
N#define NCE_MUST_USE_G0_OR_G1_WITH_G53 120
N#define NCE_NEGATIVE_ARGUMENT_TO_SQRT 121
N#define NCE_NEGATIVE_D_WORD_TOOL_RADIUS_INDEX_USED 122
N#define NCE_NEGATIVE_F_WORD_USED 123
N#define NCE_NEGATIVE_G_CODE_USED 124
N#define NCE_NEGATIVE_H_WORD_TOOL_LENGTH_OFFSET_INDEX_USED 125
N#define NCE_NEGATIVE_L_WORD_USED 126
N#define NCE_NEGATIVE_M_CODE_USED 127
N#define NCE_NEGATIVE_OR_ZERO_Q_VALUE_USED 128
N#define NCE_NEGATIVE_P_WORD_USED 129
N#define NCE_NEGATIVE_SPINDLE_SPEED_USED 130
N#define NCE_NEGATIVE_TOOL_ID_USED 131
N#define NCE_NESTED_COMMENT_FOUND 132
N#define NCE_NO_CHARACTERS_FOUND_IN_READING_REAL_VALUE 133
N#define NCE_NO_DIGITS_FOUND_WHERE_REAL_NUMBER_SHOULD_BE 134
N#define NCE_NON_INTEGER_VALUE_FOR_INTEGER 135
N#define NCE_NULL_MISSING_AFTER_NEWLINE 136
N#define NCE_OFFSET_INDEX_MISSING 137
N#define NCE_P_VALUE_NOT_AN_INTEGER_WITH_G10_L2 138
N#define NCE_P_VALUE_OUT_OF_RANGE_WITH_G10_L2 139
N#define NCE_P_WORD_WITH_NO_G4_G10_G82_G86_G88_G89 140
N#define NCE_PARAMETER_FILE_OUT_OF_ORDER 141
N#define NCE_PARAMETER_NUMBER_OUT_OF_RANGE 142
N#define NCE_Q_WORD_MISSING_WITH_G83 143
N#define NCE_Q_WORD_WITH_NO_G83 144
N#define NCE_QUEUE_IS_NOT_EMPTY_AFTER_PROBING 145
N#define NCE_R_CLEARANCE_PLANE_UNSPECIFIED_IN_CYCLE 146
N#define NCE_R_I_J_K_WORDS_ALL_MISSING_FOR_ARC 147
N#define NCE_R_LESS_THAN_X_IN_CYCLE_IN_YZ_PLANE 148
N#define NCE_R_LESS_THAN_Y_IN_CYCLE_IN_XZ_PLANE 149
N#define NCE_R_LESS_THAN_Z_IN_CYCLE_IN_XY_PLANE 150
N#define NCE_R_WORD_WITH_NO_G_CODE_THAT_USES_IT 151
N#define NCE_RADIUS_TO_END_OF_ARC_DIFFERS_FROM_RADIUS_TO_START 152
N#define NCE_RADIUS_TOO_SMALL_TO_REACH_END_POINT 153
N#define NCE_REQUIRED_PARAMETER_MISSING 154
N#define NCE_SELECTED_TOOL_SLOT_NUMBER_TOO_LARGE 155
N#define NCE_SLASH_MISSING_AFTER_FIRST_ATAN_ARGUMENT 156
N#define NCE_SPINDLE_NOT_TURNING_CLOCKWISE_IN_G84 157
N#define NCE_SPINDLE_NOT_TURNING_IN_G86 158
N#define NCE_SPINDLE_NOT_TURNING_IN_G87 159
N#define NCE_SPINDLE_NOT_TURNING_IN_G88 160
N#define NCE_SSCANF_FAILED 161
N#define NCE_START_POINT_TOO_CLOSE_TO_PROBE_POINT 162
N#define NCE_TOO_MANY_M_CODES_ON_LINE 163
N#define NCE_TOOL_LENGTH_OFFSET_INDEX_TOO_BIG 164
N#define NCE_TOOL_MAX_TOO_LARGE 165
N#define NCE_TOOL_RADIUS_INDEX_TOO_BIG 166
N#define NCE_TOOL_RADIUS_NOT_LESS_THAN_ARC_RADIUS_WITH_COMP 167
N#define NCE_TWO_G_CODES_USED_FROM_SAME_MODAL_GROUP 168
N#define NCE_TWO_M_CODES_USED_FROM_SAME_MODAL_GROUP 169
N#define NCE_UNABLE_TO_OPEN_FILE 170
N#define NCE_UNCLOSED_COMMENT_FOUND 171
N#define NCE_UNCLOSED_EXPRESSION 172
N#define NCE_UNKNOWN_G_CODE_USED 173
N#define NCE_UNKNOWN_M_CODE_USED 174
N#define NCE_UNKNOWN_OPERATION 175
N#define NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_A 176
N#define NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_M 177
N#define NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_O 178
N#define NCE_UNKNOWN_OPERATION_NAME_STARTING_WITH_X 179
N#define NCE_UNKNOWN_WORD_STARTING_WITH_A 180
N#define NCE_UNKNOWN_WORD_STARTING_WITH_C 181
N#define NCE_UNKNOWN_WORD_STARTING_WITH_E 182
N#define NCE_UNKNOWN_WORD_STARTING_WITH_F 183
N#define NCE_UNKNOWN_WORD_STARTING_WITH_L 184
N#define NCE_UNKNOWN_WORD_STARTING_WITH_R 185
N#define NCE_UNKNOWN_WORD_STARTING_WITH_S 186
N#define NCE_UNKNOWN_WORD_STARTING_WITH_T 187
N#define NCE_UNKNOWN_WORD_WHERE_UNARY_OPERATION_COULD_BE 188
N#define NCE_X_AND_Y_WORDS_MISSING_FOR_ARC_IN_XY_PLANE 189
N#define NCE_X_AND_Z_WORDS_MISSING_FOR_ARC_IN_XZ_PLANE 190
N#define NCE_X_VALUE_UNSPECIFIED_IN_YZ_PLANE_CANNED_CYCLE 191
N#define NCE_X_Y_AND_Z_WORDS_ALL_MISSING_WITH_G38_2 192
N#define NCE_Y_AND_Z_WORDS_MISSING_FOR_ARC_IN_YZ_PLANE 193
N#define NCE_Y_VALUE_UNSPECIFIED_IN_XZ_PLANE_CANNED_CYCLE 194
N#define NCE_Z_VALUE_UNSPECIFIED_IN_XY_PLANE_CANNED_CYCLE 195
N#define NCE_ZERO_OR_NEGATIVE_ARGUMENT_TO_LN 196
N#define NCE_ZERO_RADIUS_ARC 197
N
N#define RS274NGC_MIN_ERROR 3
N#define RS274NGC_MAX_ERROR 197
N#endif                                            /* RS274NGC_RETURN_H */
L 41 "main.c" 2
N#include <stdio.h>                                /* gets, etc. */
N#include <stdlib.h>                               /* exit       */
L 1 "C:\Keil\ARM\RV31\INC\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 152811 $
N * Checkin $Date: 2010-03-04 09:02:00 +0000 (Thu, 04 Mar 2010) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
L 43 "main.c" 2
N#include <string.h>                               /* strcpy     */
L 1 "C:\Keil\ARM\RV31\INC\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
L 44 "main.c" 2
N
Nextern CANON_TOOL_TABLE _tools[];                 /* in canon.cc */
Nextern int _tool_max;                             /* in canon.cc */
Nextern char _parameter_file_name[];               /* in canon.cc */
N
NFILE * _outfile;                                  /* where to print, set in main */
N
N#define Line_Length 256
N
N/*
N
NThis file contains the source code for an emulation of using the six-axis
Nrs274 interpreter from the EMC system.
N
N*/
N
N/*********************************************************************/
N
N/* report_error
N
NReturned Value: none
N
NSide effects: an error message is printed on stderr
N
NCalled by:
Ninterpret_from_file
Ninterpret_from_keyboard
Nmain
N
NThis
N
N1. calls rs274ngc_error_text to get the text of the error message whose
Ncode is error_code and prints the message,
N
N2. calls rs274ngc_line_text to get the text of the line on which the
Nerror occurred and prints the text, and
N
N3. if print_stack is on, repeatedly calls rs274ngc_stack_name to get
Nthe names of the functions on the function call stack and prints the
Nnames. The first function named is the one that sent the error
Nmessage.
N
N*/
N
Nvoid report_error(                                /* ARGUMENTS                            */
Nint error_code,                                   /* the code number of the error message */
Nint print_stack)                                  /* print stack if ON, otherwise not     */
N{
N    char buffer[RS274NGC_TEXT_SIZE];
X    char buffer[256];
N    int k;
N
N    rs274ngc_error_text(error_code, buffer, 5);   /* for coverage of code */
N    rs274ngc_error_text(error_code, buffer, RS274NGC_TEXT_SIZE);
X    rs274ngc_error_text(error_code, buffer, 256);
N    fprintf(stderr, "%s\r\n",
X    fprintf((& __stderr), "%s\r\n",
N        ((buffer[0] IS 0) ? "Unknown error, bad error code" : buffer));
X        ((buffer[0] == 0) ? "Unknown error, bad error code" : buffer));
N    rs274ngc_line_text(buffer, RS274NGC_TEXT_SIZE);
X    rs274ngc_line_text(buffer, 256);
N    fprintf(stderr, "%s\r\n", buffer);
X    fprintf((& __stderr), "%s\r\n", buffer);
N    if (print_stack IS ON)
X    if (print_stack == 1)
N    {
N        for (k SET_TO 0; ; k++)
X        for (k = 0; ; k++)
N        {
N            rs274ngc_stack_name(k, buffer, RS274NGC_TEXT_SIZE);
X            rs274ngc_stack_name(k, buffer, 256);
N            if (buffer[0] ISNT 0)
X            if (buffer[0] != 0)
N                fprintf(stderr, "%s\r\n", buffer);
X                fprintf((& __stderr), "%s\r\n", buffer);
N            else
N                break;
N        }
N    }
N}
N
N
N/***********************************************************************/
N
N/* interpret_from_keyboard
N
NReturned Value: int (0)
N
NSide effects:
NLines of NC code entered by the user are interpreted.
N
NCalled by:
Ninterpret_from_file
Nmain
N
NThis prompts the user to enter a line of rs274 code. When the user
Nhits <enter> at the end of the line, the line is executed.
NThen the user is prompted to enter another line.
N
NAny canonical commands resulting from executing the line are printed
Non the monitor (stdout).  If there is an error in reading or executing
Nthe line, an error message is printed on the monitor (stderr).
N
NTo exit, the user must enter "quit" (followed by a carriage return).
N
N*/
N
Nint interpret_from_keyboard(                      /* ARGUMENTS                 */
Nint block_delete,                                 /* switch which is ON or OFF */
Nint print_stack)                                  /* option which is ON or OFF */
N{
N    char line[RS274NGC_TEXT_SIZE];
X    char line[256];
N    int status;
N	u16 i=0;
N	char Buffer[Line_Length];
X	char Buffer[256];
N	u16 count=0;
N
N    for(; ;)
N    {
N        printf("READ => ");
N		//,%
N		while(1)
N		{	
N			if(USART_GetFlagStatus(USART1,USART_IT_RXNE)==SET)
X			if(USART_GetFlagStatus(((USART_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x3800)),((u16)0x0525))==SET)
N			{	      
N				i = USART_ReceiveData(USART1);
X				i = USART_ReceiveData(((USART_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x3800)));
N				if(count<Line_Length)
X				if(count<256)
N				{
N					if(i=='%')
N					{
N						printf("%s\r\n",Buffer);	
N						strcpy(line,Buffer);
N						for(count=0;count<Line_Length;count++)			
X						for(count=0;count<256;count++)			
N						{
N							Buffer[count]='\0';
N						}
N						count=0;
N						break;
N					}
N					else
N					{
N						Buffer[count++]=i;
N					}
N				}
N				//printf("2  %c\r\n",i&0xFF);	   /* print the input char */
N			}
N		}
N        //gets(line);
N        if (strcmp (line, "quit") IS 0)
X        if (strcmp (line, "quit") == 0)
N            return 0;
N        status SET_TO rs274ngc_read(line);
X        status = rs274ngc_read(line);
N        if ((status IS RS274NGC_EXECUTE_FINISH) AND (block_delete IS ON));
X        if ((status == 2) && (block_delete == 1));
N        else if (status IS RS274NGC_ENDFILE);
X        else if (status == 3);
N        else if ((status ISNT RS274NGC_EXECUTE_FINISH) AND
X        else if ((status != 2) &&
N            (status ISNT RS274NGC_OK))
X            (status != 0))
N            report_error(status, print_stack);
N        else
N        {
N            status SET_TO rs274ngc_execute();    
X            status = rs274ngc_execute();    
N            if ((status IS RS274NGC_EXIT) OR
X            if ((status == 1) ||
N                (status IS RS274NGC_EXECUTE_FINISH));
X                (status == 2));
N            else if (status ISNT RS274NGC_OK)
X            else if (status != 0)
N                report_error(status, print_stack);
N        }
N    }
N}
N
N
N/*********************************************************************/
N
N/* interpret_from_file
N
NReturned Value: int (0 or 1)
NIf any of the following errors occur, this returns 1.
NOtherwise, it returns 0.
N1. rs274ngc_read returns something other than RS274NGC_OK or
NRS274NGC_EXECUTE_FINISH, no_stop is off, and the user elects
Nnot to continue.
N2. rs274ngc_execute returns something other than RS274NGC_OK,
NEXIT, or RS274NGC_EXECUTE_FINISH, no_stop is off, and the user
Nelects not to continue.
N
NSide Effects:
NAn open NC-program file is interpreted.
N
NCalled By:
Nmain
N
NThis emulates the way the EMC system uses the interpreter.
N
NIf the do_next argument is 1, this goes into MDI mode if an error is
Nfound. In that mode, the user may (1) enter code or (2) enter "quit" to
Nget out of MDI. Once out of MDI, this asks the user whether to continue
Ninterpreting the file.
N
NIf the do_next argument is 0, an error does not stop interpretation.
N
NIf the do_next argument is 2, an error stops interpretation.
N
N*/
N
Nint interpret_from_file(                          /* ARGUMENTS                  */
Nint do_next,                                      /* what to do if error        */
Nint block_delete,                                 /* switch which is ON or OFF  */
Nint print_stack)                                  /* option which is ON or OFF  */
N{
N    int status;
N    char line[RS274NGC_TEXT_SIZE];
X    char line[256];
N
N    for(; ;)
N    {
N        status SET_TO rs274ngc_read(NULL);
X        status = rs274ngc_read(0);
N        if ((status IS RS274NGC_EXECUTE_FINISH) AND (block_delete IS ON))
X        if ((status == 2) && (block_delete == 1))
N            continue;
N        else if (status IS RS274NGC_ENDFILE)
X        else if (status == 3)
N            break;
N        if ((status ISNT RS274NGC_OK) AND         // should not be EXIT
X        if ((status != 0) &&         
N            (status ISNT RS274NGC_EXECUTE_FINISH))
X            (status != 2))
N        {
N            report_error(status, print_stack);
N            if ((status IS NCE_FILE_ENDED_WITH_NO_PERCENT_SIGN) OR
X            if ((status == 80) ||
N                (do_next IS 2))                   /* 2 means stop */
X                (do_next == 2))                    
N            {
N                status SET_TO 1;
X                status = 1;
N                break;
N            }
N            else if (do_next IS 1)                /* 1 means MDI */
X            else if (do_next == 1)                 
N            {
N                fprintf(stderr, "starting MDI\r\n");
X                fprintf((& __stderr), "starting MDI\r\n");
N                interpret_from_keyboard(block_delete, print_stack);
N                fprintf(stderr, "continue program? y/n =>");
X                fprintf((& __stderr), "continue program? y/n =>");
N                gets(line);
N                if (line[0] ISNT 'y')
X                if (line[0] != 'y')
N                {
N                    status SET_TO 1;
X                    status = 1;
N                    break;
N                }
N                else
N                    continue;
N            }
N            else                                  /* if do_next IS 0 -- 0 means continue */
N                continue;
N        }
N        status SET_TO rs274ngc_execute();
X        status = rs274ngc_execute();
N        if ((status ISNT RS274NGC_OK) AND
X        if ((status != 0) &&
N            (status ISNT RS274NGC_EXIT) AND
X            (status != 1) &&
N            (status ISNT RS274NGC_EXECUTE_FINISH))
X            (status != 2))
N        {
N            report_error(status, print_stack);
N            status SET_TO 1;
X            status = 1;
N            if (do_next IS 1)                     /* 1 means MDI */
X            if (do_next == 1)                      
N            {
N                fprintf(stderr, "starting MDI\r\n");
X                fprintf((& __stderr), "starting MDI\r\n");
N                interpret_from_keyboard(block_delete, print_stack);
N                fprintf(stderr, "continue program? y/n =>");
X                fprintf((& __stderr), "continue program? y/n =>");
N                gets(line);
N                if (line[0] ISNT 'y')
X                if (line[0] != 'y')
N                    break;
N            }
N            else if (do_next IS 2)                /* 2 means stop */
X            else if (do_next == 2)                 
N                break;
N        }
N        else if (status IS RS274NGC_EXIT)
X        else if (status == 1)
N            break;
N    }
N    return ((status IS 1) ? 1 : 0);
X    return ((status == 1) ? 1 : 0);
N}
N
N
N/************************************************************************/
N
N/* read_tool_file
N
NReturned Value: int
NIf any of the following errors occur, this returns 1.
NOtherwise, it returns 0.
N1. The file named by the user cannot be opened.
N2. No blank line is found.
N3. A line of data cannot be read.
N4. A tool slot number is less than 1 or >= _tool_max
N
NSide Effects:
NValues in the tool table of the machine setup are changed,
Nas specified in the file.
N
NCalled By: main
N
NTool File Format
N-----------------
NEverything above the first blank line is read and ignored, so any sort
Nof header material may be used.
N
NEverything after the first blank line should be data. Each line of
Ndata should have four or more items separated by white space. The four
Nrequired items are slot, tool id, tool length offset, and tool diameter.
NOther items might be the holder id and tool description, but these are
Noptional and will not be read. Here is a sample line:
N
N20  1419  4.299  1.0   1 inch carbide end mill
N
NThe tool_table is indexed by slot number.
N
N*/
N
Nint read_tool_file(                               /* ARGUMENTS         */
Nchar * file_name)                                 /* name of tool file */
N{
N//    FILE * tool_file_port;
N//    char buffer[1000];
N//    int slot;
N//    int tool_id;
N//    double offset;
N//    double diameter;
N//
N//    if (file_name[0] IS 0)                        /* ask for name if given name is empty string */
N//    {
N//        fprintf(stderr, "name of tool file => ");
N//        gets(buffer);
N//        tool_file_port SET_TO fopen(buffer, "r");
N//    }
N//    else
N//        tool_file_port SET_TO fopen(file_name, "r");
N//    if (tool_file_port IS NULL)
N//    {
N//        fprintf(stderr, "Cannot open %s\r\n",
N//            ((file_name[0] IS 0) ? buffer : file_name));
N//        return 1;
N//    }
N//    for(;;)                                       /* read and discard header, checking for blank line */
N//    {
N//        if (fgets(buffer, 1000, tool_file_port) IS NULL)
N//        {
N//            fprintf(stderr, "Bad tool file format\r\n");
N//            return 1;
N//        }
N//        else if (buffer[0] IS '\n')
N//            break;
N//    }
N//
N//    for (slot SET_TO 0; slot <= _tool_max; slot++)/* initialize */
N//    {
N//        _tools[slot].id SET_TO -1;
N//        _tools[slot].length SET_TO 0;
N//        _tools[slot].diameter SET_TO 0;
N//    }
N//    for (; (fgets(buffer, 1000, tool_file_port) ISNT NULL); )
N//    {
N//        if (sscanf(buffer, "%d %d %lf %lf", &slot,
N//            &tool_id, &offset, &diameter) < 4)
N//        {
N//            fprintf(stderr, "Bad input line \"%s\" in tool file\r\n", buffer);
N//            return 1;
N//        }
N//        if ((slot < 0) OR (slot > _tool_max))     /* zero and max both OK */
N//        {
N//            fprintf(stderr, "Out of range tool slot number %d\r\n", slot);
N//            return 1;
N//        }
N//        _tools[slot].id SET_TO tool_id;
N//        _tools[slot].length SET_TO offset;
N//        _tools[slot].diameter SET_TO diameter;
N        _tools[5].id SET_TO 5;
X        _tools[5].id = 5;
N        _tools[5].length SET_TO 1.5;
X        _tools[5].length = 1.5;
N        _tools[5].diameter SET_TO 0.25;
X        _tools[5].diameter = 0.25;
N
N//    }
N//    fclose(tool_file_port);
N    return 0;
N}
N
N
N/************************************************************************/
N
N/* designate_parameter_file
N
NReturned Value: int
NIf any of the following errors occur, this returns 1.
NOtherwise, it returns 0.
N1. The file named by the user cannot be opened.
N
NSide Effects:
NThe name of a parameter file given by the user is put in the
Nfile_name string.
N
NCalled By: main
N
N*/
N
Nint designate_parameter_file(char * file_name)
N{
N    FILE * test_port;
N
N    fprintf(stderr, "name of parameter file => ");
X    fprintf((& __stderr), "name of parameter file => ");
N    gets(file_name);
N    test_port SET_TO fopen(file_name, "r");
X    test_port = fopen(file_name, "r");
N    if (test_port IS NULL)
X    if (test_port == 0)
N    {
N        fprintf(stderr, "Cannot open %s\r\n", file_name);
X        fprintf((& __stderr), "Cannot open %s\r\n", file_name);
N        return 1;
N    }
N    fclose(test_port);
N    return 0;
N}
N
N
N/************************************************************************/
N
N/* adjust_error_handling
N
NReturned Value: int (0)
N
NSide Effects:
NThe values of print_stack and do_next are set.
N
NCalled By: main
N
NThis function allows the user to set one or two aspects of error handling.
N
NBy default the driver does not print the function stack in case of error.
NThis function always allows the user to turn stack printing on if it is off
Nor to turn stack printing off if it is on.
N
NWhen interpreting from the keyboard, the driver always goes ahead if there
Nis an error.
N
NWhen interpreting from a file, the default behavior is to stop in case of
Nan error. If the user is interpreting from a file (indicated by args being
N2 or 3), this lets the user change what it does on an error.
N
NIf the user has not asked for output to a file (indicated by args being 2),
Nthe user can choose any of three behaviors in case of an error (1) continue,
N(2) stop, (3) go into MDI mode. This function allows the user to cycle among
Nthe three.
N
NIf the user has asked for output to a file (indicated by args being 3),
Nthe user can choose any of two behaviors in case of an error (1) continue,
N(2) stop. This function allows the user to toggle between the two.
N
N*/
N
Nint adjust_error_handling(
Nint args,
Nint * print_stack,
Nint * do_next)
N{
N    char buffer[80];
N    int choice;
N
N    for(;;)
N    {
N        fprintf(stderr, "enter a number:\r\n");
X        fprintf((& __stderr), "enter a number:\r\n");
N        fprintf(stderr, "1 = done with error handling\r\n");
X        fprintf((& __stderr), "1 = done with error handling\r\n");
N        fprintf(stderr, "2 = %sprint stack on error\r\n",
X        fprintf((& __stderr), "2 = %sprint stack on error\r\n",
N            ((*print_stack IS ON) ? "do not " : ""));
X            ((*print_stack == 1) ? "do not " : ""));
N        if (args IS 3)
X        if (args == 3)
N        {
N            if (*do_next IS 0)                    /* 0 means continue */
X            if (*do_next == 0)                     
N                fprintf(stderr,
X                fprintf((& __stderr),
N                    "3 = stop on error (do not continue)\r\n");
N            else                                  /* if do_next IS 2 -- 2 means stopping on error */
N                fprintf(stderr,
X                fprintf((& __stderr),
N                    "3 = continue on error (do not stop)\r\n");
N        }
N        else if (args IS 2)
X        else if (args == 2)
N        {
N            if (*do_next IS 0)                    /* 0 means continue */
X            if (*do_next == 0)                     
N                fprintf(stderr,
X                fprintf((& __stderr),
N                    "3 = mdi on error (do not continue or stop)\r\n");
N            else if (*do_next IS 1)               /* 1 means MDI */
X            else if (*do_next == 1)                
N                fprintf(stderr,
X                fprintf((& __stderr),
N                        "3 = stop on error (do not mdi or continue)\r\n");
N            else                                  /* if do_next IS 2 -- 2 means stopping on error */
N                fprintf(stderr,
X                fprintf((& __stderr),
N                    "3 = continue on error (do not stop or mdi)\r\n");
N        }
N        fprintf(stderr, "enter choice => ");
X        fprintf((& __stderr), "enter choice => ");
N        gets(buffer);
N        if (sscanf(buffer, "%d", &choice) ISNT 1)
X        if (sscanf(buffer, "%d", &choice) != 1)
N            continue;
N        if (choice IS 1)
X        if (choice == 1)
N            break;
N        else if (choice IS 2)
X        else if (choice == 2)
N            *print_stack SET_TO ((*print_stack IS OFF) ? ON : OFF);
X            *print_stack = ((*print_stack == 0) ? 1 : 0);
N        else if ((choice IS 3) AND (args IS 3))
X        else if ((choice == 3) && (args == 3))
N            *do_next SET_TO ((*do_next IS 0) ? 2 : 0);
X            *do_next = ((*do_next == 0) ? 2 : 0);
N        else if ((choice IS 3) AND (args IS 2))
X        else if ((choice == 3) && (args == 2))
N            *do_next SET_TO ((*do_next IS 2) ? 0 : (*do_next + 1));
X            *do_next = ((*do_next == 2) ? 0 : (*do_next + 1));
N    }
N    return 0;
N}
N
N
N   /***********************************************************************/
N
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
NErrorStatus HSEStartUpStatus;
N
N/* Private function prototypes -----------------------------------------------*/
Nvoid RCC_Configuration(void);
Nvoid NVIC_Configuration(void);
Nvoid GPIO_Configuration(void);
Nvoid USART_Configuration(void);
N
N/* Private functions ---------------------------------------------------------*/
N
N
N
N
N
N/************************************************************************/
N
N/* main
N
NThe executable exits with either 0 (under all conditions not listed
Nbelow) or 1 (under the following conditions):
N1. A fatal error occurs while interpreting from a file.
N2. Read_tool_file fails.
N3. An error occurs in rs274ngc_init.
N
N***********************************************************************
N
NHere are three ways in which the rs274abc executable may be called.
NAny other sort of call to the executable will cause an error message
Nto be printed and the interpreter will not run. Other executables
Nmay be called similarly.
N
N1. If the rs274abc stand-alone executable is called with no arguments,
Ninput is taken from the keyboard, and an error in the input does not
Ncause the rs274abc executable to exit.
N
NEXAMPLE:
N
N1A. To interpret from the keyboard, enter:
N
Nrs274abc
N
N***********************************************************************
N
N2. If the executable is called with one argument, the argument is
Ntaken to be the name of an NC file and the file is interpreted as
Ndescribed in the documentation of interpret_from_file.
N
NEXAMPLES:
N
N2A. To interpret the file "cds.abc" and read the results on the
Nscreen, enter:
N
Nrs274abc cds.abc
N
N2B. To interpret the file "cds.abc" and print the results in the file
N"cds.prim", enter:
N
Nrs274abc cds.abc > cds.prim
N
N***********************************************************************
N
NWhichever way the executable is called, this gives the user several
Nchoices before interpretation starts
N
N1 = start interpreting
N2 = choose parameter file
N3 = read tool file ...
N4 = turn block delete switch ON
N5 = adjust error handling...
N
NInterpretation starts when option 1 is chosen. Until that happens, the
Nuser is repeatedly given the five choices listed above.  Item 4
Ntoggles between "turn block delete switch ON" and "turn block delete
Nswitch OFF".  See documentation of adjust_error_handling regarding
Nwhat option 5 does.
N
NUser instructions are printed to stderr (with fprintf) so that output
Ncan be redirected to a file. When output is redirected and user
Ninstructions are printed to stdout (with printf), the instructions get
Nredirected and the user does not see them.
N
N*/
N
N/*******************************************************************************
N* Function Name  : main
N* Description    : Main program.
N* Input          : None
N* Output         : None
N* Return         : None
N*******************************************************************************/
N
Nint main(int argc, char ** argv)
N{  
N/******************************RS274NGC******************************/
N	int status;
N	int choice;
N	int do_next;                                  /* 0=continue, 1=mdi, 2=stop */
N	int block_delete;
N	char buffer[80];
N	int tool_flag;
N	int gees[RS274NGC_ACTIVE_G_CODES];
X	int gees[12];
N	int ems[RS274NGC_ACTIVE_M_CODES];
X	int ems[7];
N	double sets[RS274NGC_ACTIVE_SETTINGS];
X	double sets[3];
N	char default_name[] SET_TO "rs274ngc.var";
X	char default_name[] = "rs274ngc.var";
N	int print_stack;
N	u16 i;
N/******************************RS274NGC******************************/	
N	
N	
N   
N   
N#ifdef DEBUG
S  debug();
N#endif
N
N	/* Configure the system clocks */
N	RCC_Configuration();
N	
N	/* NVIC Configuration */
N	NVIC_Configuration();
N	
N	/* Configure the GPIOs */
N	GPIO_Configuration();
N	
N	/* Configure the USART1 */
N	USART_Configuration();
N	
N	
N	//printf("\r\n Welcome to www.PowerAVR.com \r\n");
N	//printf("\r\n Please Input Character From Keyboard \r\n");
N
N    
N/******************************RS274/NGCmain******************************/
N  	/*
N	if (argc > 3)
N	{
N	    fprintf(stderr, "Usage \"%s\"\r\n", argv[0]);
N	    fprintf(stderr, "   or \"%s <input file>\"\r\n", argv[0]);
N	    fprintf(stderr, "   or \"%s <input file> <output file>\"\r\n", argv[0])
N	    //exit(1);
N		return 1;
N	}
N	*/
N	buffer[0]='1';
N	i=0;
N	choice=1;
N
N	do_next SET_TO 2;                             /* 2=stop */
X	do_next = 2;                              
N	block_delete SET_TO OFF;
X	block_delete = 0;
N	print_stack SET_TO OFF;
X	print_stack = 0;
N	tool_flag SET_TO 0;
X	tool_flag = 0;
N	strcpy(_parameter_file_name, default_name);
N	_outfile SET_TO stdout;                       /* may be reset below */
X	_outfile = (& __stdout);                        
N	
N	for(; ;)
N	{
N	    fprintf(stderr, "\r\nenter a number:\r\n");
X	    fprintf((& __stderr), "\r\nenter a number:\r\n");
N	    fprintf(stderr, "1 = start interpreting\r\n");
X	    fprintf((& __stderr), "1 = start interpreting\r\n");
N	    fprintf(stderr, "2 = choose parameter file ...\r\n");
X	    fprintf((& __stderr), "2 = choose parameter file ...\r\n");
N	    fprintf(stderr, "3 = read tool file ...\r\n");
X	    fprintf((& __stderr), "3 = read tool file ...\r\n");
N	    fprintf(stderr, "4 = turn block delete switch %s\r\n",
X	    fprintf((& __stderr), "4 = turn block delete switch %s\r\n",
N	        ((block_delete IS OFF) ? "ON" : "OFF"));
X	        ((block_delete == 0) ? "ON" : "OFF"));
N	    fprintf(stderr, "5 = adjust error handling...\r\n");
X	    fprintf((& __stderr), "5 = adjust error handling...\r\n");
N	    fprintf(stderr, "enter choice => 1\r\n");
X	    fprintf((& __stderr), "enter choice => 1\r\n");
N	    //gets(buffer);
N	    //if (sscanf(buffer, "%d", &choice) ISNT 1)
N	    //    continue;
N	    if (choice IS 1)
X	    if (choice == 1)
N	        break;
N	    else if (choice IS 2)
X	    else if (choice == 2)
N	    {
N	        if (designate_parameter_file(_parameter_file_name) ISNT 0)
X	        if (designate_parameter_file(_parameter_file_name) != 0)
N				return 1;
N/*	            exit(1);*/
N	    }
N	    else if (choice IS 3)
X	    else if (choice == 3)
N	    {
N	        if (read_tool_file("") ISNT 0)
X	        if (read_tool_file("") != 0)
N				return 1;
N/*	            exit(1);*/
N	        tool_flag SET_TO 1;
X	        tool_flag = 1;
N	    }
N	    else if (choice IS 4)
X	    else if (choice == 4)
N	        block_delete SET_TO ((block_delete IS OFF) ? ON : OFF);
X	        block_delete = ((block_delete == 0) ? 1 : 0);
N	    else if (choice IS 5)
X	    else if (choice == 5)
N	        adjust_error_handling(argc, &print_stack, &do_next);
N	}
N	fprintf(stderr, "executing\r\n");
X	fprintf((& __stderr), "executing\r\n");
N	if (tool_flag IS 0)
X	if (tool_flag == 0)
N	{
N	    if (read_tool_file("rs274ngc.tool_default") ISNT 0)
X	    if (read_tool_file("rs274ngc.tool_default") != 0)
N			return 1;
N/*	        exit(1);*/
N	}
N	
N	if (argc IS 3)
X	if (argc == 3)
N	{
N	    _outfile SET_TO fopen(argv[2], "w");
X	    _outfile = fopen(argv[2], "w");
N	    if (_outfile IS NULL)
X	    if (_outfile == 0)
N	    {
N	        fprintf(stderr, "could not open output file %s\r\n", argv[2]);
X	        fprintf((& __stderr), "could not open output file %s\r\n", argv[2]);
N			return 1;
N/*	        exit(1);*/
N	    }
N	}
N	
N	if ((status SET_TO rs274ngc_init()) ISNT RS274NGC_OK)
X	if ((status = rs274ngc_init()) != 0)
N	{
N	    report_error(status, print_stack);
N		return 1;
N/*	    exit(1);*/
N	}
N	
N//	if (argc IS 1)
N	    status SET_TO interpret_from_keyboard(block_delete, print_stack);
X	    status = interpret_from_keyboard(block_delete, print_stack);
N//	else                                          /* if (argc IS 2 or argc IS 3) */
N//	{
N//	    status SET_TO rs274ngc_open(argv[1]);
N//	    if (status ISNT RS274NGC_OK)              /* do not need to close since not open */
N//	    {
N//	        report_error(status, print_stack);
N//			return 1;
N///*	        exit(1);*/
N//	    }
N//	    status SET_TO interpret_from_file(do_next, block_delete, print_stack);
N//	    rs274ngc_file_name(buffer, 5);            /* called to exercise the function */
N//	    rs274ngc_file_name(buffer, 79);           /* called to exercise the function */
N//	    rs274ngc_close();
N//	}
N	rs274ngc_line_length();                       /* called to exercise the function */
N	rs274ngc_sequence_number();                   /* called to exercise the function */
N	rs274ngc_active_g_codes(gees);                /* called to exercise the function */
N	rs274ngc_active_m_codes(ems);                 /* called to exercise the function */
N	rs274ngc_active_settings(sets);               /* called to exercise the function */
N	rs274ngc_exit();                              /* saves parameters */
N	return(status);
N/*	exit(status);*/
N/******************************RS274/NGCmain******************************/
N/*	while(1)
N	{	
N		if(USART_GetFlagStatus(USART1,USART_IT_RXNE)==SET)
N		{	           
N			i = USART_ReceiveData(USART1);
N			printf("  %c",i&0xFF);
N					
N		}
N	}*/
W "main.c" 630 7 variable "buffer" was set but never used
W "main.c" 637 6 variable "i" was set but never used
N}
N
N#ifdef  DEBUG
S/*******************************************************************************
S* Function Name  : assert_failed
S* Description    : Reports the name of the source file and the source line number
S*                  where the assert error has occurred.
S* Input          : - file: pointer to the source file name
S*                  - line: assert error line source number
S* Output         : None
S* Return         : None
S*******************************************************************************/
Svoid assert_failed(u8* file, u32 line)
S{ 
S  /* User can add his own implementation to report the file name and line number */
S
S  printf("\n\r Wrong parameter value detected on\r\n");
S  printf("       file  %s\r\n", file);
S  printf("       line  %d\r\n", line);
S    
S  /* Infinite loop */
S  /* while (1)
S  {
S  } */
S}
N#endif
N
N/*******************************************************************************
N* Function Name  : RCC_Configuration
N* Description    : Configures the different system clocks.
N* Input          : None
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid RCC_Configuration(void)
N{
N  /* RCC system reset(for debug purpose) */
N  RCC_DeInit();
N
N  /* Enable HSE */
N  RCC_HSEConfig(RCC_HSE_ON);
X  RCC_HSEConfig(((u32)0x00010000));
N
N  /* Wait till HSE is ready */
N  HSEStartUpStatus = RCC_WaitForHSEStartUp();
N
N  if(HSEStartUpStatus == SUCCESS)
N  {
N    /* HCLK = SYSCLK */
N    RCC_HCLKConfig(RCC_SYSCLK_Div1); 
X    RCC_HCLKConfig(((u32)0x00000000)); 
N  
N    /* PCLK2 = HCLK */
N    RCC_PCLK2Config(RCC_HCLK_Div1); 
X    RCC_PCLK2Config(((u32)0x00000000)); 
N
N    /* PCLK1 = HCLK/2 */
N    RCC_PCLK1Config(RCC_HCLK_Div2);
X    RCC_PCLK1Config(((u32)0x00000400));
N
N    /* Flash 2 wait state */
N    FLASH_SetLatency(FLASH_Latency_2);
X    FLASH_SetLatency(((u32)0x00000002));
N    /* Enable Prefetch Buffer */
N    FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
X    FLASH_PrefetchBufferCmd(((u32)0x00000010));
N
N    /* PLLCLK = 8MHz * 9 = 72 MHz */
N    RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
X    RCC_PLLConfig(((u32)0x00010000), ((u32)0x001C0000));
N
N    /* Enable PLL */ 
N    RCC_PLLCmd(ENABLE);
N
N    /* Wait till PLL is ready */
N    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
X    while(RCC_GetFlagStatus(((u8)0x39)) == RESET)
N    {
N    }
N
N    /* Select PLL as system clock source */
N    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
X    RCC_SYSCLKConfig(((u32)0x00000002));
N
N    /* Wait till PLL is used as system clock source */
N    while(RCC_GetSYSCLKSource() != 0x08)
N    {
N    }
N  }
N   
N  /* Enable USART1 and GPIOA clock */
N  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
X  RCC_APB2PeriphClockCmd(((u32)0x00004000) | ((u32)0x00000004), ENABLE);
N}
N
N/*******************************************************************************
N* Function Name  : NVIC_Configuration
N* Description    : Configures Vector Table base location.
N* Input          : None
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid NVIC_Configuration(void)
N{
N#ifdef  VECT_TAB_RAM  
S  /* Set the Vector Table base location at 0x20000000 */ 
S  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
N#else  /* VECT_TAB_FLASH  */
N  /* Set the Vector Table base location at 0x08000000 */ 
N  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
X  NVIC_SetVectorTable(((u32)0x08000000), 0x0);   
N#endif
N}
N
N/*******************************************************************************
N* Function Name  : GPIO_Configuration
N* Description    : Configures the different GPIO ports.
N* Input          : None
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid GPIO_Configuration(void)
N{
N  GPIO_InitTypeDef GPIO_InitStructure;
N
N  /* Configure USART1 Tx (PA.09) as alternate function push-pull */
N  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
X  GPIO_InitStructure.GPIO_Pin = ((u16)0x0200);
N  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
N  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
N  GPIO_Init(GPIOA, &GPIO_InitStructure);
X  GPIO_Init(((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x0800)), &GPIO_InitStructure);
N    
N  /* Configure USART1 Rx (PA.10) as input floating */
N  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
X  GPIO_InitStructure.GPIO_Pin = ((u16)0x0400);
N  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
N  GPIO_Init(GPIOA, &GPIO_InitStructure);
X  GPIO_Init(((GPIO_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x0800)), &GPIO_InitStructure);
N}
N
N/*******************************************************************************
N* Function Name  : USART_Configuration
N* Description    : Configures the USART1.
N* Input          : None
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid USART_Configuration(void)
N{
N  USART_InitTypeDef USART_InitStructure;
N  USART_ClockInitTypeDef  USART_ClockInitStructure;
N/* USART1 configuration -----------------------------------------------
N
N-------*/
N  /* USART1 configured as follow:
N        - BaudRate = 115200 baud  
N        - Word Length = 8 Bits
N        - One Stop Bit
N        - No parity
N        - Hardware flow control disabled (RTS and CTS signals)
N        - Receive and transmit enabled
N        - USART Clock disabled
N        - USART CPOL: Clock is active low
N        - USART CPHA: Data is captured on the middle 
N        - USART LastBit: The clock pulse of the last data bit is not 
N
Noutput to 
N                         the SCLK pin
N  */
NUSART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
XUSART_ClockInitStructure.USART_Clock = ((u16)0x0000);
NUSART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
XUSART_ClockInitStructure.USART_CPOL = ((u16)0x0000);
NUSART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
XUSART_ClockInitStructure.USART_CPHA = ((u16)0x0200);
NUSART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
XUSART_ClockInitStructure.USART_LastBit = ((u16)0x0000);
N/* Configure the USART1 synchronous paramters */
NUSART_ClockInit(USART1, &USART_ClockInitStructure);
XUSART_ClockInit(((USART_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x3800)), &USART_ClockInitStructure);
N
NUSART_InitStructure.USART_BaudRate = 115200;
NUSART_InitStructure.USART_WordLength = USART_WordLength_8b;
XUSART_InitStructure.USART_WordLength = ((u16)0x0000);
NUSART_InitStructure.USART_StopBits = USART_StopBits_1;
XUSART_InitStructure.USART_StopBits = ((u16)0x0000);
NUSART_InitStructure.USART_Parity = USART_Parity_No ;
XUSART_InitStructure.USART_Parity = ((u16)0x0000) ;
NUSART_InitStructure.USART_HardwareFlowControl = 
N
NUSART_HardwareFlowControl_None;
X((u16)0x0000);
N
N
NUSART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
XUSART_InitStructure.USART_Mode = ((u16)0x0004) | ((u16)0x0008);
N/* Configure USART1 basic and asynchronous paramters */
NUSART_Init(USART1, &USART_InitStructure);
XUSART_Init(((USART_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x3800)), &USART_InitStructure);
N    
N  /* Enable USART1 */
N  USART_Cmd(USART1, ENABLE);
X  USART_Cmd(((USART_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x3800)), ENABLE);
N}
N
N/*******************************************************************************
N* Function Name  : fputc
N* Description    : Retargets the C library printf function to the USART.
N* Input          : None
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nint fputc(int ch, FILE *f)
N{
N  /* Place your implementation of fputc here */
N  /* e.g. write a character to the USART */
N  USART_SendData(USART1, (u8) ch);
X  USART_SendData(((USART_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x3800)), (u8) ch);
N
N  /* Loop until the end of transmission */
N  while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
X  while(USART_GetFlagStatus(((USART_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x3800)), ((u16)0x0040)) == RESET)
N  {
N  }
N
N  return ch;
N}
N
N/******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
N
