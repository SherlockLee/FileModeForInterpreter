L 1 "canon_pre.c"
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N   /* canon.cc
N
N   This file contains two sets of functions:
N   1. functions for the interpreter to call to tell the rest of the world to
N   do something. These all return nothing.
N   2. functions for the interpreter to call to get information from the rest
N   of the world. These all return some type of information.
N   These functions implement the interface between the RS274NGC interpreter
N   and some external environment.
N
N   This version of canon.cc also includes a third set of stuff: a dummy
N   model of the external world. The dummy model is used by the second set
N   of interface functions.
N
N   */
N
N   /************************************************************************/
N
N#include "canon.h"
L 1 "canon.h" 1
N   /************************************************************************
N
N       Copyright 2008 Mark Pictor
N
N   This file is part of RS274NGC.
N
N   RS274NGC is free software: you can redistribute it and/or modify
N   it under the terms of the GNU General Public License as published by
N   the Free Software Foundation, either version 3 of the License, or
N   (at your option) any later version.
N
N   RS274NGC is distributed in the hope that it will be useful,
N   but WITHOUT ANY WARRANTY; without even the implied warranty of
N   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N   GNU General Public License for more details.
N
N   You should have received a copy of the GNU General Public License
N   along with RS274NGC.  If not, see <http://www.gnu.org/licenses/>.
N
N   This software is based on software that was produced by the National
N   Institute of Standards and Technology (NIST).
N
N   ************************************************************************/
N
N#ifndef CANON_HH
N#define CANON_HH
N
N   /* canon.hh
N
N   This is the header file that all applications that use the
N   canonical commands for three- to six-axis machining should include.
N
N   Three mutually orthogonal (in a right-handed system) X, Y, and Z axes
N   are always present. In addition, there may be zero to three rotational
N   axes: A (parallel to the X-axis), B (parallel to the Y-axis), and C
N   (parallel to the Z-axis).
N
N   In the functions that use rotational axes, the axis value is that of a
N   wrapped linear axis, in degrees.
N
N   It is assumed in these activities that the spindle tip is always at
N   some location called the "current location," and the controller always
N   knows where that is. It is also assumed that there is always a
N   "selected plane" which must be the XY-plane, the YZ-plane, or the
N   ZX-plane of the machine.
N
N   */
N
Ntypedef int CANON_PLANE;
N#define CANON_PLANE_XY 1
N#define CANON_PLANE_YZ 2
N#define CANON_PLANE_XZ 3
N
Ntypedef int CANON_UNITS;
N#define CANON_UNITS_INCHES 1
N#define CANON_UNITS_MM 2
N#define CANON_UNITS_CM 3
N
Ntypedef int CANON_MOTION_MODE;
N#define CANON_EXACT_STOP 1
N#define CANON_EXACT_PATH 2
N#define CANON_CONTINUOUS 3
N
Ntypedef int CANON_SPEED_FEED_MODE;
N#define CANON_SYNCHED 1
N#define CANON_INDEPENDENT 2
N
Ntypedef int CANON_DIRECTION;
N#define CANON_STOPPED 1
N#define CANON_CLOCKWISE 2
N#define CANON_COUNTERCLOCKWISE 3
N
Ntypedef int CANON_FEED_REFERENCE;
N#define CANON_WORKPIECE 1
N#define CANON_XYZ 2
N
Ntypedef int CANON_SIDE;
N#define CANON_SIDE_RIGHT 1
N#define CANON_SIDE_LEFT 2
N#define CANON_SIDE_OFF 3
N
Ntypedef int CANON_AXIS;
N#define CANON_AXIS_X 1
N#define CANON_AXIS_Y 2
N#define CANON_AXIS_Z 3
N#define CANON_AXIS_A 4
N#define CANON_AXIS_B 5
N#define CANON_AXIS_C 6
N
N   /* Currently using the typedefs above rather than the enums below
N   typedef enum {CANON_PLANE_XY, CANON_PLANE_YZ, CANON_PLANE_XZ} CANON_PLANE;
N   typedef enum {CANON_UNITS_INCHES, CANON_UNITS_MM, CANON_UNITS_CM} CANON_UNITS;
N   typedef enum {CANON_EXACT_STOP, CANON_EXACT_PATH, CANON_CONTINUOUS}
N   CANON_MOTION_MODE;
N   typedef enum {CANON_SYNCHED, CANON_INDEPENDENT} CANON_SPEED_FEED_MODE;
N   typedef enum {CANON_STOPPED, CANON_CLOCKWISE, CANON_COUNTERCLOCKWISE}
N   CANON_DIRECTION;
N   typedef enum {CANON_WORKPIECE, CANON_XYZ} CANON_FEED_REFERENCE;
N   typedef enum {CANON_SIDE_RIGHT, CANON_SIDE_LEFT, CANON_SIDE_OFF} CANON_SIDE;
N   typedef enum {CANON_AXIS_X, CANON_AXIS_Y, CANON_AXIS_Z, CANON_AXIS_A,
N   CANON_AXIS_B, CANON_AXIS_C} CANON_AXIS;
N   */
N
N/*
Nstruct CANON_VECTOR
N{
N    double x, y, z;
N    CANON_VECTOR() {}
N    CANON_VECTOR(double _x, double _y, double _z) 
N	{
N		x = _x; y = _y; z = _z;
N	}
N};
N
Nstruct CANON_POSITION
N{
N    CANON_POSITION() {}
N    CANON_POSITION(double _x, double _y, double _z
N    #ifdef AA
N        , double _a
N    #endif
N    #ifdef BB
N        , double _b
N    #endif
N    #ifdef CC
N        , double _c
N    #endif
N        )
N    {
N        x = _x; y = _y; z = _z;
N#ifdef AA
N        a = _a;
N#endif
N#ifdef BB
N        b = _b;
N#endif
N#ifdef CC
N        c = _c;
N#endif
N    }
N    double x, y, z
N    #ifdef AA
N        , a
N    #endif
N    #ifdef BB
N        , b
N    #endif
N    #ifdef CC
N        , c
N    #endif
N        ;
N};
N*/
N
N   /* Tools are numbered 1..CANON_TOOL_MAX, with tool 0 meaning no tool. */
N#define CANON_TOOL_MAX 128                        // max size of carousel handled
N#define CANON_TOOL_ENTRY_LEN 256                  // how long each file line can be
N
Ntypedef struct canon_tool_table
N{
N    int id;
N    double length;
N    double diameter;
N}CANON_TOOL_TABLE;
N
N   /* Initialization */
N
N   /* reads world model data into the canonical interface */
W "canon.h" 169 13 Deprecated declaration INIT_CANON - give arg types
Nextern void INIT_CANON();
N
N   /* Representation */
N
Nextern void SET_ORIGIN_OFFSETS(
Ndouble x, double y, double z
N#ifdef AA
S, double a
N#else
N#ifdef ALL_AXES
S, double a
N#endif
N#endif
N#ifdef BB
S, double b
N#else
N#ifdef ALL_AXES
S, double b
N#endif
N#endif
N#ifdef CC
S, double c
N#else
N#ifdef ALL_AXES
S, double c
N#endif
N#endif
N);
N
N   /* Offset the origin to the point with absolute coordinates x, y, z,
N   a, b, and c. Values of x, y, z, a, b, and c are real numbers. The units
N   are whatever length units are being used at the time this command is
N   given. */
N
Nextern void USE_LENGTH_UNITS(CANON_UNITS u);
N
N   /* Use the specified units for length. Conceptually, the units must
N   be either inches or millimeters. */
N
Nextern void SELECT_PLANE(CANON_PLANE pl);
N
N   /* Use the plane designated by selected_plane as the selected plane.
N   Conceptually, the selected_plane must be the XY-plane, the XZ-plane, or
N   the YZ-plane. */
N
N   /* Free Space Motion */
N
Nextern void SET_TRAVERSE_RATE(double rate);
N
N   /* Set the traverse rate that will be used when the spindle traverses. It
N   is expected that no cutting will occur while a traverse move is being
N   made. */
N
Nextern void STRAIGHT_TRAVERSE(
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N   /*
N
N   Move at traverse rate so that at any time during the move, all axes
N   have covered the same proportion of their required motion. The final
N   XYZ position is given by x, y, and z. If there is an a-axis, its final
N   position is given by a_position, and similarly for the b-axis and c-axis.
N   A more positive value of a rotational axis is in the counterclockwise
N   direction.
N
N   Clockwise or counterclockwise is from the point of view of the
N   workpiece. If the workpiece is fastened to a turntable, the turntable
N   will turn clockwise (from the point of view of the machinist or anyone
N   else not moving with respect to the machining center) in order to make
N   the tool move counterclockwise from the point of view of the
N   workpiece.
N
N   */
N
N   /* Machining Attributes */
N
Nextern void SET_FEED_RATE(double rate);
N
N   /* 
N
N   SET_FEED_RATE sets the feed rate that will be used when the spindle is
N   told to move at the currently set feed rate. The rate is either:
N   1. the rate of motion of the tool tip in the workpiece coordinate system,
N   which is used when the feed_reference mode is "CANON_WORKPIECE", or
N   2. the rate of motion of the tool tip in the XYZ axis system, ignoring
N   motion of other axes, which is used when the feed_reference mode is
N   "CANON_XYZ".
N
N   The units of the rate are:
N
N   1. If the feed_reference mode is CANON_WORKPIECE:
N   length units (inches or millimeters according to the setting of
N   CANON_UNITS) per minute along the programmed path as seen by the
N   workpiece.
N
N   2. If the feed_reference mode is CANON_XYZ:
N   A. For motion including one rotational axis only: degrees per minute.
N   B. For motion including two rotational axes only: degrees per minute
N   In this case, the rate applies to the axis with the larger angle
N   to cover, and the second rotational axis rotates so that it has
N   always completed the same proportion of its required motion as has
N   the rotational axis to which the feed rate applies.
N   C. For motion involving one or more of the XYZ axes (with or without
N   simultaneous rotational axis motion): length units (inches or
N   millimeters according to the setting of CANON_UNITS) per minute
N   along the programmed XYZ path.
N
N   */
N
Nextern void SET_FEED_REFERENCE(CANON_FEED_REFERENCE reference);
N
N   /*
N
N   This sets the feed_reference mode to either CANON_WORKPIECE or
N   CANON_XYZ.
N
N   The CANON_WORKPIECE mode is more natural and general, since the rate
N   at which the tool passes through the material must be controlled for
N   safe and effective machining. For machines with more than the three
N   standard XYZ axes, however, computing the feed rate may be
N   time-consuming because the trajectories that result from motion in
N   four or more axes may be complex. Computation of path lengths when
N   only XYZ motion is considered is quite simple for the two standard
N   motion types (straight lines and helical arcs).
N
N   Some programming languages (rs274kt, in particular) use CANON_XYZ
N   mode. In these languages, the task of dealing with the rate at which
N   the tool tip passes through material is pushed back on the NC-program
N   generator, where the computation of path lengths is (almost always in
N   1995) an off-line activity where speed of calculation is not critical.
N
N   In CANON_WORKPIECE mode, some motions cannot be carried out as fast as
N   the programmed feed rate would require because axis motions tend to
N   cancel each other. For example, an arc in the YZ-plane can exactly
N   cancel a rotation around the A-axis, so that the location of the tool
N   tip with respect to the workpiece does not change at all during the
N   motion; in this case, the motion should take no time, which is
N   impossible at any finite rate of axis motion. In such cases, the axes
N   should be moved as fast as possible consistent with accurate
N   machining.
N
N   It would be possible to omit the SET_FEED_REFERENCE command from the
N   canonical commands and operate always in one mode or the other,
N   letting the interpreter issue SET_FEED_RATE commands, if necessary to
N   compensate if the NC language being interpreted used the other mode.
N
N   This would create two disadvantages when the feed_reference mode
N   assumed by the canonical commands differed from that assumed by the NC
N   language being interpreted:
N
N   1. The output code could have a lot of SET_FEED_RATE commands not
N   found in the input code; this is a relatively minor consideration.
N
N   2. If the interpreter reads a program in language which uses the
N   CANON_XYZ mode and writes canonical commands in the CANON_WORKPIECE
N   mode, both the interpreter and the executor of the output canonical
N   commands would have to perform a lot of complex calculations. With the
N   SET_FEED_REFERENCE command available, both do only simple calculations
N   for the same motions.
N
N   */
N
Nextern void SET_MOTION_CONTROL_MODE(CANON_MOTION_MODE mode);
N
N   /*
N
N   This sets the motion control mode to one of: CANON_EXACT_STOP,
N   CANON_EXACT_PATH, or CANON_CONTINUOUS.
N
N   */
N
Nextern void SET_CUTTER_RADIUS_COMPENSATION(double radius);
N
N   /* Set the radius to use when performing cutter radius compensation. */
N
Nextern void START_CUTTER_RADIUS_COMPENSATION(int direction);
N
N   /* Conceptually, the direction must be left (meaning the cutter
N   stays to the left of the programmed path) or right. */
N
W "canon.h" 370 13 Deprecated declaration STOP_CUTTER_RADIUS_COMPENSATION - give arg types
Nextern void STOP_CUTTER_RADIUS_COMPENSATION();
N
N   /* Do not apply cutter radius compensation when executing spindle
N   translation commands. */
N
W "canon.h" 375 13 Deprecated declaration START_SPEED_FEED_SYNCH - give arg types
Nextern void START_SPEED_FEED_SYNCH();
W "canon.h" 376 13 Deprecated declaration STOP_SPEED_FEED_SYNCH - give arg types
Nextern void STOP_SPEED_FEED_SYNCH();
N
N   /* Machining Functions */
N
Nextern void ARC_FEED(
Ndouble first_end,
Ndouble second_end,
Ndouble first_axis,
Ndouble second_axis,
Nint rotation,
Ndouble axis_end_point
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Move in a helical arc from the current location at the existing feed
N   rate. The axis of the helix is parallel to the x, y, or z axis,
N   according to which one is perpendicular to the selected plane. The
N   helical arc may degenerate to a circular arc if there is no motion
N   parallel to the axis of the helix.
N
N   1. If the selected plane is the xy-plane:
N   A. first_end is the x-coordinate of the end of the arc.
N   B. second_end is the y-coordinate of the end of the arc.
N   C. first_axis is the x-coordinate of the axis (center) of the arc.
N   D. second_axis is the y-coordinate of the axis.
N   E. axis_end_point is the z-coordinate of the end of the arc.
N
N   2. If the selected plane is the yz-plane:
N   A. first_end is the y-coordinate of the end of the arc.
N   B. second_end is the z-coordinate of the end of the arc.
N   C. first_axis is the y-coordinate of the axis (center) of the arc.
N   D. second_axis is the z-coordinate of the axis.
N   E. axis_end_point is the x-coordinate of the end of the arc.
N
N   3. If the selected plane is the zx-plane:
N   A. first_end is the z-coordinate of the end of the arc.
N   B. second_end is the x-coordinate of the end of the arc.
N   C. first_axis is the z-coordinate of the axis (center) of the arc.
N   D. second_axis is the x-coordinate of the axis.
N   E. axis_end_point is the y-coordinate of the end of the arc.
N
N   If rotation is positive, the arc is traversed counterclockwise as
N   viewed from the positive end of the coordinate axis perpendicular to
N   the currently selected plane. If rotation is negative, the arc is
N   traversed clockwise. If rotation is 0, first_end and second_end must
N   be the same as the corresponding coordinates of the current point and
N   no arc is made (but there may be translation parallel to the axis
N   perpendicular to the selected plane and motion along the rotational axes).
N   If rotation is 1, more than 0 but not more than 360 degrees of arc
N   should be made. In general, if rotation is n, the amount of rotation
N   in the arc should be more than ([n-1] x 360) but not more than (n x
N   360).
N
N   The radius of the helix is determined by the distance from the current
N   location to the axis of helix or by the distance from the end location
N   to the axis of the helix. It is recommended that the executing system
N   verify that the two radii are the same (within some tolerance) at the
N   beginning of executing this function.
N
N   While the XYZ motion is going on, move the rotational axes so that
N   they have always covered the same proportion of their total motion as
N   a point moving along the arc has of its total motion.
N
N   */
N
Nextern void STRAIGHT_FEED(
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Move at existing feed rate so that at any time during the move,
N   all axes have covered the same proportion of their required motion.
N   The meanings of the parameters is the same as for STRAIGHT_TRAVERSE.*/
N
Nextern void STRAIGHT_PROBE (
Ndouble x, double y, double z
N#ifdef AA
S, double a_position
N#else
N#ifdef ALL_AXES
S, double a_position
N#endif
N#endif
N#ifdef BB
S, double b_position
N#else
N#ifdef ALL_AXES
S, double b_position
N#endif
N#endif
N#ifdef CC
S, double c_position
N#else
N#ifdef ALL_AXES
S, double c_position
N#endif
N#endif
N);
N
N   /* Perform a probing operation. This is a temporary addition to the
N   canonical machining functions and its semantics are not defined.
N   When the operation is finished, all axes should be back where they
N   started. */
N
W "canon.h" 520 13 Deprecated declaration STOP - give arg types
Nextern void STOP();
N
N   /* stop motion after current feed */
N
Nextern void DWELL(double seconds);
N
N   /* freeze x,y,z for a time */
N
N   /* Spindle Functions */
N
W "canon.h" 530 13 Deprecated declaration SPINDLE_RETRACT_TRAVERSE - give arg types
Nextern void SPINDLE_RETRACT_TRAVERSE();
N
N   /* Retract the spindle at traverse rate to the fully retracted position. */
N
W "canon.h" 534 13 Deprecated declaration START_SPINDLE_CLOCKWISE - give arg types
Nextern void START_SPINDLE_CLOCKWISE();
N
N   /* Turn the spindle clockwise at the currently set speed rate. If the
N   spindle is already turning that way, this command has no effect. */
N
W "canon.h" 539 13 Deprecated declaration START_SPINDLE_COUNTERCLOCKWISE - give arg types
Nextern void START_SPINDLE_COUNTERCLOCKWISE();
N
N   /* Turn the spindle counterclockwise at the currently set speed rate. If
N   the spindle is already turning that way, this command has no effect. */
N
Nextern void SET_SPINDLE_SPEED(double r);
N
N   /* Set the spindle speed that will be used when the spindle is turning.
N   This is usually given in rpm and refers to the rate of spindle
N   rotation. If the spindle is already turning and is at a different
N   speed, change to the speed given with this command. */
N
W "canon.h" 551 13 Deprecated declaration STOP_SPINDLE_TURNING - give arg types
Nextern void STOP_SPINDLE_TURNING();
N
N   /* Stop the spindle from turning. If the spindle is already stopped, this
N   command may be given, but it will have no effect. */
N
W "canon.h" 556 13 Deprecated declaration SPINDLE_RETRACT - give arg types
Nextern void SPINDLE_RETRACT();
Nextern void ORIENT_SPINDLE(double orientation, CANON_DIRECTION direction);
W "canon.h" 558 13 Deprecated declaration LOCK_SPINDLE_Z - give arg types
Nextern void LOCK_SPINDLE_Z();
W "canon.h" 559 13 Deprecated declaration USE_SPINDLE_FORCE - give arg types
Nextern void USE_SPINDLE_FORCE();
W "canon.h" 560 13 Deprecated declaration USE_NO_SPINDLE_FORCE - give arg types
Nextern void USE_NO_SPINDLE_FORCE();
N
N   /* Tool Functions */
Nextern void USE_TOOL_LENGTH_OFFSET(double length);
N
Nextern void CHANGE_TOOL(int slot);                /* slot is slot number */
N
N   /* It is assumed that each cutting tool in the machine is assigned to a
N   slot (intended to correspond to a slot number in a tool carousel).
N   This command results in the tool currently in the spindle (if any)
N   being returned to its slot, and the tool from the slot designated by
N   slot_number (if any) being inserted in the spindle.
N
N   If there is no tool in the slot designated by the slot argument, there
N   will be no tool in the spindle after this command is executed and no
N   error condition will result in the controller. Similarly, if there is
N   no tool in the spindle when this command is given, no tool will be
N   returned to the carousel and no error condition will result in the
N   controller, whether or not a tool was previously selected in the
N   program.
N
N   It is expected that when the machine tool controller is initialized,
N   the designated slot for a tool already in the spindle will be
N   established. This may be done in any manner deemed fit, including
N   (for, example) recording that information in a persistent, crash-proof
N   location so it is always available from the last time the machine was
N   run, or having the operator enter it. It is expected that the machine
N   tool controller will remember that information as long as it is
N   not re-initialized; in particular, it will be remembered between
N   programs.
N
N   For the purposes of this command, the tool includes the tool holder.
N
N   For machines which can carry out a select_tool command separately from
N   a change_tool command, the select_tool command must have been given
N   before the change_tool command, and the value of slot must be the slot
N   number of the selected tool. */
N
Nextern void SELECT_TOOL(int i);                   /* i is slot number */
N
N   /* Miscellaneous Functions */
N
Nextern void CLAMP_AXIS(CANON_AXIS axis);
N
N   /* Clamp the given axis. If the machining center does not have a clamp
N   for that axis, this command should result in an error condition in the
N   controller.
N
N   An attempt to move an axis while it is clamped should result in an
N   error condition in the controller. */
N
Nextern void COMMENT(char *s);
N
N   /* This function has no physical effect. If commands are being printed or
N   logged, the comment command is printed or logged, including the string
N   which is the value of comment_text. This serves to allow formal
N   comments at specific locations in programs or command files. */
N
W "canon.h" 618 13 Deprecated declaration DISABLE_FEED_OVERRIDE - give arg types
Nextern void DISABLE_FEED_OVERRIDE();
W "canon.h" 619 13 Deprecated declaration ENABLE_FEED_OVERRIDE - give arg types
Nextern void ENABLE_FEED_OVERRIDE();
W "canon.h" 620 13 Deprecated declaration DISABLE_SPEED_OVERRIDE - give arg types
Nextern void DISABLE_SPEED_OVERRIDE();
W "canon.h" 621 13 Deprecated declaration ENABLE_SPEED_OVERRIDE - give arg types
Nextern void ENABLE_SPEED_OVERRIDE();
W "canon.h" 622 13 Deprecated declaration FLOOD_OFF - give arg types
Nextern void FLOOD_OFF();
N   /* Turn flood coolant off. */
W "canon.h" 624 13 Deprecated declaration FLOOD_ON - give arg types
Nextern void FLOOD_ON();
N   /* Turn flood coolant on. */
N
Nextern void MESSAGE(char *s);
N
W "canon.h" 629 13 Deprecated declaration MIST_OFF - give arg types
Nextern void MIST_OFF();
N   /* Turn mist coolant off. */
N
W "canon.h" 632 13 Deprecated declaration MIST_ON - give arg types
Nextern void MIST_ON();
N   /* Turn mist coolant on. */
N
W "canon.h" 635 13 Deprecated declaration PALLET_SHUTTLE - give arg types
Nextern void PALLET_SHUTTLE();
N
N   /* If the machining center has a pallet shuttle mechanism (a mechanism
N   which switches the position of two pallets), this command should cause
N   that switch to be made. If either or both of the pallets are missing,
N   this will not result in an error condition in the controller.
N
N   If the machining center does not have a pallet shuttle, this command
N   should result in an error condition in the controller. */
N
W "canon.h" 645 13 Deprecated declaration TURN_PROBE_OFF - give arg types
Nextern void TURN_PROBE_OFF();
W "canon.h" 646 13 Deprecated declaration TURN_PROBE_ON - give arg types
Nextern void TURN_PROBE_ON();
N
Nextern void UNCLAMP_AXIS(CANON_AXIS axis);
N
N   /* Unclamp the given axis. If the machining center does not have a clamp
N   for that axis, this command should result in an error condition in the
N   controller. */
N
N   /* NURB Functions */
W "canon.h" 655 13 Deprecated declaration NURB_KNOT_VECTOR - give arg types
Nextern void NURB_KNOT_VECTOR();                   /* double knot values, -1.0 signals done */
Nextern void NURB_CONTROL_POINT(int i, double x, double y, double z, double w );
Nextern void NURB_FEED(double sStart, double sEnd);
N
N   /* Program Functions */
W "canon.h" 660 13 Deprecated declaration OPTIONAL_PROGRAM_STOP - give arg types
Nextern void OPTIONAL_PROGRAM_STOP();
N
N   /* If the machining center has an optional stop switch, and it is on
N   when this command is read from a program, stop executing the program
N   at this point, but be prepared to resume with the next line of the
N   program. If the machining center does not have an optional stop
N   switch, or commands are being executed with a stop after each one
N   already (such as when the interpreter is being used with keyboard
N   input), this command has no effect. */
N
W "canon.h" 670 13 Deprecated declaration PROGRAM_END - give arg types
Nextern void PROGRAM_END();
N   /* If a program is being read, stop executing the program and be prepared
N   to accept a new program or to be shut down. */
N
W "canon.h" 674 13 Deprecated declaration PROGRAM_STOP - give arg types
Nextern void PROGRAM_STOP();
N   /* If this command is read from a program, stop executing the program at
N   this point, but be prepared to resume with the next line of the
N   program. If commands are being executed with a stop after each one
N   already (such as when the interpreter is being used with keyboard
N   input), this command has no effect. */
N
N   /*************************************************************************/
N
N   /* Canonical "Give me information" functions for the interpreter to call
N
N   In general, returned values are valid only if any canonical do it commands
N   that may have been called for have been executed to completion. If a function
N   returns a valid value regardless of execution, that is noted in the comments
N   below.
N
N   */
N
N   /* The interpreter is not using this function
N   // Returns the system angular unit factor, in units / degree
N   extern double GET_EXTERNAL_ANGLE_UNIT_FACTOR();
N   */
N
N   // Returns the system feed rate
W "canon.h" 698 15 Deprecated declaration GET_EXTERNAL_FEED_RATE - give arg types
Nextern double GET_EXTERNAL_FEED_RATE();
N
N   // Returns the system value for flood coolant, zero = off, non-zero = on
W "canon.h" 701 12 Deprecated declaration GET_EXTERNAL_FLOOD - give arg types
Nextern int GET_EXTERNAL_FLOOD();
N
N   /* The interpreter is not using this function
N   // Returns the system length unit factor, in units / mm
N   extern double GET_EXTERNAL_LENGTH_UNIT_FACTOR();
N   */
N
N   // Returns the system length unit type
W "canon.h" 709 13 Deprecated declaration GET_EXTERNAL_LENGTH_UNIT_TYPE - give arg types
NCANON_UNITS GET_EXTERNAL_LENGTH_UNIT_TYPE();
N
N   // Returns the system value for mist coolant, zero = off, non-zero = on
W "canon.h" 712 12 Deprecated declaration GET_EXTERNAL_MIST - give arg types
Nextern int GET_EXTERNAL_MIST();
N
N   // Returns the current motion control mode
W "canon.h" 715 26 Deprecated declaration GET_EXTERNAL_MOTION_CONTROL_MODE - give arg types
Nextern CANON_MOTION_MODE GET_EXTERNAL_MOTION_CONTROL_MODE();
N
N   /* The interpreter is not using these six GET_EXTERNAL_ORIGIN functions
N
N   #ifdef AA
N   // returns the current a-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_A();
N   #endif
N
N   #ifdef BB
N   // returns the current b-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_B();
N   #endif
N
N   #ifdef CC
N   // returns the current c-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_C();
N   #endif
N
N   // returns the current x-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_X();
N
N   // returns the current y-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_Y();
N
N   // returns the current z-axis origin offset
N   extern double GET_EXTERNAL_ORIGIN_Z();
N
N   */
N
N   // returns nothing but copies the name of the parameter file into
N   // the filename array, stopping at max_size if the name is longer
N   // An empty string may be placed in filename.
Nextern void GET_EXTERNAL_PARAMETER_FILE_NAME(char * filename, unsigned int max_size);
N
N   // returns the currently active plane
W "canon.h" 751 20 Deprecated declaration GET_EXTERNAL_PLANE - give arg types
Nextern CANON_PLANE GET_EXTERNAL_PLANE();
N
N#ifdef AA
S   // returns the current a-axis position
Sextern double GET_EXTERNAL_POSITION_A();
N#endif
N
N#ifdef BB
S   // returns the current b-axis position
Sextern double GET_EXTERNAL_POSITION_B();
N#endif
N
N#ifdef CC
S   // returns the current c-axis position
Sextern double GET_EXTERNAL_POSITION_C();
N#endif
N
N   // returns the current x-axis position
W "canon.h" 769 15 Deprecated declaration GET_EXTERNAL_POSITION_X - give arg types
Nextern double GET_EXTERNAL_POSITION_X();
N
N   // returns the current y-axis position
W "canon.h" 772 15 Deprecated declaration GET_EXTERNAL_POSITION_Y - give arg types
Nextern double GET_EXTERNAL_POSITION_Y();
N
N   // returns the current z-axis position
W "canon.h" 775 15 Deprecated declaration GET_EXTERNAL_POSITION_Z - give arg types
Nextern double GET_EXTERNAL_POSITION_Z();
N
N#ifdef AA
S   // Returns the machine A-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_A();
N#endif
N
N#ifdef BB
S   // Returns the machine B-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_B();
N#endif
N
N#ifdef CC
S   // Returns the machine C-axis position at the last probe trip.
Sextern double GET_EXTERNAL_PROBE_POSITION_C();
N#endif
N
N   // Returns the machine X-axis position at the last probe trip.
W "canon.h" 793 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_X - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_X();
N
N   // Returns the machine Y-axis position at the last probe trip.
W "canon.h" 796 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_Y - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_Y();
N
N   // Returns the machine Z-axis position at the last probe trip.
W "canon.h" 799 15 Deprecated declaration GET_EXTERNAL_PROBE_POSITION_Z - give arg types
Nextern double GET_EXTERNAL_PROBE_POSITION_Z();
N
N   // Returns the value for any analog non-contact probing.
W "canon.h" 802 15 Deprecated declaration GET_EXTERNAL_PROBE_VALUE - give arg types
Nextern double GET_EXTERNAL_PROBE_VALUE();
N
N   // Returns zero if queue is not empty, non-zero if the queue is empty
N   // This always returns a valid value
W "canon.h" 806 12 Deprecated declaration GET_EXTERNAL_QUEUE_EMPTY - give arg types
Nextern int GET_EXTERNAL_QUEUE_EMPTY();
N
N   // Returns the system value for spindle speed in rpm
W "canon.h" 809 15 Deprecated declaration GET_EXTERNAL_SPEED - give arg types
Nextern double GET_EXTERNAL_SPEED();
N
N   // Returns the system value for direction of spindle turning
W "canon.h" 812 24 Deprecated declaration GET_EXTERNAL_SPINDLE - give arg types
Nextern CANON_DIRECTION GET_EXTERNAL_SPINDLE();
N
N   // returns current tool length offset
W "canon.h" 815 15 Deprecated declaration GET_EXTERNAL_TOOL_LENGTH_OFFSET - give arg types
Nextern double GET_EXTERNAL_TOOL_LENGTH_OFFSET();
N
N   // Returns number of slots in carousel
W "canon.h" 818 12 Deprecated declaration GET_EXTERNAL_TOOL_MAX - give arg types
Nextern int GET_EXTERNAL_TOOL_MAX();
N
N   // Returns the system value for the carousel slot in which the tool
N   // currently in the spindle belongs. Return value zero means there is no
N   // tool in the spindle.
W "canon.h" 823 12 Deprecated declaration GET_EXTERNAL_TOOL_SLOT - give arg types
Nextern int GET_EXTERNAL_TOOL_SLOT();
N
N   // Returns the CANON_TOOL_TABLE structure associated with the tool
N   // in the given pocket
Nextern CANON_TOOL_TABLE GET_EXTERNAL_TOOL_TABLE(int pocket);
N
N   // Returns the system traverse rate
W "canon.h" 830 15 Deprecated declaration GET_EXTERNAL_TRAVERSE_RATE - give arg types
Nextern double GET_EXTERNAL_TRAVERSE_RATE();
N#endif                                            /* ifndef CANON_HH */
L 44 "canon_pre.c" 2
N#include <math.h>
L 1 "C:\Keil\ARM\RV31\INC\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 163268 $ Codemist 0.03
N * Checkin $Date: 2010-12-03 13:57:26 +0000 (Fri, 03 Dec 2010) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (1L && 199901L <= 199409L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_SOFTFP __declspec(__nothrow) __softfp
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __pure
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE __inline
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#ifdef __BIG_ENDIAN
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* ndef __BIG_ENDIAN */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* ndef __BIG_ENDIAN */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern __softfp unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Nextern __softfp unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#define HUGE_VAL ((double)__INFINITY__)
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __pure double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __pure double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    __inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    __inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __pure double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __pure double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __pure double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
X__inline __declspec(__nothrow) __pure double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
X__inline __declspec(__nothrow) __pure float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __pure double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __pure float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
X__inline __declspec(__nothrow) __pure float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __pure float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __pure float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
Sextern _ARMABI __int64 llrint(double /*x*/);
Sextern _ARMABI __int64 llrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x)     { return llrint((double)__x); }
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
Sextern _ARMABI __int64 llround(double /*x*/);
Sextern _ARMABI __int64 llroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x)     { return llround((double)__x); }
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __int64 llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __int64 llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __int64 llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __int64 llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S      using ::std::fmal;
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S      using ::std::lrintl;
S      using ::std::llrint;
S      using ::std::llrintf;
S      using ::std::llrintl;
S      using ::std::lround;
S      using ::std::lroundf;
S      using ::std::lroundl;
S      using ::std::llround;
S      using ::std::llroundf;
S      using ::std::llroundl;
S      using ::std::nan;
S      using ::std::nanf;
S      using ::std::nanl;
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S      using ::std::remquol;
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#endif /* __math_h */
N
N/* end of math.h */
L 45 "canon_pre.c" 2
N#include <stdio.h>
L 1 "C:\Keil\ARM\RV31\INC\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 137287 $
N * Checkin $Date: 2008-08-27 13:36:52 +0100 (Wed, 27 Aug 2008) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
L 46 "canon_pre.c" 2
N#include <string.h>
L 1 "C:\Keil\ARM\RV31\INC\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 137748 $
N * Checkin $Date: 2008-09-11 17:34:24 +0100 (Thu, 11 Sep 2008) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
L 47 "canon_pre.c" 2
N#define SET_TO =
N#define IS ==
N#define AND &&
N#define OR ||
N
N   /* where to print */
Nextern FILE * _outfile;
N
N   /* Dummy world model */
N
Nstatic CANON_PLANE       _active_plane = CANON_PLANE_XY;
Xstatic CANON_PLANE       _active_plane = 1;
Nstatic int               _active_slot = 1;
Nstatic double            _feed_rate = 0.0;
Nstatic int               _flood = 0;
Nstatic double            _length_unit_factor = 1; /* 1 for MM 25.4 for inch */
Nstatic CANON_UNITS       _length_unit_type = CANON_UNITS_MM;
Xstatic CANON_UNITS       _length_unit_type = 2;
Nstatic int               _line_number = 1;
Nstatic int               _mist = 0;
Nstatic CANON_MOTION_MODE _motion_mode = CANON_CONTINUOUS;
Xstatic CANON_MOTION_MODE _motion_mode = 3;
N   /*Not static.Driver writes*/
Nchar                     _parameter_file_name[100];
N#ifdef AA
Sstatic double            _probe_position_a = 0;   /*AA*/
N#endif
N#ifdef BB
Sstatic double            _probe_position_b = 0;   /*BB*/
N#endif
N#ifdef CC
Sstatic double            _probe_position_c = 0;   /*CC*/
N#endif
Nstatic double            _probe_position_x = 0;
Nstatic double            _probe_position_y = 0;
Nstatic double            _probe_position_z = 0;
N#ifdef AA
Sstatic double            _program_origin_a = 0;   /*AA*/
N#endif
N#ifdef BB
Sstatic double            _program_origin_b = 0;   /*BB*/
N#endif
N#ifdef CC
Sstatic double            _program_origin_c = 0;   /*CC*/
N#endif
Nstatic double            _program_origin_x = 0;
Nstatic double            _program_origin_y = 0;
Nstatic double            _program_origin_z = 0;
N#ifdef AA
Sstatic double            _program_position_a = 0; /*AA*/
N#endif
N#ifdef BB
Sstatic double            _program_position_b = 0; /*BB*/
N#endif
N#ifdef CC
Sstatic double            _program_position_c = 0; /*CC*/
N#endif
Nstatic double            _program_position_x = 0;
Nstatic double            _program_position_y = 0;
Nstatic double            _program_position_z = 0;
Nstatic double            _spindle_speed;
Nstatic CANON_DIRECTION   _spindle_turning;
Nint                      _tool_max = 68;          /*Not static. Driver reads  */
NCANON_TOOL_TABLE         _tools[CANON_TOOL_MAX];  /*Not static. Driver writes */
XCANON_TOOL_TABLE         _tools[128];   
Nstatic double            _traverse_rate;
N
N   /************************************************************************/
N
N   /* Canonical "Do it" functions
N
N   This is a set of dummy definitions for the canonical machining functions
N   given in canon.hh. These functions just print themselves and, if necessary,
N   update the dummy world model. On each output line is printed:
N   1. an output line number (sequential, starting with 1).
N   2. an input line number read from the input (or ... if not provided).
N   3. a printed representation of the function call which was made.
N
N   If an interpreter which makes these calls is compiled with this set of
N   definitions, it can be used as a translator by redirecting output from
N   stdout to a file.
N
N   */
N
Nextern void rs274ngc_line_text(char * line_text, int max_size);
N
Nvoid print_nc_line_number()
N{
N    char text[256];
N    int k;
N    int m;
N
N    rs274ngc_line_text(text, 256);
N    for (k SET_TO 0;
X    for (k = 0;
N        ((k < 256) AND
X        ((k < 256) &&
N        ((text[k] IS '\t') OR (text[k] IS ' ') OR (text[k] IS '/')));
X        ((text[k] == '\t') || (text[k] == ' ') || (text[k] == '/')));
N        k++);
N    if ((k < 256) AND ((text[k] IS 'n') OR (text[k] IS 'N')))
X    if ((k < 256) && ((text[k] == 'n') || (text[k] == 'N')))
N    {
N        fputc('N', _outfile);
N        for (k++, m SET_TO 0;
X        for (k++, m = 0;
N            ((k < 256) AND (text[k] >= '0') AND (text[k] <= '9'));
X            ((k < 256) && (text[k] >= '0') && (text[k] <= '9'));
N            k++, m++)
N        fputc(text[k], _outfile);
N        for (; m < 6; m++)
N            fputc(' ', _outfile);
N    }
N    else if (k < 256)
N        fprintf(_outfile, "N..... ");
N}
N
N
N#define PRINT0(control) if (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control); \
N} else
X#define PRINT0(control) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control); } else
N#define PRINT1(control, arg1) if (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control, arg1); \
N} else
X#define PRINT1(control, arg1) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control, arg1); } else
N#define PRINT2(control, arg1, arg2) if (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control, arg1, arg2); \
N} else
X#define PRINT2(control, arg1, arg2) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control, arg1, arg2); } else
N#define PRINT3(control, arg1, arg2, arg3) if (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control, arg1, arg2, arg3); \
N} else
X#define PRINT3(control, arg1, arg2, arg3) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control, arg1, arg2, arg3); } else
N#define PRINT4(control, arg1, arg2, arg3, arg4) if (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control, arg1, arg2, arg3, arg4); \
N} else
X#define PRINT4(control, arg1, arg2, arg3, arg4) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control, arg1, arg2, arg3, arg4); } else
N#define PRINT5(control, arg1, arg2, arg3, arg4, arg5) if (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control, arg1, arg2, arg3, arg4, arg5); \
N} else
X#define PRINT5(control, arg1, arg2, arg3, arg4, arg5) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control, arg1, arg2, arg3, arg4, arg5); } else
N#define PRINT6(control, arg1, arg2, arg3, arg4, arg5, arg6) if (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control, arg1, arg2, arg3, arg4, arg5, arg6); \
N} else
X#define PRINT6(control, arg1, arg2, arg3, arg4, arg5, arg6) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control, arg1, arg2, arg3, arg4, arg5, arg6); } else
N#define PRINT7(control, arg1, arg2, arg3, arg4, arg5, arg6, arg7) if (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control, \
N    arg1, arg2, arg3, arg4, arg5, arg6, arg7); \
N} else
X#define PRINT7(control, arg1, arg2, arg3, arg4, arg5, arg6, arg7) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control,     arg1, arg2, arg3, arg4, arg5, arg6, arg7); } else
N#define PRINT10(control,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) \
Nif (1) \
N{ \
N    fprintf(_outfile, "%5d ", _line_number++); \
N    print_nc_line_number(); \
N    fprintf(_outfile, control, \
N    arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); \
N} else
X#define PRINT10(control,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10) if (1) {     fprintf(_outfile, "%5d ", _line_number++);     print_nc_line_number();     fprintf(_outfile, control,     arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10); } else
N
N   /* Representation */
N
N    void SET_ORIGIN_OFFSETS(
N    double x, double y, double z
N#ifdef AA
S    , double a                                    /*AA*/
N#endif
N#ifdef BB
S    , double b                                    /*BB*/
N#endif
N#ifdef CC
S    , double c                                    /*CC*/
N#endif
N    )
N{
N    fprintf(_outfile, "%5d ", _line_number++);
N    print_nc_line_number();
N    fprintf(_outfile, "SET_ORIGIN_OFFSETS(%.4f, %.4f, %.4f"
N    #ifdef AA
S        ", %.4f"                                  /*AA*/
N    #endif
N    #ifdef BB
S        ", %.4f"                                  /*BB*/
N    #endif
N    #ifdef CC
S        ", %.4f"                                  /*CC*/
N    #endif
N        ")\r\n", x, y, z
N    #ifdef AA
S        , a                                       /*AA*/
N    #endif
N    #ifdef BB
S        , b                                       /*BB*/
N    #endif
N    #ifdef CC
S        , c                                       /*CC*/
N    #endif
N        );
N    _program_position_x SET_TO _program_position_x + _program_origin_x - x;
X    _program_position_x = _program_position_x + _program_origin_x - x;
N    _program_position_y SET_TO _program_position_y + _program_origin_y - y;
X    _program_position_y = _program_position_y + _program_origin_y - y;
N    _program_position_z SET_TO _program_position_z + _program_origin_z - z;
X    _program_position_z = _program_position_z + _program_origin_z - z;
N#ifdef AA
S   /*AA*/
S    _program_position_a SET_TO _program_position_a + _program_origin_a - a;
N#endif
N#ifdef BB
S   /*BB*/
S    _program_position_b SET_TO _program_position_b + _program_origin_b - b;
N#endif
N#ifdef CC
S   /*CC*/
S    _program_position_c SET_TO _program_position_c + _program_origin_c - c;
N#endif
N
N    _program_origin_x SET_TO x;
X    _program_origin_x = x;
N    _program_origin_y SET_TO y;
X    _program_origin_y = y;
N    _program_origin_z SET_TO z;
X    _program_origin_z = z;
N#ifdef AA
S    _program_origin_a SET_TO a;                   /*AA*/
N#endif
N#ifdef BB
S    _program_origin_b SET_TO b;                   /*BB*/
N#endif
N#ifdef CC
S    _program_origin_c SET_TO c;                   /*CC*/
N#endif
N}
N
N
Nvoid USE_LENGTH_UNITS(CANON_UNITS in_unit)
N{
N    if (in_unit IS CANON_UNITS_INCHES)
X    if (in_unit == 1)
N    {
N        PRINT0("USE_LENGTH_UNITS(CANON_UNITS_INCHES)\r\n");
X        if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "USE_LENGTH_UNITS(CANON_UNITS_INCHES)\r\n"); } else;
N        if (_length_unit_type IS CANON_UNITS_MM)
X        if (_length_unit_type == 2)
N        {
N            _length_unit_type SET_TO CANON_UNITS_INCHES;
X            _length_unit_type = 1;
N            _length_unit_factor SET_TO 25.4;
X            _length_unit_factor = 25.4;
N            _program_origin_x SET_TO (_program_origin_x / 25.4);
X            _program_origin_x = (_program_origin_x / 25.4);
N            _program_origin_y SET_TO (_program_origin_y / 25.4);
X            _program_origin_y = (_program_origin_y / 25.4);
N            _program_origin_z SET_TO (_program_origin_z / 25.4);
X            _program_origin_z = (_program_origin_z / 25.4);
N            _program_position_x SET_TO (_program_position_x / 25.4);
X            _program_position_x = (_program_position_x / 25.4);
N            _program_position_y SET_TO (_program_position_y / 25.4);
X            _program_position_y = (_program_position_y / 25.4);
N            _program_position_z SET_TO (_program_position_z / 25.4);
X            _program_position_z = (_program_position_z / 25.4);
N        }
N    }
N    else if (in_unit IS CANON_UNITS_MM)
X    else if (in_unit == 2)
N    {
N        PRINT0("USE_LENGTH_UNITS(CANON_UNITS_MM)\r\n");
X        if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "USE_LENGTH_UNITS(CANON_UNITS_MM)\r\n"); } else;
N        if (_length_unit_type IS CANON_UNITS_INCHES)
X        if (_length_unit_type == 1)
N        {
N            _length_unit_type SET_TO CANON_UNITS_MM;
X            _length_unit_type = 2;
N            _length_unit_factor SET_TO 1.0;
X            _length_unit_factor = 1.0;
N            _program_origin_x SET_TO (_program_origin_x * 25.4);
X            _program_origin_x = (_program_origin_x * 25.4);
N            _program_origin_y SET_TO (_program_origin_y * 25.4);
X            _program_origin_y = (_program_origin_y * 25.4);
N            _program_origin_z SET_TO (_program_origin_z * 25.4);
X            _program_origin_z = (_program_origin_z * 25.4);
N            _program_position_x SET_TO (_program_position_x * 25.4);
X            _program_position_x = (_program_position_x * 25.4);
N            _program_position_y SET_TO (_program_position_y * 25.4);
X            _program_position_y = (_program_position_y * 25.4);
N            _program_position_z SET_TO (_program_position_z * 25.4);
X            _program_position_z = (_program_position_z * 25.4);
N        }
N    }
N    else
N        PRINT0("USE_LENGTH_UNITS(UNKNOWN)\r\n");
X        if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "USE_LENGTH_UNITS(UNKNOWN)\r\n"); } else;
N}
N
N
N   /* Free Space Motion */
Nvoid SET_TRAVERSE_RATE(double rate)
N{
N    PRINT1("SET_TRAVERSE_RATE(%.4f)\r\n", rate);
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_TRAVERSE_RATE(%.4f)\r\n", rate); } else;
N    _traverse_rate SET_TO rate;
X    _traverse_rate = rate;
N}
N
N
Nvoid STRAIGHT_TRAVERSE(
Ndouble x, double y, double z
N#ifdef AA
S, double a                                        /*AA*/
N#endif
N#ifdef BB
S, double b                                        /*BB*/
N#endif
N#ifdef CC
S, double c                                        /*CC*/
N#endif
N)
N{
N    fprintf(_outfile, "%5d ", _line_number++);
N    print_nc_line_number();
N    fprintf(_outfile, "STRAIGHT_TRAVERSE(%.4f, %.4f, %.4f"
N    #ifdef AA
S        ", %.4f"                                  /*AA*/
N    #endif
N    #ifdef BB
S        ", %.4f"                                  /*BB*/
N    #endif
N    #ifdef CC
S        ", %.4f"                                  /*CC*/
N    #endif
N        ")\r\n", x, y, z
N    #ifdef AA
S        , a                                       /*AA*/
N    #endif
N    #ifdef BB
S        , b                                       /*BB*/
N    #endif
N    #ifdef CC
S        , c                                       /*CC*/
N    #endif
N        );
N    _program_position_x SET_TO x;
X    _program_position_x = x;
N    _program_position_y SET_TO y;
X    _program_position_y = y;
N    _program_position_z SET_TO z;
X    _program_position_z = z;
N#ifdef AA
S    _program_position_a SET_TO a;                 /*AA*/
N#endif
N#ifdef BB
S    _program_position_b SET_TO b;                 /*BB*/
N#endif
N#ifdef CC
S    _program_position_c SET_TO c;                 /*CC*/
N#endif
N}
N
N
N   /* Machining Attributes */
Nvoid SET_FEED_RATE(double rate)
N{
N    PRINT1("SET_FEED_RATE(%.4f)\r\n", rate);
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_FEED_RATE(%.4f)\r\n", rate); } else;
N    _feed_rate SET_TO rate;
X    _feed_rate = rate;
N}
N
N
Nvoid SET_FEED_REFERENCE(CANON_FEED_REFERENCE reference)
N{
N    PRINT1("SET_FEED_REFERENCE(%s)\r\n",
N        (reference IS CANON_WORKPIECE) ? "CANON_WORKPIECE" : "CANON_XYZ");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_FEED_REFERENCE(%s)\r\n", (reference == 1) ? "CANON_WORKPIECE" : "CANON_XYZ"); } else;
N}
N
N
Nextern void SET_MOTION_CONTROL_MODE(CANON_MOTION_MODE mode)
N{
N    if (mode IS CANON_EXACT_STOP)
X    if (mode == 1)
N    {
N        PRINT0("SET_MOTION_CONTROL_MODE(CANON_EXACT_STOP)\r\n");
X        if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_MOTION_CONTROL_MODE(CANON_EXACT_STOP)\r\n"); } else;
N        _motion_mode SET_TO CANON_EXACT_STOP;
X        _motion_mode = 1;
N    }
N    else if (mode IS CANON_EXACT_PATH)
X    else if (mode == 2)
N    {
N        PRINT0("SET_MOTION_CONTROL_MODE(CANON_EXACT_PATH)\r\n");
X        if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_MOTION_CONTROL_MODE(CANON_EXACT_PATH)\r\n"); } else;
N        _motion_mode SET_TO CANON_EXACT_PATH;
X        _motion_mode = 2;
N    }
N    else if (mode IS CANON_CONTINUOUS)
X    else if (mode == 3)
N    {
N        PRINT0("SET_MOTION_CONTROL_MODE(CANON_CONTINUOUS)\r\n");
X        if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_MOTION_CONTROL_MODE(CANON_CONTINUOUS)\r\n"); } else;
N        _motion_mode SET_TO CANON_CONTINUOUS;
X        _motion_mode = 3;
N    }
N    else
N        PRINT0("SET_MOTION_CONTROL_MODE(UNKNOWN)\r\n");
X        if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_MOTION_CONTROL_MODE(UNKNOWN)\r\n"); } else;
N}
N
N
Nvoid SELECT_PLANE(CANON_PLANE in_plane)
N{
N    PRINT1("SELECT_PLANE(CANON_PLANE_%s)\r\n",
N        ((in_plane IS CANON_PLANE_XY) ? "XY" :
N    (in_plane IS CANON_PLANE_YZ) ? "YZ" :
N    (in_plane IS CANON_PLANE_XZ) ? "XZ" : "UNKNOWN"));
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SELECT_PLANE(CANON_PLANE_%s)\r\n", ((in_plane == 1) ? "XY" : (in_plane == 2) ? "YZ" : (in_plane == 3) ? "XZ" : "UNKNOWN")); } else;
N    _active_plane SET_TO in_plane;
X    _active_plane = in_plane;
N}
N
N
Nvoid SET_CUTTER_RADIUS_COMPENSATION(double radius)
N{PRINT1("SET_CUTTER_RADIUS_COMPENSATION(%.4f)\r\n", radius);}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_CUTTER_RADIUS_COMPENSATION(%.4f)\r\n", radius); } else;}
N
Nvoid START_CUTTER_RADIUS_COMPENSATION(int side)
N{
N    PRINT1("START_CUTTER_RADIUS_COMPENSATION(%s)\r\n",
N        (side IS CANON_SIDE_LEFT)  ? "LEFT"  :
N    (side IS CANON_SIDE_RIGHT) ? "RIGHT" : "UNKNOWN");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "START_CUTTER_RADIUS_COMPENSATION(%s)\r\n", (side == 2) ? "LEFT" : (side == 1) ? "RIGHT" : "UNKNOWN"); } else;
N}
N
N
Nvoid STOP_CUTTER_RADIUS_COMPENSATION()
N{PRINT0 ("STOP_CUTTER_RADIUS_COMPENSATION()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "STOP_CUTTER_RADIUS_COMPENSATION()\r\n"); } else;}
N
Nvoid START_SPEED_FEED_SYNCH()
N{PRINT0 ("START_SPEED_FEED_SYNCH()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "START_SPEED_FEED_SYNCH()\r\n"); } else;}
N
Nvoid STOP_SPEED_FEED_SYNCH()
N{PRINT0 ("STOP_SPEED_FEED_SYNCH()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "STOP_SPEED_FEED_SYNCH()\r\n"); } else;}
N
N   /* Machining Functions */
N
Nvoid ARC_FEED(
Ndouble first_end, double second_end,
Ndouble first_axis, double second_axis, int rotation, double axis_end_point
N#ifdef AA
S, double a                                        /*AA*/
N#endif
N#ifdef BB
S, double b                                        /*BB*/
N#endif
N#ifdef CC
S, double c                                        /*CC*/
N#endif
N)
N{
N    fprintf(_outfile, "%5d ", _line_number++);
N    print_nc_line_number();
N    fprintf(_outfile, "ARC_FEED(%.4f, %.4f, %.4f, %.4f, %d, %.4f"
N    #ifdef AA
S        ", %.4f"                                  /*AA*/
N    #endif
N    #ifdef BB
S        ", %.4f"                                  /*BB*/
N    #endif
N    #ifdef CC
S        ", %.4f"                                  /*CC*/
N    #endif
N        ")\r\n", first_end, second_end, first_axis, second_axis,
N        rotation, axis_end_point
N    #ifdef AA
S        , a                                       /*AA*/
N    #endif
N    #ifdef BB
S        , b                                       /*BB*/
N    #endif
N    #ifdef CC
S        , c                                       /*CC*/
N    #endif
N        );
N    if (_active_plane IS CANON_PLANE_XY)
X    if (_active_plane == 1)
N    {
N        _program_position_x SET_TO first_end;
X        _program_position_x = first_end;
N        _program_position_y SET_TO second_end;
X        _program_position_y = second_end;
N        _program_position_z SET_TO axis_end_point;
X        _program_position_z = axis_end_point;
N    }
N    else if (_active_plane IS CANON_PLANE_YZ)
X    else if (_active_plane == 2)
N    {
N        _program_position_x SET_TO axis_end_point;
X        _program_position_x = axis_end_point;
N        _program_position_y SET_TO first_end;
X        _program_position_y = first_end;
N        _program_position_z SET_TO second_end;
X        _program_position_z = second_end;
N    }
N    else                                          /* if (_active_plane IS CANON_PLANE_XZ) */
N    {
N        _program_position_x SET_TO second_end;
X        _program_position_x = second_end;
N        _program_position_y SET_TO axis_end_point;
X        _program_position_y = axis_end_point;
N        _program_position_z SET_TO first_end;
X        _program_position_z = first_end;
N    }
N#ifdef AA
S    _program_position_a SET_TO a;                 /*AA*/
N#endif
N#ifdef BB
S    _program_position_b SET_TO b;                 /*BB*/
N#endif
N#ifdef CC
S    _program_position_c SET_TO c;                 /*CC*/
N#endif
N}
N
N
Nvoid STRAIGHT_FEED(
Ndouble x, double y, double z
N#ifdef AA
S, double a                                        /*AA*/
N#endif
N#ifdef BB
S, double b                                        /*BB*/
N#endif
N#ifdef CC
S, double c                                        /*CC*/
N#endif
N)
N{
N    fprintf(_outfile, "%5d ", _line_number++);
N    print_nc_line_number();
N    fprintf(_outfile, "STRAIGHT_FEED(%.4f, %.4f, %.4f"
N    #ifdef AA
S        ", %.4f"                                  /*AA*/
N    #endif
N    #ifdef BB
S        ", %.4f"                                  /*BB*/
N    #endif
N    #ifdef CC
S        ", %.4f"                                  /*CC*/
N    #endif
N        ")\r\n", x, y, z
N    #ifdef AA
S        , a                                       /*AA*/
N    #endif
N    #ifdef BB
S        , b                                       /*BB*/
N    #endif
N    #ifdef CC
S        , c                                       /*CC*/
N    #endif
N        );
N    _program_position_x SET_TO x;
X    _program_position_x = x;
N    _program_position_y SET_TO y;
X    _program_position_y = y;
N    _program_position_z SET_TO z;
X    _program_position_z = z;
N#ifdef AA
S    _program_position_a SET_TO a;                 /*AA*/
N#endif
N#ifdef BB
S    _program_position_b SET_TO b;                 /*BB*/
N#endif
N#ifdef CC
S    _program_position_c SET_TO c;                 /*CC*/
N#endif
N}
N
N
N   /* This models backing the probe off 0.01 inch or 0.254 mm from the probe
N   point towards the previous location after the probing, if the probe
N   point is not the same as the previous point -- which it should not be. */
N
Nvoid STRAIGHT_PROBE(
Ndouble x, double y, double z
N#ifdef AA
S, double a                                        /*AA*/
N#endif
N#ifdef BB
S, double b                                        /*BB*/
N#endif
N#ifdef CC
S, double c                                        /*CC*/
N#endif
N)
N{
N    double distance;
N    double dx, dy, dz;
N    double backoff;
N
N    dx SET_TO (_program_position_x - x);
X    dx = (_program_position_x - x);
N    dy SET_TO (_program_position_y - y);
X    dy = (_program_position_y - y);
N    dz SET_TO (_program_position_z - z);
X    dz = (_program_position_z - z);
N    distance SET_TO sqrt((dx * dx) + (dy * dy) + (dz * dz));
X    distance = sqrt((dx * dx) + (dy * dy) + (dz * dz));
N
N    fprintf(_outfile, "%5d ", _line_number++);
N    print_nc_line_number();
N    fprintf(_outfile, "STRAIGHT_PROBE(%.4f, %.4f, %.4f"
N    #ifdef AA
S        ", %.4f"                                  /*AA*/
N    #endif
N    #ifdef BB
S        ", %.4f"                                  /*BB*/
N    #endif
N    #ifdef CC
S        ", %.4f"                                  /*CC*/
N    #endif
N        ")\r\n", x, y, z
N    #ifdef AA
S        , a                                       /*AA*/
N    #endif
N    #ifdef BB
S        , b                                       /*BB*/
N    #endif
N    #ifdef CC
S        , c                                       /*CC*/
N    #endif
N        );
N    _probe_position_x SET_TO x;
X    _probe_position_x = x;
N    _probe_position_y SET_TO y;
X    _probe_position_y = y;
N    _probe_position_z SET_TO z;
X    _probe_position_z = z;
N#ifdef AA
S    _probe_position_a SET_TO a;                   /*AA*/
N#endif
N#ifdef BB
S    _probe_position_b SET_TO b;                   /*BB*/
N#endif
N#ifdef CC
S    _probe_position_c SET_TO c;                   /*CC*/
N#endif
N    if (distance IS 0)
X    if (distance == 0)
N    {
N        _program_position_x SET_TO _program_position_x;
X        _program_position_x = _program_position_x;
N        _program_position_y SET_TO _program_position_y;
X        _program_position_y = _program_position_y;
N        _program_position_z SET_TO _program_position_z;
X        _program_position_z = _program_position_z;
N    }
N    else
N    {
N        backoff SET_TO ((_length_unit_type IS CANON_UNITS_MM) ? 0.254 : 0.01);
X        backoff = ((_length_unit_type == 2) ? 0.254 : 0.01);
N        _program_position_x SET_TO (x + (backoff * (dx / distance)));
X        _program_position_x = (x + (backoff * (dx / distance)));
N        _program_position_y SET_TO (y + (backoff * (dy / distance)));
X        _program_position_y = (y + (backoff * (dy / distance)));
N        _program_position_z SET_TO (z + (backoff * (dz / distance)));
X        _program_position_z = (z + (backoff * (dz / distance)));
N    }
N#ifdef AA
S    _program_position_a SET_TO a;                 /*AA*/
N#endif
N#ifdef BB
S    _program_position_b SET_TO b;                 /*BB*/
N#endif
N#ifdef CC
S    _program_position_c SET_TO c;                 /*CC*/
N#endif
N}
N
N
N   /*
N   void PARAMETRIC_2D_CURVE_FEED(FunctionPtr f1, FunctionPtr f2,
N                     double start_parameter_value,
N   double end_parameter_value) {}
N
N   void PARAMETRIC_3D_CURVE_FEED(FunctionPtr xfcn, FunctionPtr yfcn,
N   FunctionPtr zfcn, double start_parameter_value,
N   double end_parameter_value) {}
N   */
N
Nvoid DWELL(double seconds)
N{PRINT1("DWELL(%.4f)\r\n", seconds);}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "DWELL(%.4f)\r\n", seconds); } else;}
N
N   /* Spindle Functions */
Nvoid SPINDLE_RETRACT_TRAVERSE()
N{PRINT0("SPINDLE_RETRACT_TRAVERSE()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SPINDLE_RETRACT_TRAVERSE()\r\n"); } else;}
N
Nvoid START_SPINDLE_CLOCKWISE()
N{
N    PRINT0("START_SPINDLE_CLOCKWISE()\r\n");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "START_SPINDLE_CLOCKWISE()\r\n"); } else;
N    _spindle_turning SET_TO ((_spindle_speed IS 0) ? CANON_STOPPED :
X    _spindle_turning = ((_spindle_speed == 0) ? 1 :
N    CANON_CLOCKWISE);
X    2);
N}
N
N
Nvoid START_SPINDLE_COUNTERCLOCKWISE()
N{
N    PRINT0("START_SPINDLE_COUNTERCLOCKWISE()\r\n");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "START_SPINDLE_COUNTERCLOCKWISE()\r\n"); } else;
N    _spindle_turning SET_TO ((_spindle_speed IS 0) ? CANON_STOPPED :
X    _spindle_turning = ((_spindle_speed == 0) ? 1 :
N    CANON_COUNTERCLOCKWISE);
X    3);
N}
N
N
Nvoid SET_SPINDLE_SPEED(double rpm)
N{
N    PRINT1("SET_SPINDLE_SPEED(%.4f)\r\n", rpm);
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SET_SPINDLE_SPEED(%.4f)\r\n", rpm); } else;
N    _spindle_speed SET_TO rpm;
X    _spindle_speed = rpm;
N}
N
N
Nvoid STOP_SPINDLE_TURNING()
N{
N    PRINT0("STOP_SPINDLE_TURNING()\r\n");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "STOP_SPINDLE_TURNING()\r\n"); } else;
N    _spindle_turning SET_TO CANON_STOPPED;
X    _spindle_turning = 1;
N}
N
N
Nvoid SPINDLE_RETRACT()
N{PRINT0("SPINDLE_RETRACT()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SPINDLE_RETRACT()\r\n"); } else;}
N
Nvoid ORIENT_SPINDLE(double orientation, CANON_DIRECTION direction)
N{
N    PRINT2("ORIENT_SPINDLE(%.4f, %s)\r\n", orientation,
N        (direction IS CANON_CLOCKWISE) ? "CANON_CLOCKWISE" :
N    "CANON_COUNTERCLOCKWISE");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "ORIENT_SPINDLE(%.4f, %s)\r\n", orientation, (direction == 2) ? "CANON_CLOCKWISE" : "CANON_COUNTERCLOCKWISE"); } else;
N}
N
N
Nvoid USE_NO_SPINDLE_FORCE()
N{PRINT0("USE_NO_SPINDLE_FORCE()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "USE_NO_SPINDLE_FORCE()\r\n"); } else;}
N
N   /* Tool Functions */
N
Nvoid USE_TOOL_LENGTH_OFFSET(double length)
N{PRINT1("USE_TOOL_LENGTH_OFFSET(%.4f)\r\n", length);}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "USE_TOOL_LENGTH_OFFSET(%.4f)\r\n", length); } else;}
N
Nvoid CHANGE_TOOL(int slot)
N{
N    PRINT1("CHANGE_TOOL(%d)\r\n", slot);
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "CHANGE_TOOL(%d)\r\n", slot); } else;
N    _active_slot SET_TO slot;
X    _active_slot = slot;
N}
N
Nvoid SELECT_TOOL(int slot)
N{PRINT1("SELECT_TOOL(%d)\r\n", slot);}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "SELECT_TOOL(%d)\r\n", slot); } else;}
N
N   /* Misc Functions */
N
Nvoid CLAMP_AXIS(CANON_AXIS axis)
N{
N    PRINT1("CLAMP_AXIS(%s)\r\n",
N        (axis IS CANON_AXIS_X) ? "CANON_AXIS_X" :
N    (axis IS CANON_AXIS_Y) ? "CANON_AXIS_Y" :
N    (axis IS CANON_AXIS_Z) ? "CANON_AXIS_Z" :
N    (axis IS CANON_AXIS_A) ? "CANON_AXIS_A" :
N    (axis IS CANON_AXIS_C) ? "CANON_AXIS_C" : "UNKNOWN");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "CLAMP_AXIS(%s)\r\n", (axis == 1) ? "CANON_AXIS_X" : (axis == 2) ? "CANON_AXIS_Y" : (axis == 3) ? "CANON_AXIS_Z" : (axis == 4) ? "CANON_AXIS_A" : (axis == 6) ? "CANON_AXIS_C" : "UNKNOWN"); } else;
N}
N
N
Nvoid COMMENT(char *s)
N{PRINT1("COMMENT(\"%s\")\r\n", s);}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "COMMENT(\"%s\")\r\n", s); } else;}
N
Nvoid DISABLE_FEED_OVERRIDE()
N{PRINT0("DISABLE_FEED_OVERRIDE()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "DISABLE_FEED_OVERRIDE()\r\n"); } else;}
N
Nvoid DISABLE_SPEED_OVERRIDE()
N{PRINT0("DISABLE_SPEED_OVERRIDE()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "DISABLE_SPEED_OVERRIDE()\r\n"); } else;}
N
Nvoid ENABLE_FEED_OVERRIDE()
N{PRINT0("ENABLE_FEED_OVERRIDE()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "ENABLE_FEED_OVERRIDE()\r\n"); } else;}
N
Nvoid ENABLE_SPEED_OVERRIDE()
N{PRINT0("ENABLE_SPEED_OVERRIDE()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "ENABLE_SPEED_OVERRIDE()\r\n"); } else;}
N
Nvoid FLOOD_OFF()
N{
N    PRINT0("FLOOD_OFF()\r\n");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "FLOOD_OFF()\r\n"); } else;
N    _flood SET_TO 0;
X    _flood = 0;
N}
N
N
Nvoid FLOOD_ON()
N{
N    PRINT0("FLOOD_ON()\r\n");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "FLOOD_ON()\r\n"); } else;
N    _flood SET_TO 1;
X    _flood = 1;
N}
N
N
Nvoid INIT_CANON()
N{
N}
N
N
Nvoid MESSAGE(char *s)
N{PRINT1("MESSAGE(\"%s\")\r\n", s);}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "MESSAGE(\"%s\")\r\n", s); } else;}
N
Nvoid MIST_OFF()
N{
N    PRINT0("MIST_OFF()\r\n");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "MIST_OFF()\r\n"); } else;
N    _mist SET_TO 0;
X    _mist = 0;
N}
N
N
Nvoid MIST_ON()
N{
N    PRINT0("MIST_ON()\r\n");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "MIST_ON()\r\n"); } else;
N    _mist SET_TO 1;
X    _mist = 1;
N}
N
N
Nvoid PALLET_SHUTTLE()
N{PRINT0("PALLET_SHUTTLE()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "PALLET_SHUTTLE()\r\n"); } else;}
N
Nvoid TURN_PROBE_OFF()
N{PRINT0("TURN_PROBE_OFF()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "TURN_PROBE_OFF()\r\n"); } else;}
N
Nvoid TURN_PROBE_ON()
N{PRINT0("TURN_PROBE_ON()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "TURN_PROBE_ON()\r\n"); } else;}
N
Nvoid UNCLAMP_AXIS(CANON_AXIS axis)
N{
N    PRINT1("UNCLAMP_AXIS(%s)\r\n",
N        (axis IS CANON_AXIS_X) ? "CANON_AXIS_X" :
N    (axis IS CANON_AXIS_Y) ? "CANON_AXIS_Y" :
N    (axis IS CANON_AXIS_Z) ? "CANON_AXIS_Z" :
N    (axis IS CANON_AXIS_A) ? "CANON_AXIS_A" :
N    (axis IS CANON_AXIS_B) ? "CANON_AXIS_B" :
N    (axis IS CANON_AXIS_C) ? "CANON_AXIS_C" : "UNKNOWN");
X    if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "UNCLAMP_AXIS(%s)\r\n", (axis == 1) ? "CANON_AXIS_X" : (axis == 2) ? "CANON_AXIS_Y" : (axis == 3) ? "CANON_AXIS_Z" : (axis == 4) ? "CANON_AXIS_A" : (axis == 5) ? "CANON_AXIS_B" : (axis == 6) ? "CANON_AXIS_C" : "UNKNOWN"); } else;
N}
N
N
N   /* Program Functions */
N
Nvoid PROGRAM_STOP()
N{PRINT0("PROGRAM_STOP()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "PROGRAM_STOP()\r\n"); } else;}
N
Nvoid OPTIONAL_PROGRAM_STOP()
N{PRINT0("OPTIONAL_PROGRAM_STOP()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "OPTIONAL_PROGRAM_STOP()\r\n"); } else;}
N
Nvoid PROGRAM_END()
N{PRINT0("PROGRAM_END()\r\n");}
X{if (1) { fprintf(_outfile, "%5d ", _line_number++); print_nc_line_number(); fprintf(_outfile, "PROGRAM_END()\r\n"); } else;}
N
N   /*************************************************************************/
N
N   /* Canonical "Give me information" functions
N
N   In general, returned values are valid only if any canonical do it commands
N   that may have been called for have been executed to completion. If a function
N   returns a valid value regardless of execution, that is noted in the comments
N   below.
N
N   */
N
N   /* The interpreter is not using this function
N   // Returns the system angular unit factor, in units / degree
N   extern double GET_EXTERNAL_ANGLE_UNIT_FACTOR()
N   {
N   return 1;
N   }
N   */
N
N   /* Returns the system feed rate */
Ndouble GET_EXTERNAL_FEED_RATE()
N{
N    return _feed_rate;
N}
N
N
N   /* Returns the system flood coolant setting zero = off, non-zero = on */
Nint GET_EXTERNAL_FLOOD()
N{
N    return _flood;
N}
N
N
N   /* Returns the system length unit factor, in units per mm */
Nextern double GET_EXTERNAL_LENGTH_UNIT_FACTOR()
N{
N    return 1/_length_unit_factor;
N}
N
N
N   /* Returns the system length unit type */
NCANON_UNITS GET_EXTERNAL_LENGTH_UNIT_TYPE()
N{
N    return _length_unit_type;
N}
N
N
N   /* Returns the system mist coolant setting zero = off, non-zero = on */
Nextern int GET_EXTERNAL_MIST()
N{
N    return _mist;
N}
N
N
N   // Returns the current motion control mode
Nextern CANON_MOTION_MODE GET_EXTERNAL_MOTION_CONTROL_MODE()
N{
N    return _motion_mode;
N}
N
N
N   /* The interpreter is not using these six GET_EXTERNAL_ORIGIN functions
N
N   #ifdef AA
N   // returns the current a-axis origin offset
N   double GET_EXTERNAL_ORIGIN_A()
N   {
N   return _program_origin_a;
N   }
N   #endif
N
N   #ifdef BB
N   // returns the current b-axis origin offset
N   double GET_EXTERNAL_ORIGIN_B()
N   {
N   return _program_origin_b;
N   }
N   #endif
N
N   #ifdef CC
N   // returns the current c-axis origin offset
N   double GET_EXTERNAL_ORIGIN_C()
N   {
N   return _program_origin_c;
N   }
N   #endif
N
N   // returns the current x-axis origin offset
N   double GET_EXTERNAL_ORIGIN_X()
N   {
N   return _program_origin_x;
N   }
N
N   // returns the current y-axis origin offset
N   double GET_EXTERNAL_ORIGIN_Y()
N   {
N   return _program_origin_y;
N   }
N
N   // returns the current z-axis origin offset
N   double GET_EXTERNAL_ORIGIN_Z()
N   {
N   return _program_origin_z;
N   }
N
N   */
N
Nvoid GET_EXTERNAL_PARAMETER_FILE_NAME(
Nchar * file_name,                                 /* string: to copy file name into       */
Nunsigned int max_size)                                     /* maximum number of characters to copy */
N{
N    if (strlen(_parameter_file_name) < max_size)
N        strcpy(file_name, _parameter_file_name);
N    else
N        file_name[0] SET_TO 0;
X        file_name[0] = 0;
N}
N
N
NCANON_PLANE GET_EXTERNAL_PLANE()
N{
N    return _active_plane;
N}
N
N
N#ifdef AA
S   /* returns the current a-axis position */
Sdouble GET_EXTERNAL_POSITION_A()
S{
S    return _program_position_a;
S}
N#endif
N
N#ifdef BB
S   /* returns the current b-axis position */
Sdouble GET_EXTERNAL_POSITION_B()
S{
S    return _program_position_b;
S}
N#endif
N
N#ifdef CC
S   /* returns the current c-axis position */
Sdouble GET_EXTERNAL_POSITION_C()
S{
S    return _program_position_c;
S}
N#endif
N
N   /* returns the current x-axis position */
Ndouble GET_EXTERNAL_POSITION_X()
N{
N    return _program_position_x;
N}
N
N
N   /* returns the current y-axis position */
Ndouble GET_EXTERNAL_POSITION_Y()
N{
N    return _program_position_y;
N}
N
N
N   /* returns the current z-axis position */
Ndouble GET_EXTERNAL_POSITION_Z()
N{
N    return _program_position_z;
N}
N
N
N#ifdef AA
S   /* returns the a-axis position at the last probe trip. This is only valid
S      once the probe command has executed to completion. */
Sdouble GET_EXTERNAL_PROBE_POSITION_A()
S{
S    return _probe_position_a;
S}
N#endif
N
N#ifdef BB
S   /* returns the b-axis position at the last probe trip. This is only valid
S      once the probe command has executed to completion. */
Sdouble GET_EXTERNAL_PROBE_POSITION_B()
S{
S    return _probe_position_b;
S}
N#endif
N
N#ifdef CC
S   /* returns the c-axis position at the last probe trip. This is only valid
S      once the probe command has executed to completion. */
Sdouble GET_EXTERNAL_PROBE_POSITION_C()
S{
S    return _probe_position_c;
S}
N#endif
N
N   /* returns the x-axis position at the last probe trip. This is only valid
N      once the probe command has executed to completion. */
Ndouble GET_EXTERNAL_PROBE_POSITION_X()
N{
N    return _probe_position_x;
N}
N
N
N   /* returns the y-axis position at the last probe trip. This is only valid
N      once the probe command has executed to completion. */
Ndouble GET_EXTERNAL_PROBE_POSITION_Y()
N{
N    return _probe_position_y;
N}
N
N
N   /* returns the z-axis position at the last probe trip. This is only valid
N      once the probe command has executed to completion. */
Ndouble GET_EXTERNAL_PROBE_POSITION_Z()
N{
N    return _probe_position_z;
N}
N
N
N   /* Returns the value for any analog non-contact probing. */
N   /* This is a dummy of a dummy, returning a useless value. */
N   /* It is not expected this will ever be called. */
Nextern double GET_EXTERNAL_PROBE_VALUE()
N{
N    return 1.0;
N}
N
N
N   /* Returns zero if queue is not empty, non-zero if the queue is empty */
N   /* In the stand-alone interpreter, there is no queue, so it is always empty */
Nextern int GET_EXTERNAL_QUEUE_EMPTY()
N{
N    return 1;
N}
N
N
N   /* Returns the system value for spindle speed in rpm */
Ndouble GET_EXTERNAL_SPEED()
N{
N    return _spindle_speed;
N}
N
N
N   /* Returns the system value for direction of spindle turning */
Nextern CANON_DIRECTION GET_EXTERNAL_SPINDLE()
N{
N    return _spindle_turning;
N}
N
N
N   /* Returns the system value for the carousel slot in which the tool
N   currently in the spindle belongs. Return value zero means there is no
N   tool in the spindle. */
Nextern int GET_EXTERNAL_TOOL_SLOT()
N{
N    return _active_slot;
N}
N
N
N   /* Returns maximum number of tools */
Nint GET_EXTERNAL_TOOL_MAX()
N{
N    return _tool_max;
N}
N
N
N   /* Returns the CANON_TOOL_TABLE structure associated with the tool
N      in the given pocket */
Nextern CANON_TOOL_TABLE GET_EXTERNAL_TOOL_TABLE(int pocket)
N{
N    return _tools[pocket];
N}
N
N
N   /* Returns the system traverse rate */
Ndouble GET_EXTERNAL_TRAVERSE_RATE()
N{
N    return _traverse_rate;
N}
