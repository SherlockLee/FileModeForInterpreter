; generated by ARM C/C++ Compiler with , RVCT4.0 [Build 524] for uVision
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\main.o --depend=.\obj\main.d --device=DARMSTM --apcs=interwork -O0 -I..\..\library\inc -I..\..\library\src -I..\uvsion -ID:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\obj\main.crf main.c]
                          THUMB

                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  GPIO_Configuration PROC
;;;175    *******************************************************************************/
;;;176    void GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;177    {
;;;178      GPIO_InitTypeDef GPIO_InitStructure;
;;;179    
;;;180      /* Configure USART1 Tx (PA.09) as alternate function push-pull */
;;;181      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000002  f44f7000          MOV      r0,#0x200
000006  f8ad0000          STRH     r0,[sp,#0]
;;;182      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00000a  2018              MOVS     r0,#0x18
00000c  f88d0003          STRB     r0,[sp,#3]
;;;183      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2003              MOVS     r0,#3
000012  f88d0002          STRB     r0,[sp,#2]
;;;184      GPIO_Init(GPIOA, &GPIO_InitStructure);
000016  4669              MOV      r1,sp
000018  4807              LDR      r0,|L1.56|
00001a  f7fffffe          BL       GPIO_Init
;;;185        
;;;186      /* Configure USART1 Rx (PA.10) as input floating */
;;;187      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00001e  f44f6080          MOV      r0,#0x400
000022  f8ad0000          STRH     r0,[sp,#0]
;;;188      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000026  2004              MOVS     r0,#4
000028  f88d0003          STRB     r0,[sp,#3]
;;;189      GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4802              LDR      r0,|L1.56|
000030  f7fffffe          BL       GPIO_Init
;;;190    }
000034  bd08              POP      {r3,pc}
;;;191    
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;157    *******************************************************************************/
;;;158    void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;159    {
;;;160    #ifdef  VECT_TAB_RAM  
;;;161      /* Set the Vector Table base location at 0x20000000 */ 
;;;162      NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0); 
;;;163    #else  /* VECT_TAB_FLASH  */
;;;164      /* Set the Vector Table base location at 0x08000000 */ 
;;;165      NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);   
000002  2100              MOVS     r1,#0
000004  f04f6000          MOV      r0,#0x8000000
000008  f7fffffe          BL       NVIC_SetVectorTable
;;;166    #endif
;;;167    }
00000c  bd10              POP      {r4,pc}
;;;168    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=2

                  RCC_Configuration PROC
;;;99     *******************************************************************************/
;;;100    void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102      /* RCC system reset(for debug purpose) */
;;;103      RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;104    
;;;105      /* Enable HSE */
;;;106      RCC_HSEConfig(RCC_HSE_ON);
000006  f44f3080          MOV      r0,#0x10000
00000a  f7fffffe          BL       RCC_HSEConfig
;;;107    
;;;108      /* Wait till HSE is ready */
;;;109      HSEStartUpStatus = RCC_WaitForHSEStartUp();
00000e  f7fffffe          BL       RCC_WaitForHSEStartUp
000012  4919              LDR      r1,|L3.120|
000014  7008              STRB     r0,[r1,#0]
;;;110    
;;;111      if(HSEStartUpStatus == SUCCESS)
000016  4608              MOV      r0,r1
000018  7800              LDRB     r0,[r0,#0]  ; HSEStartUpStatus
00001a  2801              CMP      r0,#1
00001c  d126              BNE      |L3.108|
;;;112      {
;;;113        /* HCLK = SYSCLK */
;;;114        RCC_HCLKConfig(RCC_SYSCLK_Div1); 
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       RCC_HCLKConfig
;;;115      
;;;116        /* PCLK2 = HCLK */
;;;117        RCC_PCLK2Config(RCC_HCLK_Div1); 
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       RCC_PCLK2Config
;;;118    
;;;119        /* PCLK1 = HCLK/2 */
;;;120        RCC_PCLK1Config(RCC_HCLK_Div2);
00002a  f44f6080          MOV      r0,#0x400
00002e  f7fffffe          BL       RCC_PCLK1Config
;;;121    
;;;122        /* Flash 2 wait state */
;;;123        FLASH_SetLatency(FLASH_Latency_2);
000032  2002              MOVS     r0,#2
000034  f7fffffe          BL       FLASH_SetLatency
;;;124        /* Enable Prefetch Buffer */
;;;125        FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
000038  2010              MOVS     r0,#0x10
00003a  f7fffffe          BL       FLASH_PrefetchBufferCmd
;;;126    
;;;127        /* PLLCLK = 8MHz * 9 = 72 MHz */
;;;128        RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_9);
00003e  f44f11e0          MOV      r1,#0x1c0000
000042  f44f3080          MOV      r0,#0x10000
000046  f7fffffe          BL       RCC_PLLConfig
;;;129    
;;;130        /* Enable PLL */ 
;;;131        RCC_PLLCmd(ENABLE);
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       RCC_PLLCmd
;;;132    
;;;133        /* Wait till PLL is ready */
;;;134        while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)
000050  bf00              NOP      
                  |L3.82|
000052  2039              MOVS     r0,#0x39
000054  f7fffffe          BL       RCC_GetFlagStatus
000058  2800              CMP      r0,#0
00005a  d0fa              BEQ      |L3.82|
;;;135        {
;;;136        }
;;;137    
;;;138        /* Select PLL as system clock source */
;;;139        RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00005c  2002              MOVS     r0,#2
00005e  f7fffffe          BL       RCC_SYSCLKConfig
;;;140    
;;;141        /* Wait till PLL is used as system clock source */
;;;142        while(RCC_GetSYSCLKSource() != 0x08)
000062  bf00              NOP      
                  |L3.100|
000064  f7fffffe          BL       RCC_GetSYSCLKSource
000068  2808              CMP      r0,#8
00006a  d1fb              BNE      |L3.100|
                  |L3.108|
;;;143        {
;;;144        }
;;;145      }
;;;146       
;;;147      /* Enable USART1 and GPIOA clock */
;;;148      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  f2440004          MOV      r0,#0x4004
000072  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;149    }
000076  bd10              POP      {r4,pc}
;;;150    
                          ENDP

                  |L3.120|
                          DCD      HSEStartUpStatus

                          AREA ||i.USART_Configuration||, CODE, READONLY, ALIGN=2

                  USART_Configuration PROC
;;;198    *******************************************************************************/
;;;199    void USART_Configuration(void)
000000  b500              PUSH     {lr}
;;;200    {
000002  b087              SUB      sp,sp,#0x1c
;;;201      USART_InitTypeDef USART_InitStructure;
;;;202      USART_ClockInitTypeDef  USART_ClockInitStructure;
;;;203    /* USART1 configuration -----------------------------------------------
;;;204    
;;;205    -------*/
;;;206      /* USART1 configured as follow:
;;;207            - BaudRate = 115200 baud  
;;;208            - Word Length = 8 Bits
;;;209            - One Stop Bit
;;;210            - No parity
;;;211            - Hardware flow control disabled (RTS and CTS signals)
;;;212            - Receive and transmit enabled
;;;213            - USART Clock disabled
;;;214            - USART CPOL: Clock is active low
;;;215            - USART CPHA: Data is captured on the middle 
;;;216            - USART LastBit: The clock pulse of the last data bit is not 
;;;217    
;;;218    output to 
;;;219                             the SCLK pin
;;;220      */
;;;221    USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
000004  2000              MOVS     r0,#0
000006  f8ad0004          STRH     r0,[sp,#4]
;;;222    USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
00000a  f8ad0006          STRH     r0,[sp,#6]
;;;223    USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
00000e  f44f7000          MOV      r0,#0x200
000012  f8ad0008          STRH     r0,[sp,#8]
;;;224    USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
000016  2000              MOVS     r0,#0
000018  f8ad000a          STRH     r0,[sp,#0xa]
;;;225    /* Configure the USART1 synchronous paramters */
;;;226    USART_ClockInit(USART1, &USART_ClockInitStructure);
00001c  a901              ADD      r1,sp,#4
00001e  480e              LDR      r0,|L4.88|
000020  f7fffffe          BL       USART_ClockInit
;;;227    
;;;228    USART_InitStructure.USART_BaudRate = 115200;
000024  f44f30e1          MOV      r0,#0x1c200
000028  9003              STR      r0,[sp,#0xc]
;;;229    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00002a  2000              MOVS     r0,#0
00002c  f8ad0010          STRH     r0,[sp,#0x10]
;;;230    USART_InitStructure.USART_StopBits = USART_StopBits_1;
000030  f8ad0012          STRH     r0,[sp,#0x12]
;;;231    USART_InitStructure.USART_Parity = USART_Parity_No ;
000034  f8ad0014          STRH     r0,[sp,#0x14]
;;;232    USART_InitStructure.USART_HardwareFlowControl = 
000038  f8ad0018          STRH     r0,[sp,#0x18]
;;;233    
;;;234    USART_HardwareFlowControl_None;
;;;235    
;;;236    
;;;237    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00003c  200c              MOVS     r0,#0xc
00003e  f8ad0016          STRH     r0,[sp,#0x16]
;;;238    /* Configure USART1 basic and asynchronous paramters */
;;;239    USART_Init(USART1, &USART_InitStructure);
000042  a903              ADD      r1,sp,#0xc
000044  4804              LDR      r0,|L4.88|
000046  f7fffffe          BL       USART_Init
;;;240        
;;;241      /* Enable USART1 */
;;;242      USART_Cmd(USART1, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  4802              LDR      r0,|L4.88|
00004e  f7fffffe          BL       USART_Cmd
;;;243    }
000052  b007              ADD      sp,sp,#0x1c
000054  bd00              POP      {pc}
;;;244    
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;251    *******************************************************************************/
;;;252    int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;253    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;254      /* Place your implementation of fputc here */
;;;255      /* e.g. write a character to the USART */
;;;256      USART_SendData(USART1, (u8) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L5.32|
00000a  f7fffffe          BL       USART_SendData
;;;257    
;;;258      /* Loop until the end of transmission */
;;;259      while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
00000e  bf00              NOP      
                  |L5.16|
000010  2140              MOVS     r1,#0x40
000012  4803              LDR      r0,|L5.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L5.16|
;;;260      {
;;;261      }
;;;262    
;;;263      return ch;
00001c  4620              MOV      r0,r4
;;;264    }
00001e  bd70              POP      {r4-r6,pc}
;;;265    
                          ENDP

                  |L5.32|
                          DCD      0x40013800

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;32     *******************************************************************************/
;;;33     int main(void)
000000  b510              PUSH     {r4,lr}
;;;34     {  u16 i=0;
000002  2400              MOVS     r4,#0
;;;35        
;;;36        
;;;37     #ifdef DEBUG
;;;38       debug();
;;;39     #endif
;;;40     
;;;41       /* Configure the system clocks */
;;;42       RCC_Configuration();
000004  f7fffffe          BL       RCC_Configuration
;;;43         
;;;44       /* NVIC Configuration */
;;;45       NVIC_Configuration();
000008  f7fffffe          BL       NVIC_Configuration
;;;46     
;;;47       /* Configure the GPIOs */
;;;48       GPIO_Configuration();
00000c  f7fffffe          BL       GPIO_Configuration
;;;49       
;;;50       /* Configure the USART1 */
;;;51       USART_Configuration();
000010  f7fffffe          BL       USART_Configuration
;;;52     
;;;53       
;;;54       printf("\r\n Welcome to www.PowerAVR.com \r\n");
000014  a00b              ADR      r0,|L6.68|
000016  f7fffffe          BL       __2printf
;;;55       printf("\r\n Please Input Character From Keyboard \r\n");
00001a  a013              ADR      r0,|L6.104|
00001c  f7fffffe          BL       __2printf
;;;56     while(1	)
000020  e00e              B        |L6.64|
                  |L6.34|
;;;57     	{	
;;;58     		if(USART_GetFlagStatus(USART1,USART_IT_RXNE)==SET)
000022  f2405125          MOV      r1,#0x525
000026  481b              LDR      r0,|L6.148|
000028  f7fffffe          BL       USART_GetFlagStatus
00002c  2801              CMP      r0,#1
00002e  d107              BNE      |L6.64|
;;;59     		{	           
;;;60     			i = USART_ReceiveData(USART1);
000030  4818              LDR      r0,|L6.148|
000032  f7fffffe          BL       USART_ReceiveData
000036  4604              MOV      r4,r0
;;;61     			printf("  %c",i&0xFF);	   /* print the input char */
000038  b2e1              UXTB     r1,r4
00003a  a017              ADR      r0,|L6.152|
00003c  f7fffffe          BL       __2printf
                  |L6.64|
000040  e7ef              B        |L6.34|
;;;62     					
;;;63     		}
;;;64     	}
;;;65     
;;;66     }
;;;67     
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
000044  0d0a2057656c636f6d6520746f207777772e506f7765724156522e636f6d200d0a00        DCB      "\r\n Welcome to www.PowerAVR.com \r\n",0
000066  00                DCB      0
000067  00                DCB      0
                  |L6.104|
000068  0d0a20506c6561736520496e707574204368617261637465722046726f6d204b6579626f617264200d0a00        DCB      "\r\n Please Input Character From Keyboard \r\n",0
000093  00                DCB      0
                  |L6.148|
                          DCD      0x40013800
                  |L6.152|
000098  2020256300        DCB      "  %c",0
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
